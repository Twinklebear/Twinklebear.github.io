

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<title>Blog</title>
	
    <meta name="author" content="Will Usher">

	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

	<!-- Should I be including font-awesome from bootstrap? Or just the 5.0 version? -->
    <!--<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>-->
    <script defer src="https://kit.fontawesome.com/b56adde3a3.js" crossorigin="anonymous"></script>

	<link href="/assets/syntax.css" rel="stylesheet">
	<link href="/assets/custom.css" rel="stylesheet">
	<link rel="shortcut icon" href="/assets/img/identicon.ico">

</head>
<body>
	<nav class="navbar navbar-expand-md navbar-dark bg-dark static-top">
		<div class="container">
			<a class="navbar-brand" href="/">Will Usher</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
				data-target="#navbar_responsive" aria-controls="navbarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbar_responsive">
				<ul class="navbar-nav mr-auto">
				
				
				  
					
					  
					  
						<li class="nav-item"><a href="/projects" class="nav-link">
							Projects</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item active"><a href="/blog" class="nav-link">
							Blog</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/pages/sdl2" class="nav-link">
							SDL2 Tutorials</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/news" class="nav-link">
							News</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/archive" class="nav-link">
							Archive</a></li>
						
					  
					
				  
				</ul>
			</div><!-- nav.collaps -->
		</div>
	</nav>

	<div class="container content mb-4">
		


<div class="row mt-4 justify-content-center">
	
	<div class="col-9 mb-2">
		<a href="/graphics/2019/11/20/the-sbt-three-ways"><h3>The RTX Shader Binding Table Three Ways</h3></a>
		<b>20 Nov 2019</b>
		
<p>DirectX Ray Tracing, Vulkan’s NV Ray Tracing extension, and OptiX (or collectively, the RTX APIs)
build on the same execution model for running user code to trace
and process rays. The user creates a <em>Shader Binding Table</em> (SBT), which consists of a set
of shader function handles and embedded parameters for these functions. The shaders in the table
are executed depending on whether or not a geometry was hit by a ray, and which geometry was hit.
When a geometry is hit, a set of parameters specified on both the host and
device side of the application combine to determine which shader is executed.
The RTX APIs provide a great deal of flexibility in how the SBT can be set up and
indexed into during rendering, leaving a number of options open to applications.
However, with incorrect SBT access leading
to crashes and difficult bugs, sparse examples or documentation, and
subtle differences in naming and SBT setup between the APIs, properly setting up
and accessing the SBT is an especially thorny part of the RTX APIs for new users.</p>

<p>In this post we’ll look at the similarities and differences of each ray tracing API’s shader
binding table to gain a fundamental understanding of the execution model. I’ll then
present an interactive tool for constructing the SBT, building a scene which uses it,
and executing trace calls on the scene to see which hit groups and miss shaders are called.
Finally, we’ll look at how this model can be brought back to the CPU using Embree,
to potentially build a unified low-level API for ray tracing.</p>



		<a href="/graphics/2019/11/20/the-sbt-three-ways">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="mt-2 mx-auto col-8 border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/graphics/2019/09/06/faster-shadow-rays-on-rtx"><h3>Faster Shadow Rays on RTX</h3></a>
		<b>06 Sep 2019</b>
		
<p>To determine if a hit point can be directly lit by a light source in the scene
we need to perform a visibility test between the point and the light.
In a path tracer we must perform at least one visibility test per hit point
to shade the point, or two if we’re using multiple importance sampling (one for the light
sample, and one for the BSDF sample). When rendering just ambient occlusion,
e.g., for baking occlusion maps, we may send even more shadow rays per hit-point.
Fortunately, shadow rays can be relatively cheap to trace, as
we don’t care about finding the closest hit point or computing surface shading information,
but just whether or not something is intersected by the ray.
There are a few options and combinations of ray flags which we can use
when deciding how to trace shadow rays on RTX (through DXR, OptiX or Vulkan).
I recently learned a method for skipping all hit group shaders (any hit, closest hit)
and instead using just the miss shader to determine if the ray is <em>not</em> occluded.
This was a bit non-obvious to me, though has been used by others
(see <a href="http://intro-to-dxr.cwyman.org/presentations/IntroDXR_ShaderTutorial.pdf">Chris Wyman’s Intro to DXR</a>
and <a href="https://github.com/SaschaWillems/Vulkan/tree/master/data/shaders/nv_ray_tracing_shadows">Sascha Willems’s NV Ray Tracing Shadows Example</a>).
After switching to this approach in <a href="https://github.com/Twinklebear/ChameleonRT">ChameleonRT</a>
I decided to run a small benchmark comparing some of the options for tracing shadow rays.
I’ll also discuss an extra trick we can use to simplify the shader binding table setup,
which lets us skip creating an occlusion hit group entirely.</p>



		<a href="/graphics/2019/09/06/faster-shadow-rays-on-rtx">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="mt-2 mx-auto col-8 border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/webgl/2019/01/13/volume-rendering-with-webgl"><h3>Volume Rendering with WebGL</h3></a>
		<b>13 Jan 2019</b>
		
<figure>
	<img class="img-fluid" src="https://i.imgur.com/YqdyKCj.png" />
	
	<figcaption><i>Figure 1:
	Example volume renderings, using the WebGL volume renderer described in this post.
	Left: A simulation of the spatial probability distribution
	of electrons in a high potential protein molecule.
	Right: A CT scan of a Bonsai Tree.
	Both datasets are from the
	<a href="https://klacansky.com/open-scivis-datasets/">Open SciVis Datasets</a>
	repository.
	</i></figcaption>
</figure>

<p>In scientific visualization, volume rendering is widely used to visualize
3D scalar fields. These scalar fields are often
uniform grids of values, representing,
for example, charge density around a molecule,
an MRI or CT scan, air flow around an airplane, etc.
Volume rendering is a conceptually straightforward method
for turning such data into an image: by sampling the data
along rays from the eye and assigning
a color and transparency to each sample, we can
produce useful and beautiful images of such scalar fields
(see Figure 1).
In a GPU renderer, these 3D scalar fields are stored
as 3D textures; however, in WebGL1 3D textures were
not supported, requiring additional hacks to emulate them
for volume rendering.
Recently, WebGL2 added support for 3D textures,
allowing for an elegant and fast volume renderer to be
implemented entirely in the browser.
In this post we’ll discuss the mathematical background
for volume rendering, and how it can be implemented in
WebGL2 to create an interactive volume renderer
entirely in the browser!
Before we start, you can try out the volume renderer
described in this post <a href="https://www.willusher.io/webgl-volume-raycaster/">online</a>.</p>



		<a href="/webgl/2019/01/13/volume-rendering-with-webgl">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="mt-2 mx-auto col-8 border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/latex/2018/07/10/comments-in-latex"><h3>Comments in LaTeX</h3></a>
		<b>10 Jul 2018</b>
		
<p>When writing a paper in LaTeX, it’s common to leave
notes and comments in the text, either to yourself
or your co-authors. I used to write these
as just different colored text using <code class="highlighter-rouge">\textcolor{...}</code>,
with each author assigned a color, or all with the same color.
However, with more authors
it can get hard to keep picking legible font colors.
Futhermore, sometimes just a different color font doesn’t
stand out quite as much as I’d like from the rest of the text.
More recently I’ve switched to using highlights for
the comments, which works well with multiple authors,
and helps the comments stand out from the rest of
the text. This is easy to do with the
<a href="https://ctan.org/pkg/soul?lang=en">soul</a> and
<a href="https://ctan.org/pkg/xcolor?lang=en">xcolor</a> packages.</p>



		<a href="/latex/2018/07/10/comments-in-latex">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="mt-2 mx-auto col-8 border-bottom border-secondary">
		</div>
	</div>
	

	
	<div class="col-12 text-center mb-2">
		<h5>Find older posts in the <a href="/archive">Archive</a></h5>
	</div>
	
</div>


	</div>

	<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
	<!-- Do I actually need popper ? -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	
</body>
</html>



