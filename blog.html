

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="origin-trial" content="AoMftca5+Dstn4K7mCd1AKVcenGb0/EBkqJgonux6w6fVXhyJ2iHs9LuZKA36+gcaypMdBLAaIpkES6VMXoJtg8AAABQeyJvcmlnaW4iOiJodHRwczovL3d3dy53aWxsdXNoZXIuaW86NDQzIiwiZmVhdHVyZSI6IldlYkdQVSIsImV4cGlyeSI6MTY0MzE1NTE5OX0=">

	<title>Blog</title>
	
    <meta name="author" content="Will Usher">

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

	<!-- Should I be including font-awesome from bootstrap? Or just the 5.0 version? -->
    <!--<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>-->
    <script defer src="https://kit.fontawesome.com/b56adde3a3.js" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>

	<link href="/assets/molokai.css" rel="stylesheet">
	<link href="/assets/custom.css" rel="stylesheet">
	<link rel="shortcut icon" href="/assets/img/identicon.ico">

</head>
<body>
	<nav class="navbar navbar-expand-md navbar-dark bg-dark static-top">
		<div class="container">
			<a class="navbar-brand" href="/">Will Usher</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
				data-target="#navbar_responsive" aria-controls="navbarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbar_responsive">
				<ul class="navbar-nav mr-auto">
				
				
				  
					
					  
					  
						<li class="nav-item"><a href="/projects" class="nav-link">
							Projects</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item active"><a href="/blog" class="nav-link">
							Blog</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/pages/sdl2" class="nav-link">
							SDL2 Tutorials</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/news" class="nav-link">
							News</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/archive" class="nav-link">
							Archive</a></li>
						
					  
					
				  
				</ul>
			</div><!-- nav.collaps -->
		</div>
	</nav>

	<div class="container content mb-4">
		


<div class="row mt-4 justify-content-center">
	
	<div class="col-9 mb-2">
		<a href="/graphics/2024/04/28/0-to-gltf-basic-materials"><h3>From 0 to glTF with WebGPU: Basic Materials and Textures</h3></a>
        <p>April 28, 2024</p>
		
<figure>
  <img class="img-fluid" src="https://willusherio.b-cdn.net/webgpu-0-to-gltf/basic-material-textures-ts-duck.png" />
    
    <figcaption><b>Figure 1:</b>
    The happy duck we’ll be able to render at the end of this post
    <i>
  </i>
  </figcaption>
</figure>

<p>Now that we can load up complex scene hierarchies from glTF files and render them correctly, let’s start getting some more interesting colors on screen! glTF defines a <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#appendix-b-brdf-implementation">physically based BRDF</a>, with support for metallic and roughness properties, along with normal, emission and occlusion texture maps. There are a number of <a href="https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md">extensions</a> on top of this basic material model (the <code class="language-plaintext highlighter-rouge">KHR_materials_*</code> extensions) that add even more advanced material definitions.</p>

<p>We’ll keep it simple to start. Today we’re going to take the first step of loading the base glTF material parameters and textures from the glB file and passing them to our shader. In the shader we’ll color the object by its base color properties, without applying any lighting or material model yet.</p>



		<a href="/graphics/2024/04/28/0-to-gltf-basic-materials">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="col-12 mt-2 mx-auto border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/graphics/2024/04/22/webgpu-marching-cubes"><h3>GPU Compute in the Browser at the Speed of Native: WebGPU Marching Cubes</h3></a>
        <p>April 22, 2024</p>
		
<p>WebGPU is a powerful GPU-API for the web, providing support for advanced low-overhead rendering pipelines and GPU compute pipelines. WebGPU’s support for GPU compute shaders and storage buffers are a key distinction from WebGL, which lacks these features, and make it possible to bring powerful GPU-parallel applications to run entirely in the browser. These applications can range from GPGPU (e.g., simulations, data processing/analysis, machine learning, etc.) to GPU compute driven rendering pipelines, and applications across the spectrum.</p>

<p>In this post, we’ll evaluate WebGPU compute performance against native Vulkan by implementing the classic Marching Cubes algorithm in WebGPU. Marching Cubes is a nearly embarrassingly parallel algorithm, with two global reduction steps that must take place to synchronize work items and thread output locations. This makes it a great first GPU-parallel algorithm to try out on a new platform, as it has enough complexity to stress the API in a few different ways beyond simple parallel kernel dispatches but isn’t so complex as to take an substantial amount of time to implement or be bottlenecked by CPU performance.</p>



		<a href="/graphics/2024/04/22/webgpu-marching-cubes">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="col-12 mt-2 mx-auto border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/graphics/2023/06/24/0-to-gltf-full-scene"><h3>From 0 to glTF with WebGPU: Rendering the Full glTF Scene</h3></a>
        <p>June 24, 2023</p>
		
<figure>
  <img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/broken-to-fixed-engine.webp" />
  
  <figcaption><b>Figure 1:</b>
  <i>In this post, we'll look at how to fix our terribly broken 2 Cylinder Engine.
  Left: A buggy render of 2CylinderEngine.glb achieved when ignoring the glTF node transformations.
  Right: The correct rendering with meshes positioned based on the hierarchy of transforms
  specified in the glTF node tree.
  </i></figcaption>
</figure>

<p>Loading and drawing our first mesh from a glTF file was quite a bit of work in the <a href="https://www.willusher.io/graphics/2023/05/16/0-to-gltf-first-mesh">previous post</a>, but with this core piece in place we can start adding a lot more functionality to our renderer pretty quickly. If you tried loading up glTF files into the renderer from the previous post, you may have noticed that they didn’t look how you expected. This is because glTF files often contain many meshes that make up different parts of the scene geometry, most of which will be missing since we only loaded the first mesh last time. If we just add a simple loop through the meshes to load and draw them all we’ll frequently end up with a scene like the broken engine on the left in the image above. This is because the meshes are reference and transformed by the glTF node hierarchy, and we need to load and handle these nested transformations to render the correct scene shown on the right. The test model we’ll be using for this post is the <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/2CylinderEngine">2CylinderEngine</a> from the Khronos glTF samples repo, which has nested transformations in its node hierarchy that make it a great test case. So grab <a href="https://github.com/KhronosGroup/glTF-Sample-Models/raw/master/2.0/2CylinderEngine/glTF-Binary/2CylinderEngine.glb">2CylinderEngine.glb</a> and let’s get started!</p>



		<a href="/graphics/2023/06/24/0-to-gltf-full-scene">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="col-12 mt-2 mx-auto border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/graphics/2023/05/16/0-to-gltf-first-mesh"><h3>From 0 to glTF with WebGPU: Rendering the First glTF Mesh</h3></a>
        <p>May 16, 2023</p>
		
<p>Now that we’ve seen how to draw a triangle in the <a href="https://www.willusher.io/graphics/2023/04/10/0-to-gltf-triangle">first post</a> and hook up camera controls so we can look around in the <a href="https://www.willusher.io/graphics/2023/04/11/0-to-gltf-bind-groups">second post</a>, we’re at the point where the avocado really hits the screen and we can start drawing our first glTF primitives! I say the avocado hits the screen because that’s the glTF test model we’ll be using. You can grab it from the <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/Avocado">Khronos glTF samples repo</a>. glTF files come in two flavors (minus other extension specific versions), a standard “.gltf” version that stores the JSON header in one file and binary data and textures in separate files, and a “.glb” version, that combines the JSON header and all binary or texture data into a single file. We’ll be loading .glb files in this series to simplify how many files we have to deal with to get a model into the renderer, so grab the glTF-Binary <a href="https://github.com/KhronosGroup/glTF-Sample-Models/raw/master/2.0/Avocado/glTF-Binary/Avocado.glb">Avocado.glb</a> and let’s get started!</p>

<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/first-mesh-avocado.png" />
	
	<figcaption><b>Figure 1:</b>
	<i>It takes quite a bit to get Avocado.glb on the screen, but this
    beautiful image of our expected final (and delicious) result should
    be enough motivation to keep us going!
    </i></figcaption>
</figure>



		<a href="/graphics/2023/05/16/0-to-gltf-first-mesh">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="col-12 mt-2 mx-auto border-bottom border-secondary">
		</div>
	</div>
	
	<div class="col-9 mb-2">
		<a href="/graphics/2023/04/11/0-to-gltf-bind-groups"><h3>From 0 to glTF with WebGPU: Bind Groups - Updated for Chrome 113 Release</h3></a>
        <p>April 11, 2023</p>
		
<p>This tutorial is an updated version of my previous one and updates the
code listing to match the finalizing WebGPU APIs. If you’ve read
the previous version of this tutorial you can skim through the code
listings to get up to date.
The code for the blog series is also available <a href="https://github.com/Twinklebear/webgpu-0-to-gltf">on GitHub</a>.</p>

<p>In this second post of the series we’ll learn about Bind Groups,
which let us pass buffers and textures to our shaders.
When writing a renderer, we typically have inputs which do not make sense as vertex
attributes (e.g., transform matrices, material parameters), or simply cannot be passed
as vertex attributes (e.g., textures). Such parameters are instead
passed as uniforms in GLSL terms, or root parameters in HLSL terms.
The application then associates the desired buffers and textures with the
parameters in the shader. In WebGPU, the association of data to parameters is made using Bind Groups.
In this post, we’ll use Bind Groups to pass a uniform buffer containing a view
transform to our vertex shader, allowing us to add camera controls to our triangle
from the previous post.
If you haven’t read the <a href="/graphics/2023/04/10/0-to-gltf-triangle">updated first post in this series</a>
I recommend reading that first, as we’ll continue directly off the code written there.</p>



		<a href="/graphics/2023/04/11/0-to-gltf-bind-groups">Continue &nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
		<div class="col-12 mt-2 mx-auto border-bottom border-secondary">
		</div>
	</div>
	

	
	<div class="col-12 text-center mb-2">
		<h5>Find older posts in the <a href="/archive">Archive</a></h5>
	</div>
	
</div>


	</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    

    <script defer data-domain="willusher.io" src="https://pan.wushernet.com/js/script.js"></script>

</body>
</html>



