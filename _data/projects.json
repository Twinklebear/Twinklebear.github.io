[
	[
	{
		"title": "tray_rust",
		"image": "http://i.imgur.com/E1ylrZW.jpg",
		"gh_user": "Twinklebear",
		"gh_repo": "tray_rust",
		"description": "tray_rust is a toy physically based ray tracer built off of the techniques
			discussed in [Physically Based Rendering](http://pbrt.org/). It began life as a port of
			[tray](https://github.com/Twinklebear/tray) to [Rust](http://www.rust-lang.org) to check out the language.
			The renderer is currently capable of path tracing, supports triangle meshes (MTL support coming soon),
			and various physically based material models (including measured data from the
			[MERL BRDF Database](http://www.merl.com/brdf/)) along with rigid body animation and distributed rendering. More
			details on rendering performance and other features can be found in the readme
			[README](https://github.com/Twinklebear/tray_rust/blob/master/README.md).\n\n
			In the image above the Rust logo model was made by
			[Nylithius on BlenderArtists](http://blenderartists.org/forum/showthread.php?362836-Rust-language-3D-logo) and
			the Buddha and Dragon are from the [Stanford 3D Scanning Repository](http://graphics.stanford.edu/data/3Dscanrep/)
			The materials on the Rust logo, Buddha and Dragon are from the [MERL BRDF Database](http://www.merl.com/brdf/)."
	},
	{
		"title": "ispc-rs",
		"image": "http://i.imgur.com/ACzYqAm.png",
		"gh_user": "Twinklebear",
		"gh_repo": "ispc-rs",
		"description": "ispc-rs is a small Rust library meant to be used as a compile time dependency
			for Rust projects to allow them to build and link with code written in
			[ISPC](https://ispc.github.io/). ISPC is a language that makes it possible to take advantage
			the CPU's vector units without needing hand-written intrinsics. Through this library it's easy
			to write very fast vector code in ISPC and link it with (still quick!) higher-level code
			in Rust to get a good balance of high performance and ease of use.
			
			The images shown above are from the
			[rt example](https://github.com/Twinklebear/ispc-rs/tree/master/examples/rt) (top row)
			which demonstrates a simple fast and parallel path tracer
			and the [ddvol example](https://github.com/Twinklebear/ispc-rs/tree/master/examples/ddvol)
			(bottom row) which is a scientific visualization volume
			renderer. Both use higher level Rust code to read in a scene file and setup
			the objects in the scene and then call into ISPC to render in parallel, making
			good use of the CPU's SIMD units."
	},
	{
		"title": "tobj",
		"image": "http://i.imgur.com/wImyNG4.png",
		"gh_user": "Twinklebear",
		"gh_repo": "tobj",
		"description": "tobj is a tiny OBJ loader in Rust that draws inspiration for its API and design from
			Syoyo's excellent library, [tinyobjloader](https://github.com/syoyo/tinyobjloader).
			The crate aims to be a simple, fast and
			lightweight option for loading OBJ and MTL files for easy integration with realtime and offline
			renderers, or really any other project where you need to load OBJ files!\n\n
			The image shown is from a demo viewer written to test tobj named
			[tobj_viewer](https://github.com/Twinklebear/tobj_viewer) displaying the
			[Rungholt](http://graphics.cs.williams.edu/data/meshes.xml) model. The model can be found on
			Morgan McGuire's meshes page and was originally built by kescha."
	},
	{
		"title": "ssao",
		"image": "http://i.imgur.com/byM8iNh.png",
		"gh_user": "Twinklebear",
		"gh_repo": "ssao",
		"description": "This is sort of an implementation of
			[Scalable Ambient Obscurance by McGuire et al.](http://graphics.cs.williams.edu/papers/SAOHPG12/)
			however I make a few simplifying shortcuts in my implementation and don't achieve as good performance
			or quality. I was also unable to get their new recommended estimator to behave so this implementation
			still uses the Alchemy AO estimator initially recommended in the paper. There's a somewhat longer write
			up available on [my classpage](http://www.willusher.io/courses/cs6610/) since this was initially
			implemented as a class project.\n\n
			The image shows just the ambient occlusion value for a view of the Crytek Sponza scene."
	}
	],

	[
	{
		"title": "μPacket",
		"image": "http://i.imgur.com/WcM6Rcl.png",
		"gh_user": "Twinklebear",
		"gh_repo": "micro-packet",
		"description": "μPacket is an extremely simple packet based ray tracer that uses the AVX/AVX2 instruction
			set to trace eight rays at once through the scene. Currently it only supports spheres and planes
			with Lambertian BRDFs illuminated by a single point light. Illumination is computed with Whitted ray
			tracing, although recursion only goes as far as computing shadows since there are no reflective
			or transmissive materials at the moment.\n\n
			Ray packets were first introduced by [Wald et al., 2001](http://www.sci.utah.edu/~wald/Publications/2001/CRT/CRT.pdf)
			and are now widely used in high performance ray tracers like [Embree](http://embree.github.io/) due to
			the performance gain achieved with good packet (and now stream) tracing techniques.\n\n
			Current plans for this project are to switch to trace ray streams and add support for a path tracing
			integrator for higher quality images."
	},
	{
		"title": "bspline",
		"image": "http://i.imgur.com/RUEw8EW.png",
		"gh_user": "Twinklebear",
		"gh_repo": "bspline",
		"description": "A Rust library for computing B-spline interpolating curves on generic control points.
			bspline can be used to evaluate B-splines of varying orders on any type that can be linearly
			interpolated, ranging from floats, positions, RGB colors to transformation matrices and so on.

			The bspline logo (above) was generated using this library with a cubic B-spline in 2D for the
			positioning of the curve and a quadratic B-spline in RGB space to color it."
	},
	{
		"title": "tray",
		"image": "http://i.imgur.com/zPpNVDs.png",
		"gh_user": "Twinklebear",
		"gh_repo": "tray",
		"description": "tray is a toy physically based ray tracer built off of the techniques discussed in
			[Physically Based Rendering](http://pbrt.org/). It currently has support for path tracing,
			bidirectional path tracing and photon mapping. tray also supports physically materials such as
			microfacet models like Torrance-Sparrow and measured data from the
			[MERL BRDF Database](http://www.merl.com/brdf/).\n\n
			This is the project tray_rust is based on and as such may not see much more development since most
			of my ray tracing work is now going on there."
	},
	{
		"title": "lfwatch",
		"gh_user": "Twinklebear",
		"gh_repo": "lfwatch",
		"description": "lfwatch is a lightweight file watcher for Windows, Linux and OS X. It monitors some
			desired directories for file changes and calls the callback set for the directory with information
			about the file change event. This was written to do hot reloading of GLSL shaders but could be
			useful for some other applications."
	}
	]
]

