(()=>{"use strict";var e={163:(e,t,n)=>{e.exports=n.p+"aad74533c70863e5419a.png"},902:(e,t,n)=>{e.exports=n.p+"a5c11a572e6b4f458a45.png"},745:(e,t,n)=>{e.exports=n.p+"97fec048f06baef3d282.png"},426:(e,t,n)=>{e.exports=n.p+"1ef74900fa05b21736ff.png"},296:(e,t,n)=>{e.exports=n.p+"b340b67402670cf370a3.png"},790:(e,t,n)=>{e.exports=n.p+"c5acd61a762601c42272.png"},574:e=>{e.exports="let M_PI: f32 = 3.14159265358979323846;\n\n// Reduce clutter/keyboard pain\ntype float2 = vec2<f32>;\ntype float3 = vec3<f32>;\ntype float4 = vec4<f32>;\ntype uint2 = vec2<u32>;\ntype int2 = vec2<i32>;\n\n// TODO: Would need to write a custom webpack loader for wgsl that\n// processes #include to be able to #include this\nstruct LCGRand {\n     state: u32;\n};\n\nfn murmur_hash3_mix(hash_in: u32, k_in: u32) -> u32\n{\n    let c1 = 0xcc9e2d51u;\n    let c2 = 0x1b873593u;\n    let r1 = 15u;\n    let r2 = 13u;\n    let m = 5u;\n    let n = 0xe6546b64u;\n\n    var k = k_in * c1;\n    k = (k << r1) | (k >> (32u - r1));\n    k *= c2;\n\n    var hash = hash_in ^ k;\n    hash = ((hash << r2) | (hash >> (32u - r2))) * m + n;\n\n    return hash;\n}\n\nfn murmur_hash3_finalize(hash_in: u32) -> u32\n{\n    var hash = hash_in ^ (hash_in >> 16u);\n    hash *= 0x85ebca6bu;\n    hash ^= hash >> 13u;\n    hash *= 0xc2b2ae35u;\n    hash ^= hash >> 16u;\n\n    return hash;\n}\n\nfn lcg_random(rng: ptr<function, LCGRand>) -> u32\n{\n    let m = 1664525u;\n    let n = 1013904223u;\n    // WGSL please Add an arrow operator or only use refs/inout\n    // This is really a pain\n    (*rng).state = (*rng).state * m + n;\n    return (*rng).state;\n}\n\nfn lcg_randomf(rng: ptr<function, LCGRand>) -> f32\n{\n\treturn ldexp(f32(lcg_random(rng)), -32);\n}\n\nfn get_rng(frame_id: u32, pixel: int2, dims: int2) -> LCGRand\n{\n    var rng: LCGRand;\n    rng.state = murmur_hash3_mix(0u, u32(pixel.x + pixel.y * dims.x));\n    rng.state = murmur_hash3_mix(rng.state, frame_id);\n    rng.state = murmur_hash3_finalize(rng.state);\n    return rng;\n}\n\nstruct VertexInput {\n    @location(0) position: float3;\n};\n\nstruct VertexOutput {\n    @builtin(position) position: float4;\n    @location(0) transformed_eye: float3;\n    @location(1) ray_dir: float3;\n};\n\nstruct ViewParams {\n    proj_view: mat4x4<f32>;\n    // Not sure on WGSL padding/alignment rules for blocks,\n    // just assume align/pad to vec4\n    eye_pos: float4;\n    //volume_scale: float4;\n    frame_id: u32;\n};\n\n// TODO: Become user params\nvar<private> sigma_t_scale: f32 = 100.0;\nvar<private> sigma_s_scale: f32 = 1.0;\n\n\n@group(0) @binding(0)\nvar<uniform> view_params: ViewParams;\n\n@group(0) @binding(1)\nvar volume: texture_3d<f32>;\n\n@group(0) @binding(2)\nvar colormap: texture_2d<f32>;\n\n@group(0) @binding(3)\nvar tex_sampler: sampler;\n\n// Why can't we read from storage textures or read/write from one?\n@group(0) @binding(4)\nvar accum_buffer_in: texture_2d<f32>;\n\n@group(0) @binding(5)\nvar accum_buffer_out: texture_storage_2d<rgba32float, write>;\n\n@stage(vertex)\nfn vertex_main(vert: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n    var pos = vert.position;\n    out.position = view_params.proj_view * float4(pos, 1.0);\n    out.transformed_eye = view_params.eye_pos.xyz;\n    out.ray_dir = pos - out.transformed_eye;\n    return out;\n};\n\nfn intersect_box(orig: float3, dir: float3) -> float2 {\n\tvar box_min = float3(0.0);\n\tvar box_max = float3(1.0);\n\tvar inv_dir = 1.0 / dir;\n\tvar tmin_tmp = (box_min - orig) * inv_dir;\n\tvar tmax_tmp = (box_max - orig) * inv_dir;\n\tvar tmin = min(tmin_tmp, tmax_tmp);\n\tvar tmax = max(tmin_tmp, tmax_tmp);\n\tvar t0 = max(tmin.x, max(tmin.y, tmin.z));\n\tvar t1 = min(tmax.x, min(tmax.y, tmax.z));\n\treturn float2(t0, t1);\n}\n\nfn sample_spherical_direction(s: float2) -> float3 {\n    let cos_theta = 1.0 - 2.0 * s.x;\n    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));\n    let phi = s.y * 2.0 * M_PI;\n    return float3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\n}\n\nfn linear_to_srgb(x: f32) -> f32 {\n\tif (x <= 0.0031308) {\n\t\treturn 12.92 * x;\n\t}\n\treturn 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\nstruct SamplingResult {\n    scattering_event: bool;\n    color: float3;\n    transmittance: f32;\n};\n\nfn sample_woodcock(orig: float3,\n                   dir: float3,\n                   interval: float2,\n                   t: ptr<function, f32>,\n                   rng: ptr<function, LCGRand>)\n                   -> SamplingResult\n{\n    var result: SamplingResult;\n    result.scattering_event = false;\n    result.color = float3(0.0);\n    result.transmittance = 0.0;\n    loop {\n        let samples = float2(lcg_randomf(rng), lcg_randomf(rng));\n\n        *t -= log(1.0 - samples.x) / sigma_t_scale;\n        if (*t >= interval.y) {\n            break;\n        }\n\n        var p = orig + *t * dir;\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\n        // TODO: opacity from transfer function in UI instead of just based on the scalar value\n        // Opacity values from the transfer fcn will already be in [0, 1]\n        var density = val;\n        //var sample_opacity = textureSampleLevel(colormap, tex_sampler, float2(val, 0.5), 0.0).a;\n        // Here the sigma t scale will cancel out\n        if (density > samples.y) {\n            result.scattering_event = true;\n            result.color = textureSampleLevel(colormap, tex_sampler, float2(val, 0.5), 0.0).rgb;\n            result.transmittance = (1.0 - val);\n            break;\n        }\n    }\n    return result;\n}\n\nfn delta_tracking_transmittance(orig: float3,\n                                dir: float3,\n                                interval: float2,\n                                rng: ptr<function, LCGRand>) -> f32\n{\n    var transmittance = 1.0;\n    var t = interval.x;\n    loop {\n        let samples = float2(lcg_randomf(rng), lcg_randomf(rng));\n\n        t -= log(1.0 - samples.x) / sigma_t_scale;\n        if (t >= interval.y) {\n            break;\n        }\n\n        var p = orig + t * dir;\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\n        // TODO: Sample opacity from colormap\n        if (val > samples.y) {\n            return 0.0;\n        }\n    }\n    return 1.0;\n}\n\nfn ratio_tracking_transmittance(orig: float3,\n                                dir: float3,\n                                interval: float2,\n                                rng: ptr<function, LCGRand>) -> f32\n{\n    var transmittance = 1.0;\n    var t = interval.x;\n    loop {\n        t -= log(1.0 - lcg_randomf(rng)) / sigma_t_scale;\n        if (t >= interval.y) {\n            break;\n        }\n\n        var p = orig + t * dir;\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\n        // TODO: Sample from the opacity colormap\n        transmittance *= (1.0 - val);\n    }\n    return transmittance;\n}\n\n@stage(fragment)\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\n    var ray_dir = normalize(in.ray_dir);\n\n\tvar t_interval = intersect_box(in.transformed_eye, ray_dir);\n\tif (t_interval.x > t_interval.y) {\n\t\tdiscard;\n\t}\n\tt_interval.x = max(t_interval.x, 0.0);\n\n    let pixel = int2(i32(in.position.x), i32(in.position.y));\n    var rng = get_rng(view_params.frame_id, pixel, int2(1280, 720));\n\n    // This should just be 1 for the max density in scivis\n    var inv_max_density = 1.0;\n\n    let light_dir = normalize(float3(1.0, 1.0, 0.0));\n    let light_emission = 0.5;\n    let ambient_strength = 0.0;\n    let volume_emission = 0.5;\n\n    var illum = float3(0.0);\n    var throughput = float3(1.0);\n    var transmittance = 1.0;\n\n    var had_any_event = false;\n    var pos = in.transformed_eye;\n    // Sample the next scattering event in the volume\n    for (var i = 0; i < 4; i += 1) {\n        var t = t_interval.x;\n        var event = sample_woodcock(pos, ray_dir, t_interval, &t, &rng);\n\n        if (!event.scattering_event) {\n            // Illuminate with an \"environment light\"\n            if (had_any_event) {\n                illum += throughput * float3(ambient_strength);\n            } else {\n                illum = float3(0.1);\n            }\n            break;\n        } else {\n            had_any_event = true;\n\n            // Update scattered ray position\n            pos = pos + ray_dir * t;\n\n            // Sample illumination from the direct light\n            t_interval = intersect_box(pos, light_dir);\n            // We're inside the volume\n            t_interval.x = 0.0;\n            //var light_transmittance = ratio_tracking_transmittance(pos, light_dir, t_interval, &rng);\n            var light_transmittance = delta_tracking_transmittance(pos, light_dir, t_interval, &rng);\n            illum += throughput * light_transmittance * float3(light_emission);\n\n            // Include emission from the volume for emission/absorption scivis model\n            // Scaling the volume emission by the inverse of the opacity from the transfer function\n            // can give some nice effects. Would be cool to provide control of this\n            illum += throughput * event.color * volume_emission;// * (1.0 - event.transmittance);\n\n            throughput *= event.color * event.transmittance * sigma_s_scale;\n\n            // Scatter in a random direction to continue the ray\n            ray_dir = sample_spherical_direction(float2(lcg_randomf(&rng), lcg_randomf(&rng)));\n            t_interval = intersect_box(pos, ray_dir);\n            if (t_interval.x > t_interval.y) {\n                illum = float3(0.0, 1.0, 0.0);\n                break;\n            }\n            // We're now inside the volume\n            t_interval.x = 0.0;\n        }\n    }\n\n    var color = float4(illum, 1.0);\n\n    // Accumulate into the accumulation buffer for progressive accumulation \n    var accum_color = float4(0.0);\n    if (view_params.frame_id > 0u) {\n        accum_color = textureLoad(accum_buffer_in, pixel, 0);\n    }\n    accum_color += color;\n    textureStore(accum_buffer_out, pixel, accum_color);\n\n    color = accum_color / f32(view_params.frame_id + 1u);\n\n    // TODO: background color also needs to be sRGB-mapped, otherwise this\n    // causes the volume bounding box to show up incorrectly b/c of the\n    // differing brightness\n    color.r = linear_to_srgb(color.r);\n    color.g = linear_to_srgb(color.g);\n    color.b = linear_to_srgb(color.b);\n    return color;\n}\n\n"}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{var e;n.g.importScripts&&(e=n.g.location+"");var t=n.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");r.length&&(e=r[r.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=e})(),(()=>{var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(2);return e!=Float32Array&&(t[0]=0,t[1]=0),t}function r(e,t,n){return e[0]=t,e[1]=n,e}function a(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function i(t,n,r){var a=new e(3);return a[0]=t,a[1]=n,a[2]=r,a}function o(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function s(e,t){var n=t[0],r=t[1],a=t[2],i=n*n+r*r+a*a;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}function l(e,t,n){var r=t[0],a=t[1],i=t[2],o=n[0],s=n[1],l=n[2];return e[0]=a*l-i*s,e[1]=i*o-r*l,e[2]=r*s-a*o,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),t();function u(){var t=new e(4);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function c(e,t,n,r,a){return e[0]=t,e[1]=n,e[2]=r,e[3]=a,e}function m(e,t){var n=t[0],r=t[1],a=t[2],i=t[3],o=n*n+r*r+a*a+i*i;return o>0&&(o=1/Math.sqrt(o)),e[0]=n*o,e[1]=r*o,e[2]=a*o,e[3]=i*o,e}function f(e,t,n){var r=t[0],a=t[1],i=t[2],o=t[3];return e[0]=n[0]*r+n[4]*a+n[8]*i+n[12]*o,e[1]=n[1]*r+n[5]*a+n[9]*i+n[13]*o,e[2]=n[2]*r+n[6]*a+n[10]*i+n[14]*o,e[3]=n[3]*r+n[7]*a+n[11]*i+n[15]*o,e}function v(){var t=new e(4);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}a(),u();var h,g=c,p=function(e,t,n){var r=t[0],a=t[1],i=t[2],o=t[3],s=n[0],l=n[1],u=n[2],c=n[3];return e[0]=r*c+o*s+a*u-i*l,e[1]=a*c+o*l+i*s-r*u,e[2]=i*c+o*u+r*l-a*s,e[3]=o*c-r*s-a*l-i*u,e},d=m;function _(){var t=new e(16);return e!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function x(e,t){var n=t[0],r=t[1],a=t[2],i=t[3],o=t[4],s=t[5],l=t[6],u=t[7],c=t[8],m=t[9],f=t[10],v=t[11],h=t[12],g=t[13],p=t[14],d=t[15],_=n*s-r*o,x=n*l-a*o,b=n*u-i*o,y=r*l-a*s,w=r*u-i*s,T=a*u-i*l,S=c*g-m*h,G=c*p-f*h,M=c*d-v*h,U=m*p-f*g,P=m*d-v*g,C=f*d-v*p,A=_*C-x*P+b*U+y*M-w*G+T*S;return A?(A=1/A,e[0]=(s*C-l*P+u*U)*A,e[1]=(a*P-r*C-i*U)*A,e[2]=(g*T-p*w+d*y)*A,e[3]=(f*w-m*T-v*y)*A,e[4]=(l*M-o*C-u*G)*A,e[5]=(n*C-a*M+i*G)*A,e[6]=(p*b-h*T-d*x)*A,e[7]=(c*T-f*b+v*x)*A,e[8]=(o*P-s*M+u*S)*A,e[9]=(r*M-n*P-i*S)*A,e[10]=(h*w-g*b+d*_)*A,e[11]=(m*b-c*w-v*_)*A,e[12]=(s*G-o*U-l*S)*A,e[13]=(n*U-r*G+a*S)*A,e[14]=(g*x-h*y-p*_)*A,e[15]=(c*y-m*x+f*_)*A,e):null}function b(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}a(),i(1,0,0),i(0,1,0),v(),v(),h=new e(9),e!=Float32Array&&(h[1]=0,h[2]=0,h[3]=0,h[5]=0,h[6]=0,h[7]=0),h[0]=1,h[4]=1,h[8]=1;var y=function(e,t,n){var r=t[0],a=t[1],i=t[2],o=t[3],s=t[4],l=t[5],u=t[6],c=t[7],m=t[8],f=t[9],v=t[10],h=t[11],g=t[12],p=t[13],d=t[14],_=t[15],x=n[0],b=n[1],y=n[2],w=n[3];return e[0]=x*r+b*s+y*m+w*g,e[1]=x*a+b*l+y*f+w*p,e[2]=x*i+b*u+y*v+w*d,e[3]=x*o+b*c+y*h+w*_,x=n[4],b=n[5],y=n[6],w=n[7],e[4]=x*r+b*s+y*m+w*g,e[5]=x*a+b*l+y*f+w*p,e[6]=x*i+b*u+y*v+w*d,e[7]=x*o+b*c+y*h+w*_,x=n[8],b=n[9],y=n[10],w=n[11],e[8]=x*r+b*s+y*m+w*g,e[9]=x*a+b*l+y*f+w*p,e[10]=x*i+b*u+y*v+w*d,e[11]=x*o+b*c+y*h+w*_,x=n[12],b=n[13],y=n[14],w=n[15],e[12]=x*r+b*s+y*m+w*g,e[13]=x*a+b*l+y*f+w*p,e[14]=x*i+b*u+y*v+w*d,e[15]=x*o+b*c+y*h+w*_,e};function w(e){var n,r,a=(r=e,(n=e)[0]*r[0]+n[1]*r[1]);if(a<=1)return g(v(),e[0],e[1],Math.sqrt(1-a),0);var i=function(e,t){var n=t[0],r=t[1],a=n*n+r*r;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e}(t(),e);return g(v(),i[0],i[1],0,0)}function T(e,t,n){return e<t?t:e>n?n:e}class S{constructor(t,n,r,i,u){var c=o(a(),t[0],t[1],t[2]),m=o(a(),n[0],n[1],n[2]),f=o(a(),r[0],r[1],r[2]);s(f,f);var h,g,p,y,w=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}(a(),m,c),T=(g=(h=w)[0],p=h[1],y=h[2],Math.hypot(g,p,y));s(w,w);var S=l(a(),w,f);s(S,S);var G=l(a(),S,w);s(G,G),l(S,w,G),s(S,S),this.zoomSpeed=i,this.invScreen=[1/u[0],1/u[1]],this.centerTranslation=b(_(),n),x(this.centerTranslation,this.centerTranslation);var M=o(a(),0,0,-1*T);this.translation=b(_(),M);var U=function(t,n,r,a,i,o,s,l,u){var c=new e(9);return c[0]=t,c[1]=n,c[2]=r,c[3]=a,c[4]=i,c[5]=o,c[6]=s,c[7]=l,c[8]=u,c}(S[0],S[1],S[2],G[0],G[1],G[2],-w[0],-w[1],-w[2]);!function(e,t){if(e===t){var n=t[1],r=t[2],a=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=a}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]}(U,U),this.rotation=function(e,t){var n,r=t[0]+t[4]+t[8];if(r>0)n=Math.sqrt(r+1),e[3]=.5*n,n=.5/n,e[0]=(t[5]-t[7])*n,e[1]=(t[6]-t[2])*n,e[2]=(t[1]-t[3])*n;else{var a=0;t[4]>t[0]&&(a=1),t[8]>t[3*a+a]&&(a=2);var i=(a+1)%3,o=(a+2)%3;n=Math.sqrt(t[3*a+a]-t[3*i+i]-t[3*o+o]+1),e[a]=.5*n,n=.5/n,e[3]=(t[3*i+o]-t[3*o+i])*n,e[i]=(t[3*i+a]+t[3*a+i])*n,e[o]=(t[3*o+a]+t[3*a+o])*n}return e}(v(),U),d(this.rotation,this.rotation),this.camera=_(),this.invCamera=_(),this.updateCameraMatrix()}rotate(e,n){var a=r(t(),T(2*e[0]*this.invScreen[0]-1,-1,1),T(1-2*e[1]*this.invScreen[1],-1,1)),i=r(t(),T(2*n[0]*this.invScreen[0]-1,-1,1),T(1-2*n[1]*this.invScreen[1],-1,1)),o=w(a),s=w(i);this.rotation=p(this.rotation,o,this.rotation),this.rotation=p(this.rotation,s,this.rotation),this.updateCameraMatrix()}zoom(e){var t=o(a(),0,0,e*this.invScreen[1]*this.zoomSpeed),n=b(_(),t);this.translation=y(this.translation,n,this.translation),this.translation[14]>=-.2&&(this.translation[14]=-.2),this.updateCameraMatrix()}pan(e){var t=c(u(),e[0]*this.invScreen[0]*Math.abs(this.translation[14]),e[1]*this.invScreen[1]*Math.abs(this.translation[14]),0,0),n=f(u(),t,this.invCamera),r=b(_(),n);this.centerTranslation=y(this.centerTranslation,r,this.centerTranslation),this.updateCameraMatrix()}updateCameraMatrix(){var e=function(e,t){var n=t[0],r=t[1],a=t[2],i=t[3],o=n+n,s=r+r,l=a+a,u=n*o,c=r*o,m=r*s,f=a*o,v=a*s,h=a*l,g=i*o,p=i*s,d=i*l;return e[0]=1-m-h,e[1]=c+d,e[2]=f-p,e[3]=0,e[4]=c-d,e[5]=1-u-h,e[6]=v+g,e[7]=0,e[8]=f+p,e[9]=v-g,e[10]=1-u-m,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(_(),this.rotation);this.camera=y(this.camera,e,this.centerTranslation),this.camera=y(this.camera,this.translation,this.camera),this.invCamera=x(this.invCamera,this.camera)}eyePos(){return[this.invCamera[12],this.invCamera[13],this.invCamera[14]]}eyeDir(){var e=c(u(),0,0,-1,0);return[(e=m(e=f(e,e,this.invCamera),e))[0],e[1],e[2]]}upDir(){var e=c(u(),0,1,0,0);return[(e=m(e=f(e,e,this.invCamera),e))[0],e[1],e[2]]}}function G(e,t){var n=[t[0]-e[0],t[1]-e[1]];return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2))}class M{constructor(){this.mousemove=null,this.press=null,this.wheel=null,this.twoFingerDrag=null,this.pinch=null}registerForCanvas(e){var t=null,n=this;e.addEventListener("mousemove",(function(r){r.preventDefault();var a=e.getBoundingClientRect(),i=[r.clientX-a.left,r.clientY-a.top];t?n.mousemove&&n.mousemove(t,i,r):t=[r.clientX-a.left,r.clientY-a.top],t=i})),e.addEventListener("mousedown",(function(t){t.preventDefault();var r=e.getBoundingClientRect(),a=[t.clientX-r.left,t.clientY-r.top];n.press&&n.press(a,t)})),e.addEventListener("wheel",(function(e){e.preventDefault(),n.wheel&&n.wheel(-e.deltaY)})),e.oncontextmenu=function(e){e.preventDefault()};var r={};e.addEventListener("touchstart",(function(t){var a=e.getBoundingClientRect();t.preventDefault();for(var i=0;i<t.changedTouches.length;++i){var o=t.changedTouches[i];r[o.identifier]=[o.clientX-a.left,o.clientY-a.top],1==t.changedTouches.length&&n.press&&n.press(r[o.identifier],t)}})),e.addEventListener("touchmove",(function(t){t.preventDefault();var a=e.getBoundingClientRect();if(1==Object.keys(r).length){if(n.mousemove){var i=t.changedTouches[0],o=r[i.identifier],s=[i.clientX-a.left,i.clientY-a.top];t.buttons=1,n.mousemove(o,s,t)}}else{for(var l={},u=0;u<t.changedTouches.length;++u)l[(i=t.changedTouches[u]).identifier]=[i.clientX-a.left,i.clientY-a.top];var c=[];for(i in r)i in l||(l[i]=r[i]),c.push(r[i]);var m=[];for(i in l)m.push(l[i]);var f=[vec2.set(vec2.create(),m[0][0]-c[0][0],m[0][1]-c[0][1]),vec2.set(vec2.create(),m[1][0]-c[1][0],m[1][1]-c[1][1])],v=[vec2.create(),vec2.create()];vec2.normalize(v[0],f[0]),vec2.normalize(v[1],f[1]);var h=vec2.set(vec2.create(),c[1][0]-c[0][0],c[1][1]-c[0][1]);vec2.normalize(h,h);var g=vec2.lerp(vec2.create(),f[0],f[1],.5);vec2.normalize(g,g);var p=[vec2.dot(h,v[0]),vec2.dot(h,v[1])],d=[vec2.dot(g,v[0]),vec2.dot(g,v[1])];if(n.pinch&&Math.abs(p[0])>.5&&Math.abs(p[1])>.5&&Math.sign(p[0])!=Math.sign(p[1])){var _=G(c[0],c[1]),x=G(m[0],m[1]);n.pinch(x-_)}else if(n.twoFingerDrag&&Math.abs(d[0])>.5&&Math.abs(d[1])>.5&&Math.sign(d[0])==Math.sign(d[1])){var b=vec2.lerp(vec2.create(),f[0],f[1],.5);b[1]=-b[1],n.twoFingerDrag(b)}}for(u=0;u<t.changedTouches.length;++u)i=t.changedTouches[u],r[i.identifier]=[i.clientX-a.left,i.clientY-a.top]}));var a=function(e){e.preventDefault();for(var t=0;t<e.changedTouches.length;++t){var n=e.changedTouches[t];delete r[n.identifier]}};e.addEventListener("touchcancel",a),e.addEventListener("touchend",a)}}var U=n(574),P=n(163),C=n(902),A=n(745),B=n(426),E=n(296),R=n(790);const I={Fuel:"7d87jcsh0qodk78/fuel_64x64x64_uint8.raw",Neghip:"zgocya7h33nltu9/neghip_64x64x64_uint8.raw","Hydrogen Atom":"jwbav8s3wmmxd5x/hydrogen_atom_128x128x128_uint8.raw","Boston Teapot":"w4y88hlf2nbduiv/boston_teapot_256x256x178_uint8.raw",Engine:"ld2sqwwd3vaq4zf/engine_256x256x128_uint8.raw",Bonsai:"rdnhdxmxtfxe0sa/bonsai_256x256x256_uint8.raw",Foot:"ic0mik3qv4vqacm/foot_256x256x256_uint8.raw",Skull:"5rfjobn0lvb7tmo/skull_256x256x256_uint8.raw",Aneurysm:"3ykigaiym8uiwbp/aneurism_256x256x256_uint8.raw"},F={"Cool Warm":P,"Matplotlib Plasma":C,"Matplotlib Virdis":A,Rainbow:B,"Samsel Linear Green":E,"Samsel Linear YGB 1211G":R};(async()=>{if(void 0===navigator.gpu)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var e=await navigator.gpu.requestAdapter();if(!e)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var t=await e.requestDevice(),n=document.getElementById("webgpu-canvas"),r=n.getContext("webgpu"),i=t.createShaderModule({code:U}),s=await i.compilationInfo();if(s.messages.length>0){var l=!1;console.log("Shader compilation log:");for(var u=0;u<s.messages.length;++u){var c=s.messages[u];console.log(`${c.lineNum}:${c.linePos} - ${c.message}`),l=l||"error"==c.type}if(l)return void console.log("Shader failed to compile")}const m=o(a(),.5,.5,2.5),f=o(a(),.5,.5,.5),v=o(a(),0,1,0),h=function(){for(var e=[1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0],t=[],n=0;n<e.length;++n)t.push(n);return{vertices:e,indices:t}}();var g=t.createBuffer({size:4*h.vertices.length,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(g.getMappedRange()).set(h.vertices),g.unmap();var p=t.createBuffer({size:4*h.indices.length,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(p.getMappedRange()).set(h.indices),p.unmap();var d=t.createBuffer({size:84,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),x=t.createSampler({magFilter:"linear",minFilter:"linear"}),b=null,w=new Image;w.src=F["Cool Warm"],await w.decode();var T=await createImageBitmap(w),G={source:T},P={texture:b=t.createTexture({size:[T.width,T.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT})};t.queue.copyExternalImageToTexture(G,P,[T.width,T.height]);var C,A=(C=I.Bonsai.match(/.*\/(\w+)_(\d+)x(\d+)x(\d+)_(\w+)\.*/),[parseInt(C[2]),parseInt(C[3]),parseInt(C[4])]),B=t.createTexture({size:A,format:"r8unorm",dimension:"3d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),E=await async function(e){var t="https://www.dl.dropboxusercontent.com/s/"+e+"?dl=1",n=await fetch(t).then((e=>e.arrayBuffer().then((function(e){return new Uint8Array(e)}))));return document.getElementById("loadingText").innerHTML=n?"Volume Loaded":"Error loading volume",n}(I.Bonsai),R=t.createBuffer({size:E.length,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(R.getMappedRange()).set(E),R.unmap();var D=t.createCommandEncoder();G={buffer:R,bytesPerRow:A[0],rowsPerImage:A[1]},P={texture:B},D.copyBufferToTexture(G,P,A),await t.queue.submit([D.finish()]);var k=[t.createTexture({size:[n.width,n.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),t.createTexture({size:[n.width,n.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})],L=[k[0].createView(),k[1].createView()],O="bgra8unorm";r.configure({device:t,format:O,usage:GPUTextureUsage.OUTPUT_ATTACHMENT});var N=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rgba32float"}}]}),z=t.createPipelineLayout({bindGroupLayouts:[N]}),q={module:i,entryPoint:"vertex_main",buffers:[{arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}]},V={module:i,entryPoint:"fragment_main",targets:[{format:O,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},X=t.createRenderPipeline({layout:z,vertex:q,fragment:V,primitive:{topology:"triangle-strip",stripIndexFormat:"uint16",cullMode:"front"}}),Y=.1<=.0031308?1.292:1.055*Math.pow(.1,1/2.4)-.055,j={colorAttachments:[{view:void 0,loadOp:"clear",clearValue:[Y,Y,Y,1]}]},W=new S(m,f,v,2,[n.width,n.height]),$=function(e,t,n,r,a){var i,o=1/Math.tan(t/2);return e[0]=o/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i=1/-99.9,e[10]=100.1*i,e[14]=20*i,e}(_(),50*Math.PI/180,n.width/n.height),H=_(),J=0,K=new M;K.mousemove=function(e,t,n){1==n.buttons?(J=0,W.rotate(e,t)):2==n.buttons&&(J=0,W.pan([t[0]-e[0],e[1]-t[1]]))},K.wheel=function(e){J=0,W.zoom(e)},K.pinch=K.wheel,K.twoFingerDrag=function(e){J=0,W.pan(e)},K.registerForCanvas(n);var Q=function(){var e=null,t=new Promise((t=>e=t));return window.requestAnimationFrame(e),t};requestAnimationFrame(Q);for(var Z=[{binding:0,resource:{buffer:d}},{binding:1,resource:B.createView()},{binding:2,resource:b.createView()},{binding:3,resource:x},{binding:4,resource:null},{binding:5,resource:null}];;)if(await Q(),!document.hidden){H=y(H,$,W.camera);var ee=t.createBuffer({size:84,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),te=W.eyePos(),ne=ee.getMappedRange(),re=new Float32Array(ne);re.set(H),re.set(te,H.length),new Uint32Array(ne).set([J],20),ee.unmap(),Z[4].resource=L[J%2],Z[5].resource=L[(J+1)%2];var ae=t.createBindGroup({layout:N,entries:Z});(D=t.createCommandEncoder()).copyBufferToBuffer(ee,0,d,0,84),j.colorAttachments[0].view=r.getCurrentTexture().createView();var ie=D.beginRenderPass(j);ie.setPipeline(X),ie.setBindGroup(0,ae),ie.setVertexBuffer(0,g),ie.setIndexBuffer(p,"uint16"),ie.draw(h.vertices.length/3,1,0,0),ie.end(),t.queue.submit([D.finish()]),ee.destroy(),J+=1}})()})()})();