(()=>{"use strict";var e={};e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{var t;e.g.importScripts&&(t=e.g.location+"");var n=e.g.document;if(!t&&n&&(n.currentScript&&(t=n.currentScript.src),!t)){var r=n.getElementsByTagName("script");r.length&&(t=r[r.length-1].src)}if(!t)throw new Error("Automatic publicPath is not supported in this browser");t=t.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),e.p=t})();var t="undefined"!=typeof Float32Array?Float32Array:Array;function n(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}function r(e,t,n){return e[0]=t,e[1]=n,e}function a(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function i(e,n,r){var a=new t(3);return a[0]=e,a[1]=n,a[2]=r,a}function o(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function s(e,t){var n=t[0],r=t[1],a=t[2],i=n*n+r*r+a*a;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e}function l(e,t,n){var r=t[0],a=t[1],i=t[2],o=n[0],s=n[1],l=n[2];return e[0]=a*l-i*s,e[1]=i*o-r*l,e[2]=r*s-a*o,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),n();function u(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function c(e,t,n,r,a){return e[0]=t,e[1]=n,e[2]=r,e[3]=a,e}function m(e,t){var n=t[0],r=t[1],a=t[2],i=t[3],o=n*n+r*r+a*a+i*i;return o>0&&(o=1/Math.sqrt(o)),e[0]=n*o,e[1]=r*o,e[2]=a*o,e[3]=i*o,e}function v(e,t,n){var r=t[0],a=t[1],i=t[2],o=t[3];return e[0]=n[0]*r+n[4]*a+n[8]*i+n[12]*o,e[1]=n[1]*r+n[5]*a+n[9]*i+n[13]*o,e[2]=n[2]*r+n[6]*a+n[10]*i+n[14]*o,e[3]=n[3]*r+n[7]*a+n[11]*i+n[15]*o,e}function f(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}a(),u();var h,d=c,g=function(e,t,n){var r=t[0],a=t[1],i=t[2],o=t[3],s=n[0],l=n[1],u=n[2],c=n[3];return e[0]=r*c+o*s+a*u-i*l,e[1]=a*c+o*l+i*s-r*u,e[2]=i*c+o*u+r*l-a*s,e[3]=o*c-r*s-a*l-i*u,e},p=m;function _(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function x(e,t){var n=t[0],r=t[1],a=t[2],i=t[3],o=t[4],s=t[5],l=t[6],u=t[7],c=t[8],m=t[9],v=t[10],f=t[11],h=t[12],d=t[13],g=t[14],p=t[15],_=n*s-r*o,x=n*l-a*o,y=n*u-i*o,b=r*l-a*s,w=r*u-i*s,T=a*u-i*l,M=c*d-m*h,S=c*g-v*h,G=c*p-f*h,U=m*g-v*d,E=m*p-f*d,P=v*p-f*g,R=_*P-x*E+y*U+b*G-w*S+T*M;return R?(R=1/R,e[0]=(s*P-l*E+u*U)*R,e[1]=(a*E-r*P-i*U)*R,e[2]=(d*T-g*w+p*b)*R,e[3]=(v*w-m*T-f*b)*R,e[4]=(l*G-o*P-u*S)*R,e[5]=(n*P-a*G+i*S)*R,e[6]=(g*y-h*T-p*x)*R,e[7]=(c*T-v*y+f*x)*R,e[8]=(o*E-s*G+u*M)*R,e[9]=(r*G-n*E-i*M)*R,e[10]=(h*w-d*y+p*_)*R,e[11]=(m*y-c*w-f*_)*R,e[12]=(s*S-o*U-l*M)*R,e[13]=(n*U-r*S+a*M)*R,e[14]=(d*x-h*b-g*_)*R,e[15]=(c*b-m*x+v*_)*R,e):null}function y(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}a(),i(1,0,0),i(0,1,0),f(),f(),h=new t(9),t!=Float32Array&&(h[1]=0,h[2]=0,h[3]=0,h[5]=0,h[6]=0,h[7]=0),h[0]=1,h[4]=1,h[8]=1;var b=function(e,t,n){var r=t[0],a=t[1],i=t[2],o=t[3],s=t[4],l=t[5],u=t[6],c=t[7],m=t[8],v=t[9],f=t[10],h=t[11],d=t[12],g=t[13],p=t[14],_=t[15],x=n[0],y=n[1],b=n[2],w=n[3];return e[0]=x*r+y*s+b*m+w*d,e[1]=x*a+y*l+b*v+w*g,e[2]=x*i+y*u+b*f+w*p,e[3]=x*o+y*c+b*h+w*_,x=n[4],y=n[5],b=n[6],w=n[7],e[4]=x*r+y*s+b*m+w*d,e[5]=x*a+y*l+b*v+w*g,e[6]=x*i+y*u+b*f+w*p,e[7]=x*o+y*c+b*h+w*_,x=n[8],y=n[9],b=n[10],w=n[11],e[8]=x*r+y*s+b*m+w*d,e[9]=x*a+y*l+b*v+w*g,e[10]=x*i+y*u+b*f+w*p,e[11]=x*o+y*c+b*h+w*_,x=n[12],y=n[13],b=n[14],w=n[15],e[12]=x*r+y*s+b*m+w*d,e[13]=x*a+y*l+b*v+w*g,e[14]=x*i+y*u+b*f+w*p,e[15]=x*o+y*c+b*h+w*_,e};function w(e){var t,r,a=(r=e,(t=e)[0]*r[0]+t[1]*r[1]);if(a<=1)return d(f(),e[0],e[1],Math.sqrt(1-a),0);var i=function(e,t){var n=t[0],r=t[1],a=n*n+r*r;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e}(n(),e);return d(f(),i[0],i[1],0,0)}function T(e,t,n){return e<t?t:e>n?n:e}class M{constructor(e,n,r,i,u){var c=o(a(),e[0],e[1],e[2]),m=o(a(),n[0],n[1],n[2]),v=o(a(),r[0],r[1],r[2]);s(v,v);var h,d,g,b,w=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}(a(),m,c),T=(d=(h=w)[0],g=h[1],b=h[2],Math.hypot(d,g,b));s(w,w);var M=l(a(),w,v);s(M,M);var S=l(a(),M,w);s(S,S),l(M,w,S),s(M,M),this.zoomSpeed=i,this.invScreen=[1/u[0],1/u[1]],this.centerTranslation=y(_(),n),x(this.centerTranslation,this.centerTranslation);var G=o(a(),0,0,-1*T);this.translation=y(_(),G);var U=function(e,n,r,a,i,o,s,l,u){var c=new t(9);return c[0]=e,c[1]=n,c[2]=r,c[3]=a,c[4]=i,c[5]=o,c[6]=s,c[7]=l,c[8]=u,c}(M[0],M[1],M[2],S[0],S[1],S[2],-w[0],-w[1],-w[2]);!function(e,t){if(e===t){var n=t[1],r=t[2],a=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=a}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]}(U,U),this.rotation=function(e,t){var n,r=t[0]+t[4]+t[8];if(r>0)n=Math.sqrt(r+1),e[3]=.5*n,n=.5/n,e[0]=(t[5]-t[7])*n,e[1]=(t[6]-t[2])*n,e[2]=(t[1]-t[3])*n;else{var a=0;t[4]>t[0]&&(a=1),t[8]>t[3*a+a]&&(a=2);var i=(a+1)%3,o=(a+2)%3;n=Math.sqrt(t[3*a+a]-t[3*i+i]-t[3*o+o]+1),e[a]=.5*n,n=.5/n,e[3]=(t[3*i+o]-t[3*o+i])*n,e[i]=(t[3*i+a]+t[3*a+i])*n,e[o]=(t[3*o+a]+t[3*a+o])*n}return e}(f(),U),p(this.rotation,this.rotation),this.camera=_(),this.invCamera=_(),this.updateCameraMatrix()}rotate(e,t){var a=r(n(),T(2*e[0]*this.invScreen[0]-1,-1,1),T(1-2*e[1]*this.invScreen[1],-1,1)),i=r(n(),T(2*t[0]*this.invScreen[0]-1,-1,1),T(1-2*t[1]*this.invScreen[1],-1,1)),o=w(a),s=w(i);this.rotation=g(this.rotation,o,this.rotation),this.rotation=g(this.rotation,s,this.rotation),this.updateCameraMatrix()}zoom(e){var t=o(a(),0,0,e*this.invScreen[1]*this.zoomSpeed),n=y(_(),t);this.translation=b(this.translation,n,this.translation),this.translation[14]>=-.2&&(this.translation[14]=-.2),this.updateCameraMatrix()}pan(e){var t=c(u(),e[0]*this.invScreen[0]*Math.abs(this.translation[14]),e[1]*this.invScreen[1]*Math.abs(this.translation[14]),0,0),n=v(u(),t,this.invCamera),r=y(_(),n);this.centerTranslation=b(this.centerTranslation,r,this.centerTranslation),this.updateCameraMatrix()}updateCameraMatrix(){var e=function(e,t){var n=t[0],r=t[1],a=t[2],i=t[3],o=n+n,s=r+r,l=a+a,u=n*o,c=r*o,m=r*s,v=a*o,f=a*s,h=a*l,d=i*o,g=i*s,p=i*l;return e[0]=1-m-h,e[1]=c+p,e[2]=v-g,e[3]=0,e[4]=c-p,e[5]=1-u-h,e[6]=f+d,e[7]=0,e[8]=v+g,e[9]=f-d,e[10]=1-u-m,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(_(),this.rotation);this.camera=b(this.camera,e,this.centerTranslation),this.camera=b(this.camera,this.translation,this.camera),this.invCamera=x(this.invCamera,this.camera)}eyePos(){return[this.invCamera[12],this.invCamera[13],this.invCamera[14]]}eyeDir(){var e=c(u(),0,0,-1,0);return[(e=m(e=v(e,e,this.invCamera),e))[0],e[1],e[2]]}upDir(){var e=c(u(),0,1,0,0);return[(e=m(e=v(e,e,this.invCamera),e))[0],e[1],e[2]]}}function S(e,t){var n=[t[0]-e[0],t[1]-e[1]];return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2))}class G{constructor(){this.mousemove=null,this.press=null,this.wheel=null,this.twoFingerDrag=null,this.pinch=null}registerForCanvas(e){var t=null,n=this;e.addEventListener("mousemove",(function(r){r.preventDefault();var a=e.getBoundingClientRect(),i=[r.clientX-a.left,r.clientY-a.top];t?n.mousemove&&n.mousemove(t,i,r):t=[r.clientX-a.left,r.clientY-a.top],t=i})),e.addEventListener("mousedown",(function(t){t.preventDefault();var r=e.getBoundingClientRect(),a=[t.clientX-r.left,t.clientY-r.top];n.press&&n.press(a,t)})),e.addEventListener("wheel",(function(e){e.preventDefault(),n.wheel&&n.wheel(-e.deltaY)})),e.oncontextmenu=function(e){e.preventDefault()};var r={};e.addEventListener("touchstart",(function(t){var a=e.getBoundingClientRect();t.preventDefault();for(var i=0;i<t.changedTouches.length;++i){var o=t.changedTouches[i];r[o.identifier]=[o.clientX-a.left,o.clientY-a.top],1==t.changedTouches.length&&n.press&&n.press(r[o.identifier],t)}})),e.addEventListener("touchmove",(function(t){t.preventDefault();var a=e.getBoundingClientRect();if(1==Object.keys(r).length){if(n.mousemove){var i=t.changedTouches[0],o=r[i.identifier],s=[i.clientX-a.left,i.clientY-a.top];t.buttons=1,n.mousemove(o,s,t)}}else{for(var l={},u=0;u<t.changedTouches.length;++u)l[(i=t.changedTouches[u]).identifier]=[i.clientX-a.left,i.clientY-a.top];var c=[];for(i in r)i in l||(l[i]=r[i]),c.push(r[i]);var m=[];for(i in l)m.push(l[i]);var v=[vec2.set(vec2.create(),m[0][0]-c[0][0],m[0][1]-c[0][1]),vec2.set(vec2.create(),m[1][0]-c[1][0],m[1][1]-c[1][1])],f=[vec2.create(),vec2.create()];vec2.normalize(f[0],v[0]),vec2.normalize(f[1],v[1]);var h=vec2.set(vec2.create(),c[1][0]-c[0][0],c[1][1]-c[0][1]);vec2.normalize(h,h);var d=vec2.lerp(vec2.create(),v[0],v[1],.5);vec2.normalize(d,d);var g=[vec2.dot(h,f[0]),vec2.dot(h,f[1])],p=[vec2.dot(d,f[0]),vec2.dot(d,f[1])];if(n.pinch&&Math.abs(g[0])>.5&&Math.abs(g[1])>.5&&Math.sign(g[0])!=Math.sign(g[1])){var _=S(c[0],c[1]),x=S(m[0],m[1]);n.pinch(x-_)}else if(n.twoFingerDrag&&Math.abs(p[0])>.5&&Math.abs(p[1])>.5&&Math.sign(p[0])==Math.sign(p[1])){var y=vec2.lerp(vec2.create(),v[0],v[1],.5);y[1]=-y[1],n.twoFingerDrag(y)}}for(u=0;u<t.changedTouches.length;++u)i=t.changedTouches[u],r[i.identifier]=[i.clientX-a.left,i.clientY-a.top]}));var a=function(e){e.preventDefault();for(var t=0;t<e.changedTouches.length;++t){var n=e.changedTouches[t];delete r[n.identifier]}};e.addEventListener("touchcancel",a),e.addEventListener("touchend",a)}}const U=e.p+"aad74533c70863e5419a.png",E=e.p+"a5c11a572e6b4f458a45.png",P=e.p+"97fec048f06baef3d282.png",R=e.p+"1ef74900fa05b21736ff.png",A=e.p+"b340b67402670cf370a3.png",B=e.p+"c5acd61a762601c42272.png",C={Fuel:"fuel_64x64x64_uint8.raw",Neghip:"neghip_64x64x64_uint8.raw","Hydrogen Atom":"hydrogen_atom_128x128x128_uint8.raw",Bonsai:"bonsai_256x256x256_uint8.raw",Foot:"foot_256x256x256_uint8.raw",Skull:"skull_256x256x256_uint8.raw",Aneurysm:"aneurism_256x256x256_uint8.raw"},I={"Cool Warm":U,"Matplotlib Plasma":E,"Matplotlib Virdis":P,Rainbow:R,"Samsel Linear Green":A,"Samsel Linear YGB 1211G":B};function L(e){var t=e.match(/(\w+)_(\d+)x(\d+)x(\d+)_(\w+)\.*/);return[parseInt(t[2]),parseInt(t[3]),parseInt(t[4])]}function F(e,t){return Math.floor((e+t-1)/t)*t}async function k(e){const t=L(e),n=t[0]*t[1]*t[2];var r=document.getElementById("loadingText"),a=document.getElementById("loadingProgressBar");r.innerHTML="Loading Volume...",a.setAttribute("style","width: 0%");var i="https://cdn.willusher.io/demo-volumes/"+e;try{for(var o=(await fetch(i)).body.getReader(),s=0,l=new Uint8Array(n);;){var{done:u,value:c}=await o.read();if(u)break;l.set(c,s);var m=(s+=c.length)/n*100;a.setAttribute("style",`width: ${m.toFixed(2)}%`)}return r.innerHTML="Volume Loaded",t[0]%256!=0?function(e,t){const n=[F(t[0],256),t[1],t[2]];var r=new Uint8Array(n[0]*n[1]*n[2]);const a=t[1]*t[2];for(var i=0;i<a;++i){var o=e.subarray(i*t[0],i*t[0]+t[0]);r.set(o,i*n[0])}return r}(l,t):l}catch(e){console.log(`Error loading volume: ${e}`),r.innerHTML="Error loading volume"}return null}async function D(e,t,n){var r=e.createTexture({size:t,format:"r8unorm",dimension:"3d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),a=e.createBuffer({size:n.length,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(a.getMappedRange()).set(n),a.unmap();var i=e.createCommandEncoder(),o={buffer:a,bytesPerRow:F(t[0],256),rowsPerImage:t[1]},s={texture:r};return i.copyBufferToTexture(o,s,t),e.queue.submit([i.finish()]),await e.queue.onSubmittedWorkDone(),r}async function N(e,t){var n=new Image;n.src=t,await n.decode();var r=await createImageBitmap(n),a=e.createTexture({size:[r.width,r.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),i={source:r},o={texture:a};return e.queue.copyExternalImageToTexture(i,o,[r.width,r.height]),await e.queue.onSubmittedWorkDone(),a}function z(e,t){for(var n in t){var r=document.createElement("option");r.value=n,r.innerHTML=n,e.appendChild(r)}}function O(e,t){const n=Math.cos(e),r=Math.sin(e);return[Math.cos(t)*r,Math.sin(t)*r,n]}(async()=>{if(void 0===navigator.gpu)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var e=await navigator.gpu.requestAdapter();if(!e)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var t=await e.requestDevice(),n=document.getElementById("webgpu-canvas"),r=n.getContext("webgpu"),i=t.createShaderModule({code:"const M_PI: f32 = 3.14159265358979323846;\n\n// Reduce clutter/keyboard pain\nalias float2 = vec2<f32>;\nalias float3 = vec3<f32>;\nalias float4 = vec4<f32>;\nalias uint2 = vec2<u32>;\nalias int2 = vec2<i32>;\n\n// TODO: Would need to write a custom webpack loader for wgsl that\n// processes #include to be able to #include this\nstruct LCGRand {\n     state: u32,\n};\n\nfn murmur_hash3_mix(hash_in: u32, k_in: u32) -> u32\n{\n    let c1 = 0xcc9e2d51u;\n    let c2 = 0x1b873593u;\n    let r1 = 15u;\n    let r2 = 13u;\n    let m = 5u;\n    let n = 0xe6546b64u;\n\n    var k = k_in * c1;\n    k = (k << r1) | (k >> (32u - r1));\n    k *= c2;\n\n    var hash = hash_in ^ k;\n    hash = ((hash << r2) | (hash >> (32u - r2))) * m + n;\n\n    return hash;\n}\n\nfn murmur_hash3_finalize(hash_in: u32) -> u32\n{\n    var hash = hash_in ^ (hash_in >> 16u);\n    hash *= 0x85ebca6bu;\n    hash ^= hash >> 13u;\n    hash *= 0xc2b2ae35u;\n    hash ^= hash >> 16u;\n\n    return hash;\n}\n\nfn lcg_random(rng: ptr<function, LCGRand>) -> u32\n{\n    let m = 1664525u;\n    let n = 1013904223u;\n    // WGSL please Add an arrow operator or only use refs/inout\n    // This is really a pain\n    (*rng).state = (*rng).state * m + n;\n    return (*rng).state;\n}\n\nfn lcg_randomf(rng: ptr<function, LCGRand>) -> f32\n{\n\treturn ldexp(f32(lcg_random(rng)), -32);\n}\n\nfn get_rng(frame_id: u32, pixel: int2, dims: int2) -> LCGRand\n{\n    var rng: LCGRand;\n    rng.state = murmur_hash3_mix(0u, u32(pixel.x + pixel.y * dims.x));\n    rng.state = murmur_hash3_mix(rng.state, frame_id);\n    rng.state = murmur_hash3_finalize(rng.state);\n    return rng;\n}\n\nstruct VertexInput {\n    @location(0) position: float3,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: float4,\n    @location(0) transformed_eye: float3,\n    @location(1) ray_dir: float3,\n};\n\nstruct ViewParams {\n    proj_view: mat4x4<f32>,\n    // Not sure on WGSL padding/alignment rules for blocks,\n    // just assume align/pad to vec4\n    eye_pos: float4,\n    volume_scale: float4,\n    light_dir: float4,\n    frame_id: u32,\n    sigma_t_scale: f32,\n    sigma_s_scale: f32\n};\n\n@group(0) @binding(0)\nvar<uniform> params: ViewParams;\n\n@group(0) @binding(1)\nvar volume: texture_3d<f32>;\n\n@group(0) @binding(2)\nvar colormap: texture_2d<f32>;\n\n@group(0) @binding(3)\nvar tex_sampler: sampler;\n\n// Why can't we read from storage textures or read/write from one?\n@group(0) @binding(4)\nvar accum_buffer_in: texture_2d<f32>;\n\n@group(0) @binding(5)\nvar accum_buffer_out: texture_storage_2d<rgba32float, write>;\n\n@vertex\nfn vertex_main(vert: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n    // Translate the volume to place its center at the origin to scale it\n    var volume_translation = float3(0.5) - params.volume_scale.xyz * 0.5;\n    var world_pos = vert.position * params.volume_scale.xyz + volume_translation;\n    out.position = params.proj_view * float4(world_pos, 1.0);\n\n    // Transform the eye into the scaled space\n    out.transformed_eye = (params.eye_pos.xyz - volume_translation) / params.volume_scale.xyz;\n    out.ray_dir = vert.position - out.transformed_eye;\n    return out;\n};\n\nfn intersect_box(orig: float3, dir: float3) -> float2 {\n\tvar box_min = float3(0.0);\n\tvar box_max = float3(1.0);\n\tvar inv_dir = 1.0 / dir;\n\tvar tmin_tmp = (box_min - orig) * inv_dir;\n\tvar tmax_tmp = (box_max - orig) * inv_dir;\n\tvar tmin = min(tmin_tmp, tmax_tmp);\n\tvar tmax = max(tmin_tmp, tmax_tmp);\n\tvar t0 = max(tmin.x, max(tmin.y, tmin.z));\n\tvar t1 = min(tmax.x, min(tmax.y, tmax.z));\n\treturn float2(t0, t1);\n}\n\nfn sample_spherical_direction(s: float2) -> float3 {\n    let cos_theta = 1.0 - 2.0 * s.x;\n    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));\n    let phi = s.y * 2.0 * M_PI;\n    return float3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\n}\n\nfn linear_to_srgb(x: f32) -> f32 {\n\tif (x <= 0.0031308) {\n\t\treturn 12.92 * x;\n\t}\n\treturn 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\nstruct SamplingResult {\n    scattering_event: bool,\n    color: float3,\n    transmittance: f32,\n};\n\nfn sample_woodcock(orig: float3,\n                   dir: float3,\n                   interval: float2,\n                   t: ptr<function, f32>,\n                   rng: ptr<function, LCGRand>)\n                   -> SamplingResult\n{\n    var result: SamplingResult;\n    result.scattering_event = false;\n    result.color = float3(0.0);\n    result.transmittance = 0.0;\n    loop {\n        let samples = float2(lcg_randomf(rng), lcg_randomf(rng));\n\n        *t -= log(1.0 - samples.x) / params.sigma_t_scale;\n        if (*t >= interval.y) {\n            break;\n        }\n\n        var p = orig + *t * dir;\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\n        // TODO: opacity from transfer function in UI instead of just based on the scalar value\n        // Opacity values from the transfer fcn will already be in [0, 1]\n        var density = val;\n        //var sample_opacity = textureSampleLevel(colormap, tex_sampler, float2(val, 0.5), 0.0).a;\n        // Here the sigma t scale will cancel out\n        if (density > samples.y) {\n            result.scattering_event = true;\n            result.color = textureSampleLevel(colormap, tex_sampler, float2(val, 0.5), 0.0).rgb;\n            result.transmittance = (1.0 - val);\n            break;\n        }\n    }\n    return result;\n}\n\nfn delta_tracking_transmittance(orig: float3,\n                                dir: float3,\n                                interval: float2,\n                                rng: ptr<function, LCGRand>) -> f32\n{\n    var transmittance = 1.0;\n    var t = interval.x;\n    loop {\n        let samples = float2(lcg_randomf(rng), lcg_randomf(rng));\n\n        t -= log(1.0 - samples.x) / params.sigma_t_scale;\n        if (t >= interval.y) {\n            break;\n        }\n\n        var p = orig + t * dir;\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\n        // TODO: Sample opacity from colormap\n        if (val > samples.y) {\n            return 0.0;\n        }\n    }\n    return 1.0;\n}\n\nfn ratio_tracking_transmittance(orig: float3,\n                                dir: float3,\n                                interval: float2,\n                                rng: ptr<function, LCGRand>) -> f32\n{\n    var transmittance = 1.0;\n    var t = interval.x;\n    loop {\n        t -= log(1.0 - lcg_randomf(rng)) / params.sigma_t_scale;\n        if (t >= interval.y) {\n            break;\n        }\n\n        var p = orig + t * dir;\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\n        // TODO: Sample from the opacity colormap\n        transmittance *= (1.0 - val);\n    }\n    return transmittance;\n}\n\n@fragment\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\n    var ray_dir = normalize(in.ray_dir);\n\n\tvar t_interval = intersect_box(in.transformed_eye, ray_dir);\n\tif (t_interval.x > t_interval.y) {\n\t\tdiscard;\n\t}\n\tt_interval.x = max(t_interval.x, 0.0);\n\n    let pixel = int2(i32(in.position.x), i32(in.position.y));\n    // Image will be no larger than 1280x720 so we can keep this fixed\n    // for picking our RNG value\n    var rng = get_rng(params.frame_id, pixel, int2(1280, 720));\n\n    // This should just be 1 for the max density in scivis\n    var inv_max_density = 1.0;\n\n    let light_dir = params.light_dir.xyz;\n    let light_emission = params.light_dir.w;\n    let ambient_strength = 0.0;\n    let volume_emission = 0.5;\n\n    var illum = float3(0.0);\n    var throughput = float3(1.0);\n    var transmittance = 1.0;\n\n    var had_any_event = false;\n    var pos = in.transformed_eye;\n    // Sample the next scattering event in the volume\n    for (var i = 0; i < 4; i += 1) {\n        var t = t_interval.x;\n        var event = sample_woodcock(pos, ray_dir, t_interval, &t, &rng);\n\n        if (!event.scattering_event) {\n            // Illuminate with an \"environment light\"\n            if (had_any_event) {\n                illum += throughput * float3(ambient_strength);\n            } else {\n                illum = float3(0.1);\n            }\n            break;\n        } else {\n            had_any_event = true;\n\n            // Update scattered ray position\n            pos = pos + ray_dir * t;\n\n            // Sample illumination from the direct light\n            t_interval = intersect_box(pos, light_dir);\n            // We're inside the volume\n            t_interval.x = 0.0;\n            /*\n            var light_transmittance =\n                ratio_tracking_transmittance(pos, light_dir, t_interval, &rng);\n            */\n            var light_transmittance =\n                delta_tracking_transmittance(pos, light_dir, t_interval, &rng);\n            illum += throughput * light_transmittance * float3(light_emission);\n\n            // Include emission from the volume for emission/absorption scivis model\n            // Scaling the volume emission by the inverse of the opacity from the transfer function\n            // can give some nice effects. Would be cool to provide control of this\n            illum += throughput * event.color * volume_emission;// * (1.0 - event.transmittance);\n\n            throughput *= event.color * event.transmittance * params.sigma_s_scale;\n\n            // Scatter in a random direction to continue the ray\n            ray_dir = sample_spherical_direction(float2(lcg_randomf(&rng), lcg_randomf(&rng)));\n            t_interval = intersect_box(pos, ray_dir);\n            if (t_interval.x > t_interval.y) {\n                illum = float3(0.0, 1.0, 0.0);\n                break;\n            }\n            // We're now inside the volume\n            t_interval.x = 0.0;\n        }\n    }\n\n    var color = float4(illum, 1.0);\n\n    // Accumulate into the accumulation buffer for progressive accumulation \n    var accum_color = float4(0.0);\n    if (params.frame_id > 0u) {\n        accum_color = textureLoad(accum_buffer_in, pixel, 0);\n    }\n    accum_color += color;\n    textureStore(accum_buffer_out, pixel, accum_color);\n\n    color = accum_color / f32(params.frame_id + 1u);\n\n    // TODO: background color also needs to be sRGB-mapped, otherwise this\n    // causes the volume bounding box to show up incorrectly b/c of the\n    // differing brightness\n    color.r = linear_to_srgb(color.r);\n    color.g = linear_to_srgb(color.g);\n    color.b = linear_to_srgb(color.b);\n    return color;\n}\n\n"}),s=await i.getCompilationInfo();if(s.messages.length>0){var l=!1;console.log("Shader compilation log:");for(var u=0;u<s.messages.length;++u){var c=s.messages[u];console.log(`${c.lineNum}:${c.linePos} - ${c.message}`),l=l||"error"==c.type}if(l)return void console.log("Shader failed to compile")}const m=o(a(),.5,.5,2.5),v=o(a(),.5,.5,.5),f=o(a(),0,1,0),h=function(){for(var e=[1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0],t=[],n=0;n<e.length;++n)t.push(n);return{vertices:e,indices:t}}();var d=t.createBuffer({size:4*h.vertices.length,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(d.getMappedRange()).set(h.vertices),d.unmap();var g=t.createBuffer({size:4*h.indices.length,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(g.getMappedRange()).set(h.indices),g.unmap();var p=t.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),x=t.createSampler({magFilter:"linear",minFilter:"linear"}),y=document.getElementById("volumeList"),w=document.getElementById("colormapList");z(y,C),z(w,I);var T="Bonsai";if(window.location.hash){var S=decodeURI(window.location.hash.substring(1));if(!(S in C))return void alert(`Linked to invalid data set ${S}`);y.value=S,T=S}var U=L(C[T]);const E=Math.max(U[0],Math.max(U[1],U[2]));var P=[U[0]/E,U[1]/E,U[2]/E],R="Cool Warm",A=await N(t,I[R]),B=await k(C[T]).then((e=>D(t,U,e))),F=[t.createTexture({size:[n.width,n.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),t.createTexture({size:[n.width,n.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})],V=[F[0].createView(),F[1].createView()],q="bgra8unorm";r.configure({device:t,format:q,usage:GPUTextureUsage.OUTPUT_ATTACHMENT,alphaMode:"premultiplied"});var X=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rgba32float"}}]}),Y=t.createPipelineLayout({bindGroupLayouts:[X]}),W={module:i,entryPoint:"vertex_main",buffers:[{arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}]},$={module:i,entryPoint:"fragment_main",targets:[{format:q,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},j=t.createRenderPipeline({layout:Y,vertex:W,fragment:$,primitive:{topology:"triangle-strip",stripIndexFormat:"uint16",cullMode:"front"}}),H=.1<=.0031308?1.292:1.055*Math.pow(.1,1/2.4)-.055,J={colorAttachments:[{view:void 0,loadOp:"clear",storeOp:"store",clearValue:[H,H,H,1]}]},K=new M(m,v,f,2,[n.width,n.height]),Q=function(e,t,n,r,a){var i,o=1/Math.tan(t/2);return e[0]=o/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=a&&a!==1/0?(i=1/(r-a),e[10]=(a+r)*i,e[14]=2*a*r*i):(e[10]=-1,e[14]=-2*r),e}(_(),50*Math.PI/180,n.width/n.height,.1,100),Z=_(),ee=0,te=new G;te.mousemove=function(e,t,n){1==n.buttons?(ee=0,K.rotate(e,t)):2==n.buttons&&(ee=0,K.pan([t[0]-e[0],e[1]-t[1]]))},te.wheel=function(e){ee=0,K.zoom(e)},te.pinch=te.wheel,te.twoFingerDrag=function(e){ee=0,K.pan(e)},te.registerForCanvas(n);var ne=document.getElementById("phiRange"),re=document.getElementById("thetaRange"),ae=document.getElementById("lightStrength");ne.oninput=function(){ee=0},re.oninput=function(){ee=0},ae.oninput=function(){ee=0};var ie=function(){var e=null,t=new Promise((t=>e=t));return window.requestAnimationFrame(e),t};requestAnimationFrame(ie);for(var oe=[{binding:0,resource:{buffer:p}},{binding:1,resource:B.createView()},{binding:2,resource:A.createView()},{binding:3,resource:x},{binding:4,resource:null},{binding:5,resource:null}],se=t.createBuffer({size:128,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1});;)if(await ie(),!document.hidden){if(T!=y.value){T=y.value,history.replaceState(history.state,"","#"+T),U=L(C[T]);const e=Math.max(U[0],Math.max(U[1],U[2]));P=[U[0]/e,U[1]/e,U[2]/e],B=await k(C[T]).then((e=>D(t,U,e))),ee=0,oe[1].resource=B.createView()}R!=w.value&&(R=w.value,A=await N(t,I[R]),ee=0,oe[2].resource=A.createView()),Z=b(Z,Q,K.camera);var le=O(re.value,ne.value);await se.mapAsync(GPUMapMode.WRITE);var ue=K.eyePos(),ce=se.getMappedRange(),me=new Float32Array(ce),ve=new Uint32Array(ce);me.set(Z,0),me.set(ue,16),me.set(P,20),me.set(le,24),me.set([ae.value],27),ve.set([ee],28),me.set([100,1],29),se.unmap(),oe[4].resource=V[ee%2],oe[5].resource=V[(ee+1)%2];var fe=t.createBindGroup({layout:X,entries:oe}),he=t.createCommandEncoder();he.copyBufferToBuffer(se,0,p,0,128),J.colorAttachments[0].view=r.getCurrentTexture().createView();var de=he.beginRenderPass(J);de.setPipeline(j),de.setBindGroup(0,fe),de.setVertexBuffer(0,d),de.setIndexBuffer(g,"uint16"),de.draw(h.vertices.length/3,1,0,0),de.end(),t.queue.submit([he.finish()]),ee+=1}})()})();