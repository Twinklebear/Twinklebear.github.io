(()=>{"use strict";var r={};r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(r){if("object"==typeof window)return window}}(),(()=>{var e;r.g.importScripts&&(e=r.g.location+"");var t=r.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");n.length&&(e=n[n.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})();var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var r=new e(2);return e!=Float32Array&&(r[0]=0,r[1]=0),r}function n(r,e,t){return r[0]=e,r[1]=t,r}function a(){var r=new e(3);return e!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function i(r,t,n){var a=new e(3);return a[0]=r,a[1]=t,a[2]=n,a}function o(r,e,t,n){return r[0]=e,r[1]=t,r[2]=n,r}function s(r,e){var t=e[0],n=e[1],a=e[2],i=t*t+n*n+a*a;return i>0&&(i=1/Math.sqrt(i)),r[0]=e[0]*i,r[1]=e[1]*i,r[2]=e[2]*i,r}function l(r,e,t){var n=e[0],a=e[1],i=e[2],o=t[0],s=t[1],l=t[2];return r[0]=a*l-i*s,r[1]=i*o-n*l,r[2]=n*s-a*o,r}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)}),t();function u(){var r=new e(4);return e!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function c(r,e,t,n,a){return r[0]=e,r[1]=t,r[2]=n,r[3]=a,r}function m(r,e){var t=e[0],n=e[1],a=e[2],i=e[3],o=t*t+n*n+a*a+i*i;return o>0&&(o=1/Math.sqrt(o)),r[0]=t*o,r[1]=n*o,r[2]=a*o,r[3]=i*o,r}function v(r,e,t){var n=e[0],a=e[1],i=e[2],o=e[3];return r[0]=t[0]*n+t[4]*a+t[8]*i+t[12]*o,r[1]=t[1]*n+t[5]*a+t[9]*i+t[13]*o,r[2]=t[2]*n+t[6]*a+t[10]*i+t[14]*o,r[3]=t[3]*n+t[7]*a+t[11]*i+t[15]*o,r}function f(){var r=new e(4);return e!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r[3]=1,r}a(),u();var h,d=c,g=function(r,e,t){var n=e[0],a=e[1],i=e[2],o=e[3],s=t[0],l=t[1],u=t[2],c=t[3];return r[0]=n*c+o*s+a*u-i*l,r[1]=a*c+o*l+i*s-n*u,r[2]=i*c+o*u+n*l-a*s,r[3]=o*c-n*s-a*l-i*u,r},p=m;function _(){var r=new e(16);return e!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=0,r[12]=0,r[13]=0,r[14]=0),r[0]=1,r[5]=1,r[10]=1,r[15]=1,r}function x(r,e){var t=e[0],n=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8],m=e[9],v=e[10],f=e[11],h=e[12],d=e[13],g=e[14],p=e[15],_=t*s-n*o,x=t*l-a*o,y=t*u-i*o,b=n*l-a*s,w=n*u-i*s,T=a*u-i*l,M=c*d-m*h,S=c*g-v*h,G=c*p-f*h,U=m*g-v*d,E=m*p-f*d,P=v*p-f*g,B=_*P-x*E+y*U+b*G-w*S+T*M;return B?(B=1/B,r[0]=(s*P-l*E+u*U)*B,r[1]=(a*E-n*P-i*U)*B,r[2]=(d*T-g*w+p*b)*B,r[3]=(v*w-m*T-f*b)*B,r[4]=(l*G-o*P-u*S)*B,r[5]=(t*P-a*G+i*S)*B,r[6]=(g*y-h*T-p*x)*B,r[7]=(c*T-v*y+f*x)*B,r[8]=(o*E-s*G+u*M)*B,r[9]=(n*G-t*E-i*M)*B,r[10]=(h*w-d*y+p*_)*B,r[11]=(m*y-c*w-f*_)*B,r[12]=(s*S-o*U-l*M)*B,r[13]=(t*U-n*S+a*M)*B,r[14]=(d*x-h*b-g*_)*B,r[15]=(c*b-m*x+v*_)*B,r):null}function y(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r}a(),i(1,0,0),i(0,1,0),f(),f(),h=new e(9),e!=Float32Array&&(h[1]=0,h[2]=0,h[3]=0,h[5]=0,h[6]=0,h[7]=0),h[0]=1,h[4]=1,h[8]=1;var b=function(r,e,t){var n=e[0],a=e[1],i=e[2],o=e[3],s=e[4],l=e[5],u=e[6],c=e[7],m=e[8],v=e[9],f=e[10],h=e[11],d=e[12],g=e[13],p=e[14],_=e[15],x=t[0],y=t[1],b=t[2],w=t[3];return r[0]=x*n+y*s+b*m+w*d,r[1]=x*a+y*l+b*v+w*g,r[2]=x*i+y*u+b*f+w*p,r[3]=x*o+y*c+b*h+w*_,x=t[4],y=t[5],b=t[6],w=t[7],r[4]=x*n+y*s+b*m+w*d,r[5]=x*a+y*l+b*v+w*g,r[6]=x*i+y*u+b*f+w*p,r[7]=x*o+y*c+b*h+w*_,x=t[8],y=t[9],b=t[10],w=t[11],r[8]=x*n+y*s+b*m+w*d,r[9]=x*a+y*l+b*v+w*g,r[10]=x*i+y*u+b*f+w*p,r[11]=x*o+y*c+b*h+w*_,x=t[12],y=t[13],b=t[14],w=t[15],r[12]=x*n+y*s+b*m+w*d,r[13]=x*a+y*l+b*v+w*g,r[14]=x*i+y*u+b*f+w*p,r[15]=x*o+y*c+b*h+w*_,r};function w(r){var e,n,a=(n=r,(e=r)[0]*n[0]+e[1]*n[1]);if(a<=1)return d(f(),r[0],r[1],Math.sqrt(1-a),0);var i=function(r,e){var t=e[0],n=e[1],a=t*t+n*n;return a>0&&(a=1/Math.sqrt(a)),r[0]=e[0]*a,r[1]=e[1]*a,r}(t(),r);return d(f(),i[0],i[1],0,0)}function T(r,e,t){return r<e?e:r>t?t:r}class M{constructor(r,t,n,i,u){var c=o(a(),r[0],r[1],r[2]),m=o(a(),t[0],t[1],t[2]),v=o(a(),n[0],n[1],n[2]);s(v,v);var h,d,g,b,w=function(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}(a(),m,c),T=(d=(h=w)[0],g=h[1],b=h[2],Math.hypot(d,g,b));s(w,w);var M=l(a(),w,v);s(M,M);var S=l(a(),M,w);s(S,S),l(M,w,S),s(M,M),this.zoomSpeed=i,this.invScreen=[1/u[0],1/u[1]],this.centerTranslation=y(_(),t),x(this.centerTranslation,this.centerTranslation);var G=o(a(),0,0,-1*T);this.translation=y(_(),G);var U=function(r,t,n,a,i,o,s,l,u){var c=new e(9);return c[0]=r,c[1]=t,c[2]=n,c[3]=a,c[4]=i,c[5]=o,c[6]=s,c[7]=l,c[8]=u,c}(M[0],M[1],M[2],S[0],S[1],S[2],-w[0],-w[1],-w[2]);!function(r,e){if(r===e){var t=e[1],n=e[2],a=e[5];r[1]=e[3],r[2]=e[6],r[3]=t,r[5]=e[7],r[6]=n,r[7]=a}else r[0]=e[0],r[1]=e[3],r[2]=e[6],r[3]=e[1],r[4]=e[4],r[5]=e[7],r[6]=e[2],r[7]=e[5],r[8]=e[8]}(U,U),this.rotation=function(r,e){var t,n=e[0]+e[4]+e[8];if(n>0)t=Math.sqrt(n+1),r[3]=.5*t,t=.5/t,r[0]=(e[5]-e[7])*t,r[1]=(e[6]-e[2])*t,r[2]=(e[1]-e[3])*t;else{var a=0;e[4]>e[0]&&(a=1),e[8]>e[3*a+a]&&(a=2);var i=(a+1)%3,o=(a+2)%3;t=Math.sqrt(e[3*a+a]-e[3*i+i]-e[3*o+o]+1),r[a]=.5*t,t=.5/t,r[3]=(e[3*i+o]-e[3*o+i])*t,r[i]=(e[3*i+a]+e[3*a+i])*t,r[o]=(e[3*o+a]+e[3*a+o])*t}return r}(f(),U),p(this.rotation,this.rotation),this.camera=_(),this.invCamera=_(),this.updateCameraMatrix()}rotate(r,e){var a=n(t(),T(2*r[0]*this.invScreen[0]-1,-1,1),T(1-2*r[1]*this.invScreen[1],-1,1)),i=n(t(),T(2*e[0]*this.invScreen[0]-1,-1,1),T(1-2*e[1]*this.invScreen[1],-1,1)),o=w(a),s=w(i);this.rotation=g(this.rotation,o,this.rotation),this.rotation=g(this.rotation,s,this.rotation),this.updateCameraMatrix()}zoom(r){var e=o(a(),0,0,r*this.invScreen[1]*this.zoomSpeed),t=y(_(),e);this.translation=b(this.translation,t,this.translation),this.translation[14]>=-.2&&(this.translation[14]=-.2),this.updateCameraMatrix()}pan(r){var e=c(u(),r[0]*this.invScreen[0]*Math.abs(this.translation[14]),r[1]*this.invScreen[1]*Math.abs(this.translation[14]),0,0),t=v(u(),e,this.invCamera),n=y(_(),t);this.centerTranslation=b(this.centerTranslation,n,this.centerTranslation),this.updateCameraMatrix()}updateCameraMatrix(){var r=function(r,e){var t=e[0],n=e[1],a=e[2],i=e[3],o=t+t,s=n+n,l=a+a,u=t*o,c=n*o,m=n*s,v=a*o,f=a*s,h=a*l,d=i*o,g=i*s,p=i*l;return r[0]=1-m-h,r[1]=c+p,r[2]=v-g,r[3]=0,r[4]=c-p,r[5]=1-u-h,r[6]=f+d,r[7]=0,r[8]=v+g,r[9]=f-d,r[10]=1-u-m,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}(_(),this.rotation);this.camera=b(this.camera,r,this.centerTranslation),this.camera=b(this.camera,this.translation,this.camera),this.invCamera=x(this.invCamera,this.camera)}eyePos(){return[this.invCamera[12],this.invCamera[13],this.invCamera[14]]}eyeDir(){var r=c(u(),0,0,-1,0);return[(r=m(r=v(r,r,this.invCamera),r))[0],r[1],r[2]]}upDir(){var r=c(u(),0,1,0,0);return[(r=m(r=v(r,r,this.invCamera),r))[0],r[1],r[2]]}}function S(r,e){var t=[e[0]-r[0],e[1]-r[1]];return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2))}class G{constructor(){this.mousemove=null,this.press=null,this.wheel=null,this.twoFingerDrag=null,this.pinch=null}registerForCanvas(r){var e=null,t=this;r.addEventListener("mousemove",(function(n){n.preventDefault();var a=r.getBoundingClientRect(),i=[n.clientX-a.left,n.clientY-a.top];e?t.mousemove&&t.mousemove(e,i,n):e=[n.clientX-a.left,n.clientY-a.top],e=i})),r.addEventListener("mousedown",(function(e){e.preventDefault();var n=r.getBoundingClientRect(),a=[e.clientX-n.left,e.clientY-n.top];t.press&&t.press(a,e)})),r.addEventListener("wheel",(function(r){r.preventDefault(),t.wheel&&t.wheel(-r.deltaY)})),r.oncontextmenu=function(r){r.preventDefault()};var n={};r.addEventListener("touchstart",(function(e){var a=r.getBoundingClientRect();e.preventDefault();for(var i=0;i<e.changedTouches.length;++i){var o=e.changedTouches[i];n[o.identifier]=[o.clientX-a.left,o.clientY-a.top],1==e.changedTouches.length&&t.press&&t.press(n[o.identifier],e)}})),r.addEventListener("touchmove",(function(e){e.preventDefault();var a=r.getBoundingClientRect();if(1==Object.keys(n).length){if(t.mousemove){var i=e.changedTouches[0],o=n[i.identifier],s=[i.clientX-a.left,i.clientY-a.top];e.buttons=1,t.mousemove(o,s,e)}}else{for(var l={},u=0;u<e.changedTouches.length;++u)l[(i=e.changedTouches[u]).identifier]=[i.clientX-a.left,i.clientY-a.top];var c=[];for(i in n)i in l||(l[i]=n[i]),c.push(n[i]);var m=[];for(i in l)m.push(l[i]);var v=[vec2.set(vec2.create(),m[0][0]-c[0][0],m[0][1]-c[0][1]),vec2.set(vec2.create(),m[1][0]-c[1][0],m[1][1]-c[1][1])],f=[vec2.create(),vec2.create()];vec2.normalize(f[0],v[0]),vec2.normalize(f[1],v[1]);var h=vec2.set(vec2.create(),c[1][0]-c[0][0],c[1][1]-c[0][1]);vec2.normalize(h,h);var d=vec2.lerp(vec2.create(),v[0],v[1],.5);vec2.normalize(d,d);var g=[vec2.dot(h,f[0]),vec2.dot(h,f[1])],p=[vec2.dot(d,f[0]),vec2.dot(d,f[1])];if(t.pinch&&Math.abs(g[0])>.5&&Math.abs(g[1])>.5&&Math.sign(g[0])!=Math.sign(g[1])){var _=S(c[0],c[1]),x=S(m[0],m[1]);t.pinch(x-_)}else if(t.twoFingerDrag&&Math.abs(p[0])>.5&&Math.abs(p[1])>.5&&Math.sign(p[0])==Math.sign(p[1])){var y=vec2.lerp(vec2.create(),v[0],v[1],.5);y[1]=-y[1],t.twoFingerDrag(y)}}for(u=0;u<e.changedTouches.length;++u)i=e.changedTouches[u],n[i.identifier]=[i.clientX-a.left,i.clientY-a.top]}));var a=function(r){r.preventDefault();for(var e=0;e<r.changedTouches.length;++e){var t=r.changedTouches[e];delete n[t.identifier]}};r.addEventListener("touchcancel",a),r.addEventListener("touchend",a)}}const U=r.p+"aad74533c70863e5419a.png",E=r.p+"a5c11a572e6b4f458a45.png",P=r.p+"97fec048f06baef3d282.png",B=r.p+"1ef74900fa05b21736ff.png",R=r.p+"b340b67402670cf370a3.png",A=r.p+"c5acd61a762601c42272.png",C={Fuel:"7d87jcsh0qodk78/fuel_64x64x64_uint8.raw",Neghip:"zgocya7h33nltu9/neghip_64x64x64_uint8.raw","Hydrogen Atom":"jwbav8s3wmmxd5x/hydrogen_atom_128x128x128_uint8.raw","Boston Teapot":"w4y88hlf2nbduiv/boston_teapot_256x256x178_uint8.raw",Engine:"ld2sqwwd3vaq4zf/engine_256x256x128_uint8.raw",Bonsai:"rdnhdxmxtfxe0sa/bonsai_256x256x256_uint8.raw",Foot:"ic0mik3qv4vqacm/foot_256x256x256_uint8.raw",Skull:"5rfjobn0lvb7tmo/skull_256x256x256_uint8.raw",Aneurysm:"3ykigaiym8uiwbp/aneurism_256x256x256_uint8.raw"},I={"Cool Warm":U,"Matplotlib Plasma":E,"Matplotlib Virdis":P,Rainbow:B,"Samsel Linear Green":R,"Samsel Linear YGB 1211G":A};function k(r){var e=r.match(/.*\/(\w+)_(\d+)x(\d+)x(\d+)_(\w+)\.*/);return[parseInt(e[2]),parseInt(e[3]),parseInt(e[4])]}function L(r,e){return Math.floor((r+e-1)/e)*e}async function F(r){const e=k(r),t=e[0]*e[1]*e[2];var n=document.getElementById("loadingText"),a=document.getElementById("loadingProgressBar");n.innerHTML="Loading Volume...",a.setAttribute("style","width: 0%");var i="https://www.dl.dropboxusercontent.com/s/"+r+"?dl=1";try{for(var o=(await fetch(i)).body.getReader(),s=0,l=new Uint8Array(t);;){var{done:u,value:c}=await o.read();if(u)break;l.set(c,s);var m=(s+=c.length)/t*100;a.setAttribute("style",`width: ${m.toFixed(2)}%`)}return n.innerHTML="Volume Loaded",e[0]%256!=0?function(r,e){const t=[L(e[0],256),e[1],e[2]];var n=new Uint8Array(t[0]*t[1]*t[2]);const a=e[1]*e[2];for(var i=0;i<a;++i){var o=r.subarray(i*e[0],i*e[0]+e[0]);n.set(o,i*t[0])}return n}(l,e):l}catch(r){console.log(`Error loading volume: ${r}`),n.innerHTML="Error loading volume"}return null}async function D(r,e,t){var n=r.createTexture({size:e,format:"r8unorm",dimension:"3d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),a=r.createBuffer({size:t.length,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(a.getMappedRange()).set(t),a.unmap();var i=r.createCommandEncoder(),o={buffer:a,bytesPerRow:L(e[0],256),rowsPerImage:e[1]},s={texture:n};return i.copyBufferToTexture(o,s,e),r.queue.submit([i.finish()]),await r.queue.onSubmittedWorkDone(),n}async function z(r,e){var t=new Image;t.src=e,await t.decode();var n=await createImageBitmap(t),a=r.createTexture({size:[n.width,n.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),i={source:n},o={texture:a};return r.queue.copyExternalImageToTexture(i,o,[n.width,n.height]),await r.queue.onSubmittedWorkDone(),a}function N(r,e){for(var t in e){var n=document.createElement("option");n.value=t,n.innerHTML=t,r.appendChild(n)}}function O(r,e){const t=Math.cos(r),n=Math.sin(r);return[Math.cos(e)*n,Math.sin(e)*n,t]}(async()=>{if(void 0===navigator.gpu)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var r=await navigator.gpu.requestAdapter();if(!r)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var e=await r.requestDevice(),t=document.getElementById("webgpu-canvas"),n=t.getContext("webgpu"),i=e.createShaderModule({code:"const M_PI: f32 = 3.14159265358979323846;\r\n\r\n// Reduce clutter/keyboard pain\r\ntype float2 = vec2<f32>;\r\ntype float3 = vec3<f32>;\r\ntype float4 = vec4<f32>;\r\ntype uint2 = vec2<u32>;\r\ntype int2 = vec2<i32>;\r\n\r\n// TODO: Would need to write a custom webpack loader for wgsl that\r\n// processes #include to be able to #include this\r\nstruct LCGRand {\r\n     state: u32,\r\n};\r\n\r\nfn murmur_hash3_mix(hash_in: u32, k_in: u32) -> u32\r\n{\r\n    let c1 = 0xcc9e2d51u;\r\n    let c2 = 0x1b873593u;\r\n    let r1 = 15u;\r\n    let r2 = 13u;\r\n    let m = 5u;\r\n    let n = 0xe6546b64u;\r\n\r\n    var k = k_in * c1;\r\n    k = (k << r1) | (k >> (32u - r1));\r\n    k *= c2;\r\n\r\n    var hash = hash_in ^ k;\r\n    hash = ((hash << r2) | (hash >> (32u - r2))) * m + n;\r\n\r\n    return hash;\r\n}\r\n\r\nfn murmur_hash3_finalize(hash_in: u32) -> u32\r\n{\r\n    var hash = hash_in ^ (hash_in >> 16u);\r\n    hash *= 0x85ebca6bu;\r\n    hash ^= hash >> 13u;\r\n    hash *= 0xc2b2ae35u;\r\n    hash ^= hash >> 16u;\r\n\r\n    return hash;\r\n}\r\n\r\nfn lcg_random(rng: ptr<function, LCGRand>) -> u32\r\n{\r\n    let m = 1664525u;\r\n    let n = 1013904223u;\r\n    // WGSL please Add an arrow operator or only use refs/inout\r\n    // This is really a pain\r\n    (*rng).state = (*rng).state * m + n;\r\n    return (*rng).state;\r\n}\r\n\r\nfn lcg_randomf(rng: ptr<function, LCGRand>) -> f32\r\n{\r\n\treturn ldexp(f32(lcg_random(rng)), -32);\r\n}\r\n\r\nfn get_rng(frame_id: u32, pixel: int2, dims: int2) -> LCGRand\r\n{\r\n    var rng: LCGRand;\r\n    rng.state = murmur_hash3_mix(0u, u32(pixel.x + pixel.y * dims.x));\r\n    rng.state = murmur_hash3_mix(rng.state, frame_id);\r\n    rng.state = murmur_hash3_finalize(rng.state);\r\n    return rng;\r\n}\r\n\r\nstruct VertexInput {\r\n    @location(0) position: float3,\r\n};\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: float4,\r\n    @location(0) transformed_eye: float3,\r\n    @location(1) ray_dir: float3,\r\n};\r\n\r\nstruct ViewParams {\r\n    proj_view: mat4x4<f32>,\r\n    // Not sure on WGSL padding/alignment rules for blocks,\r\n    // just assume align/pad to vec4\r\n    eye_pos: float4,\r\n    volume_scale: float4,\r\n    light_dir: float4,\r\n    frame_id: u32,\r\n    sigma_t_scale: f32,\r\n    sigma_s_scale: f32\r\n};\r\n\r\n@group(0) @binding(0)\r\nvar<uniform> params: ViewParams;\r\n\r\n@group(0) @binding(1)\r\nvar volume: texture_3d<f32>;\r\n\r\n@group(0) @binding(2)\r\nvar colormap: texture_2d<f32>;\r\n\r\n@group(0) @binding(3)\r\nvar tex_sampler: sampler;\r\n\r\n// Why can't we read from storage textures or read/write from one?\r\n@group(0) @binding(4)\r\nvar accum_buffer_in: texture_2d<f32>;\r\n\r\n@group(0) @binding(5)\r\nvar accum_buffer_out: texture_storage_2d<rgba32float, write>;\r\n\r\n@vertex\r\nfn vertex_main(vert: VertexInput) -> VertexOutput {\r\n    var out: VertexOutput;\r\n    // Translate the volume to place its center at the origin to scale it\r\n    var volume_translation = float3(0.5) - params.volume_scale.xyz * 0.5;\r\n    var world_pos = vert.position * params.volume_scale.xyz + volume_translation;\r\n    out.position = params.proj_view * float4(world_pos, 1.0);\r\n\r\n    // Transform the eye into the scaled space\r\n    out.transformed_eye = (params.eye_pos.xyz - volume_translation) / params.volume_scale.xyz;\r\n    out.ray_dir = vert.position - out.transformed_eye;\r\n    return out;\r\n};\r\n\r\nfn intersect_box(orig: float3, dir: float3) -> float2 {\r\n\tvar box_min = float3(0.0);\r\n\tvar box_max = float3(1.0);\r\n\tvar inv_dir = 1.0 / dir;\r\n\tvar tmin_tmp = (box_min - orig) * inv_dir;\r\n\tvar tmax_tmp = (box_max - orig) * inv_dir;\r\n\tvar tmin = min(tmin_tmp, tmax_tmp);\r\n\tvar tmax = max(tmin_tmp, tmax_tmp);\r\n\tvar t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n\tvar t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n\treturn float2(t0, t1);\r\n}\r\n\r\nfn sample_spherical_direction(s: float2) -> float3 {\r\n    let cos_theta = 1.0 - 2.0 * s.x;\r\n    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));\r\n    let phi = s.y * 2.0 * M_PI;\r\n    return float3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\r\n}\r\n\r\nfn linear_to_srgb(x: f32) -> f32 {\r\n\tif (x <= 0.0031308) {\r\n\t\treturn 12.92 * x;\r\n\t}\r\n\treturn 1.055 * pow(x, 1.0 / 2.4) - 0.055;\r\n}\r\n\r\nstruct SamplingResult {\r\n    scattering_event: bool,\r\n    color: float3,\r\n    transmittance: f32,\r\n};\r\n\r\nfn sample_woodcock(orig: float3,\r\n                   dir: float3,\r\n                   interval: float2,\r\n                   t: ptr<function, f32>,\r\n                   rng: ptr<function, LCGRand>)\r\n                   -> SamplingResult\r\n{\r\n    var result: SamplingResult;\r\n    result.scattering_event = false;\r\n    result.color = float3(0.0);\r\n    result.transmittance = 0.0;\r\n    loop {\r\n        let samples = float2(lcg_randomf(rng), lcg_randomf(rng));\r\n\r\n        *t -= log(1.0 - samples.x) / params.sigma_t_scale;\r\n        if (*t >= interval.y) {\r\n            break;\r\n        }\r\n\r\n        var p = orig + *t * dir;\r\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\r\n        // TODO: opacity from transfer function in UI instead of just based on the scalar value\r\n        // Opacity values from the transfer fcn will already be in [0, 1]\r\n        var density = val;\r\n        //var sample_opacity = textureSampleLevel(colormap, tex_sampler, float2(val, 0.5), 0.0).a;\r\n        // Here the sigma t scale will cancel out\r\n        if (density > samples.y) {\r\n            result.scattering_event = true;\r\n            result.color = textureSampleLevel(colormap, tex_sampler, float2(val, 0.5), 0.0).rgb;\r\n            result.transmittance = (1.0 - val);\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfn delta_tracking_transmittance(orig: float3,\r\n                                dir: float3,\r\n                                interval: float2,\r\n                                rng: ptr<function, LCGRand>) -> f32\r\n{\r\n    var transmittance = 1.0;\r\n    var t = interval.x;\r\n    loop {\r\n        let samples = float2(lcg_randomf(rng), lcg_randomf(rng));\r\n\r\n        t -= log(1.0 - samples.x) / params.sigma_t_scale;\r\n        if (t >= interval.y) {\r\n            break;\r\n        }\r\n\r\n        var p = orig + t * dir;\r\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\r\n        // TODO: Sample opacity from colormap\r\n        if (val > samples.y) {\r\n            return 0.0;\r\n        }\r\n    }\r\n    return 1.0;\r\n}\r\n\r\nfn ratio_tracking_transmittance(orig: float3,\r\n                                dir: float3,\r\n                                interval: float2,\r\n                                rng: ptr<function, LCGRand>) -> f32\r\n{\r\n    var transmittance = 1.0;\r\n    var t = interval.x;\r\n    loop {\r\n        t -= log(1.0 - lcg_randomf(rng)) / params.sigma_t_scale;\r\n        if (t >= interval.y) {\r\n            break;\r\n        }\r\n\r\n        var p = orig + t * dir;\r\n        var val = textureSampleLevel(volume, tex_sampler, p, 0.0).r;\r\n        // TODO: Sample from the opacity colormap\r\n        transmittance *= (1.0 - val);\r\n    }\r\n    return transmittance;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\r\n    var ray_dir = normalize(in.ray_dir);\r\n\r\n\tvar t_interval = intersect_box(in.transformed_eye, ray_dir);\r\n\tif (t_interval.x > t_interval.y) {\r\n\t\tdiscard;\r\n\t}\r\n\tt_interval.x = max(t_interval.x, 0.0);\r\n\r\n    let pixel = int2(i32(in.position.x), i32(in.position.y));\r\n    // Image will be no larger than 1280x720 so we can keep this fixed\r\n    // for picking our RNG value\r\n    var rng = get_rng(params.frame_id, pixel, int2(1280, 720));\r\n\r\n    // This should just be 1 for the max density in scivis\r\n    var inv_max_density = 1.0;\r\n\r\n    let light_dir = params.light_dir.xyz;\r\n    let light_emission = params.light_dir.w;\r\n    let ambient_strength = 0.0;\r\n    let volume_emission = 0.5;\r\n\r\n    var illum = float3(0.0);\r\n    var throughput = float3(1.0);\r\n    var transmittance = 1.0;\r\n\r\n    var had_any_event = false;\r\n    var pos = in.transformed_eye;\r\n    // Sample the next scattering event in the volume\r\n    for (var i = 0; i < 4; i += 1) {\r\n        var t = t_interval.x;\r\n        var event = sample_woodcock(pos, ray_dir, t_interval, &t, &rng);\r\n\r\n        if (!event.scattering_event) {\r\n            // Illuminate with an \"environment light\"\r\n            if (had_any_event) {\r\n                illum += throughput * float3(ambient_strength);\r\n            } else {\r\n                illum = float3(0.1);\r\n            }\r\n            break;\r\n        } else {\r\n            had_any_event = true;\r\n\r\n            // Update scattered ray position\r\n            pos = pos + ray_dir * t;\r\n\r\n            // Sample illumination from the direct light\r\n            t_interval = intersect_box(pos, light_dir);\r\n            // We're inside the volume\r\n            t_interval.x = 0.0;\r\n            /*\r\n            var light_transmittance =\r\n                ratio_tracking_transmittance(pos, light_dir, t_interval, &rng);\r\n            */\r\n            var light_transmittance =\r\n                delta_tracking_transmittance(pos, light_dir, t_interval, &rng);\r\n            illum += throughput * light_transmittance * float3(light_emission);\r\n\r\n            // Include emission from the volume for emission/absorption scivis model\r\n            // Scaling the volume emission by the inverse of the opacity from the transfer function\r\n            // can give some nice effects. Would be cool to provide control of this\r\n            illum += throughput * event.color * volume_emission;// * (1.0 - event.transmittance);\r\n\r\n            throughput *= event.color * event.transmittance * params.sigma_s_scale;\r\n\r\n            // Scatter in a random direction to continue the ray\r\n            ray_dir = sample_spherical_direction(float2(lcg_randomf(&rng), lcg_randomf(&rng)));\r\n            t_interval = intersect_box(pos, ray_dir);\r\n            if (t_interval.x > t_interval.y) {\r\n                illum = float3(0.0, 1.0, 0.0);\r\n                break;\r\n            }\r\n            // We're now inside the volume\r\n            t_interval.x = 0.0;\r\n        }\r\n    }\r\n\r\n    var color = float4(illum, 1.0);\r\n\r\n    // Accumulate into the accumulation buffer for progressive accumulation \r\n    var accum_color = float4(0.0);\r\n    if (params.frame_id > 0u) {\r\n        accum_color = textureLoad(accum_buffer_in, pixel, 0);\r\n    }\r\n    accum_color += color;\r\n    textureStore(accum_buffer_out, pixel, accum_color);\r\n\r\n    color = accum_color / f32(params.frame_id + 1u);\r\n\r\n    // TODO: background color also needs to be sRGB-mapped, otherwise this\r\n    // causes the volume bounding box to show up incorrectly b/c of the\r\n    // differing brightness\r\n    color.r = linear_to_srgb(color.r);\r\n    color.g = linear_to_srgb(color.g);\r\n    color.b = linear_to_srgb(color.b);\r\n    return color;\r\n}\r\n\r\n"}),s=await i.compilationInfo();if(s.messages.length>0){var l=!1;console.log("Shader compilation log:");for(var u=0;u<s.messages.length;++u){var c=s.messages[u];console.log(`${c.lineNum}:${c.linePos} - ${c.message}`),l=l||"error"==c.type}if(l)return void console.log("Shader failed to compile")}const m=o(a(),.5,.5,2.5),v=o(a(),.5,.5,.5),f=o(a(),0,1,0),h=function(){for(var r=[1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0],e=[],t=0;t<r.length;++t)e.push(t);return{vertices:r,indices:e}}();var d=e.createBuffer({size:4*h.vertices.length,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(d.getMappedRange()).set(h.vertices),d.unmap();var g=e.createBuffer({size:4*h.indices.length,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(g.getMappedRange()).set(h.indices),g.unmap();var p=e.createBuffer({size:124,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),x=e.createSampler({magFilter:"linear",minFilter:"linear"}),y=document.getElementById("volumeList"),w=document.getElementById("colormapList");N(y,C),N(w,I);var T="Bonsai";if(window.location.hash){var S=decodeURI(window.location.hash.substring(1));if(!(S in C))return void alert(`Linked to invalid data set ${S}`);y.value=S,T=S}var U=k(C[T]);const E=Math.max(U[0],Math.max(U[1],U[2]));var P=[U[0]/E,U[1]/E,U[2]/E],B="Cool Warm",R=await z(e,I[B]),A=await F(C[T]).then((r=>D(e,U,r))),L=[e.createTexture({size:[t.width,t.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING}),e.createTexture({size:[t.width,t.height,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})],q=[L[0].createView(),L[1].createView()],V="bgra8unorm";n.configure({device:e,format:V,usage:GPUTextureUsage.OUTPUT_ATTACHMENT});var X=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float",viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,storageTexture:{access:"write-only",format:"rgba32float"}}]}),Y=e.createPipelineLayout({bindGroupLayouts:[X]}),j={module:i,entryPoint:"vertex_main",buffers:[{arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}]},W={module:i,entryPoint:"fragment_main",targets:[{format:V,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},$=e.createRenderPipeline({layout:Y,vertex:j,fragment:W,primitive:{topology:"triangle-strip",stripIndexFormat:"uint16",cullMode:"front"}}),H=.1<=.0031308?1.292:1.055*Math.pow(.1,1/2.4)-.055,J={colorAttachments:[{view:void 0,loadOp:"clear",clearValue:[H,H,H,1]}]},K=new M(m,v,f,2,[t.width,t.height]),Q=function(r,e,t,n,a){var i,o=1/Math.tan(e/2);return r[0]=o/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,null!=a&&a!==1/0?(i=1/(n-a),r[10]=(a+n)*i,r[14]=2*a*n*i):(r[10]=-1,r[14]=-2*n),r}(_(),50*Math.PI/180,t.width/t.height,.1,100),Z=_(),rr=0,er=new G;er.mousemove=function(r,e,t){1==t.buttons?(rr=0,K.rotate(r,e)):2==t.buttons&&(rr=0,K.pan([e[0]-r[0],r[1]-e[1]]))},er.wheel=function(r){rr=0,K.zoom(r)},er.pinch=er.wheel,er.twoFingerDrag=function(r){rr=0,K.pan(r)},er.registerForCanvas(t);var tr=document.getElementById("phiRange"),nr=document.getElementById("thetaRange"),ar=document.getElementById("lightStrength");tr.oninput=function(){rr=0},nr.oninput=function(){rr=0},ar.oninput=function(){rr=0};var ir=function(){var r=null,e=new Promise((e=>r=e));return window.requestAnimationFrame(r),e};requestAnimationFrame(ir);for(var or=[{binding:0,resource:{buffer:p}},{binding:1,resource:A.createView()},{binding:2,resource:R.createView()},{binding:3,resource:x},{binding:4,resource:null},{binding:5,resource:null}];;)if(await ir(),!document.hidden){if(T!=y.value){T=y.value,history.replaceState(history.state,"","#"+T),U=k(C[T]);const r=Math.max(U[0],Math.max(U[1],U[2]));P=[U[0]/r,U[1]/r,U[2]/r],A=await F(C[T]).then((r=>D(e,U,r))),rr=0,or[1].resource=A.createView()}B!=w.value&&(B=w.value,R=await z(e,I[B]),rr=0,or[2].resource=R.createView()),Z=b(Z,Q,K.camera);var sr=O(nr.value,tr.value),lr=e.createBuffer({size:124,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),ur=K.eyePos(),cr=lr.getMappedRange(),mr=new Float32Array(cr),vr=new Uint32Array(cr);mr.set(Z,0),mr.set(ur,16),mr.set(P,20),mr.set(sr,24),mr.set([ar.value],27),vr.set([rr],28),mr.set([100,1],29),lr.unmap(),or[4].resource=q[rr%2],or[5].resource=q[(rr+1)%2];var fr=e.createBindGroup({layout:X,entries:or}),hr=e.createCommandEncoder();hr.copyBufferToBuffer(lr,0,p,0,124),J.colorAttachments[0].view=n.getCurrentTexture().createView();var dr=hr.beginRenderPass(J);dr.setPipeline($),dr.setBindGroup(0,fr),dr.setVertexBuffer(0,d),dr.setIndexBuffer(g,"uint16"),dr.draw(h.vertices.length/3,1,0,0),dr.end(),e.queue.submit([hr.finish()]),lr.destroy(),rr+=1}})()})();