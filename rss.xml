<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
	<channel>
		<title>Will Usher's Blog</title>
		<description>Computer Graphics and Programming</description>
		<link>https://www.willusher.io</link>
		<lastBuildDate>Tue, 27 Aug 2019 13:39:27 -0600</lastBuildDate>
		<pubDate>Tue, 27 Aug 2019 13:39:27 -0600</pubDate>
		<ttl>60</ttl>
		
		<item>
			<title>Volume Rendering with WebGL</title>
			<description>
				
&lt;figure&gt;
	&lt;img class=&quot;img-fluid&quot; src=&quot;https://i.imgur.com/YqdyKCj.png&quot; /&gt;
	
	&lt;figcaption&gt;&lt;i&gt;Figure 1:
	Example volume renderings, using the WebGL volume renderer described in this post.
	Left: A simulation of the spatial probability distribution
	of electrons in a high potential protein molecule.
	Right: A CT scan of a Bonsai Tree.
	Both datasets are from the
	&lt;a href=&quot;https://klacansky.com/open-scivis-datasets/&quot;&gt;Open SciVis Datasets&lt;/a&gt;
	repository.
	&lt;/i&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In scientific visualization, volume rendering is widely used to visualize
3D scalar fields. These scalar fields are often
uniform grids of values, representing,
for example, charge density around a molecule,
an MRI or CT scan, air flow around an airplane, etc.
Volume rendering is a conceptually straightforward method
for turning such data into an image: by sampling the data
along rays from the eye and assigning
a color and transparency to each sample, we can
produce useful and beautiful images of such scalar fields
(see Figure 1).
In a GPU renderer, these 3D scalar fields are stored
as 3D textures; however, in WebGL1 3D textures were
not supported, requiring additional hacks to emulate them
for volume rendering.
Recently, WebGL2 added support for 3D textures,
allowing for an elegant and fast volume renderer to be
implemented entirely in the browser.
In this post we’ll discuss the mathematical background
for volume rendering, and how it can be implemented in
WebGL2 to create an interactive volume renderer
entirely in the browser!
Before we start, you can try out the volume renderer
described in this post &lt;a href=&quot;https://www.willusher.io/webgl-volume-raycaster/&quot;&gt;online&lt;/a&gt;.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//webgl/2019/01/13/volume-rendering-with-webgl</link>
			<pubDate>Sun, 13 Jan 2019 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Comments in LaTeX</title>
			<description>
				
&lt;p&gt;When writing a paper in LaTeX, it’s common to leave
notes and comments in the text, either to yourself
or your co-authors. I used to write these
as just different colored text using &lt;code class=&quot;highlighter-rouge&quot;&gt;\textcolor{...}&lt;/code&gt;,
with each author assigned a color, or all with the same color.
However, with more authors
it can get hard to keep picking legible font colors.
Futhermore, sometimes just a different color font doesn’t
stand out quite as much as I’d like from the rest of the text.
More recently I’ve switched to using highlights for
the comments, which works well with multiple authors,
and helps the comments stand out from the rest of
the text. This is easy to do with the
&lt;a href=&quot;https://ctan.org/pkg/soul?lang=en&quot;&gt;soul&lt;/a&gt; and
&lt;a href=&quot;https://ctan.org/pkg/xcolor?lang=en&quot;&gt;xcolor&lt;/a&gt; packages.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//latex/2018/07/10/comments-in-latex</link>
			<pubDate>Tue, 10 Jul 2018 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Distributed Rendering with Rust and Mio</title>
			<description>
				
&lt;p&gt;In this post we’ll take a look at adding distributed rendering to
&lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;tray_rust&lt;/a&gt; which will let us take advantage of multiple
machines when rendering an image, like a compute cluster.
To do this we’ll look at options for how to distribute the rendering job across multiple nodes
and what sort of communication is needed synchronize their work. We’ll also look into how we
can use &lt;a href=&quot;https://github.com/carllerche/mio&quot;&gt;mio&lt;/a&gt; to write an efficient master process that
can manage multiple workers effectively.&lt;/p&gt;

&lt;p&gt;After implementing a simple technique to distribute the job we’ll discuss
the scalability of this approach and possible paths forward to improve it. I’ve
also recently written a &lt;a href=&quot;https://github.com/Twinklebear/tray_rust_blender&quot;&gt;plugin for Blender&lt;/a&gt; so you can
easily create your own scenes and
will mention a bit on how to run the ray tracer on Google Compute Engine (or AWS EC2)
if you want to try out the distributed rendering yourself.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//2016/01/02/distributed-rendering-with-rust-and-mio</link>
			<pubDate>Sat, 02 Jan 2016 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Rendering an Animation in Rust</title>
			<description>
				
&lt;p&gt;In this post we’ll look at adding a pretty awesome new feature to &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;tray_rust&lt;/a&gt;,
something I’ve never implemented before: animation! We’ll take a look at a simple way for sampling time in our scene, how
we can associate time points with transformations of objects to make them move and how to compute smooth animation
paths with B-Splines. Then we’ll wrap up with rendering a really cool animation by using 60 different
machines spread across two clusters at my lab.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//2015/12/16/rendering-an-animation-in-rust</link>
			<pubDate>Wed, 16 Dec 2015 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Porting a Ray Tracer to Rust, part 3</title>
			<description>
				
&lt;p&gt;It’s been a little while since my last post on tray_rust as I’ve been a busy with classes, but I’ve
had a bit of free time to implement some extremely cool features. In this post we’ll look at porting over
the path tracing code and adding a bounding volume hierarchy, along with adding support for triangle meshes and measured material data from the
&lt;a href=&quot;http://www.merl.com/brdf/&quot;&gt;MERL BRDF Database&lt;/a&gt; introduced by Matusik et al. in 2003 in
&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=882343&quot;&gt;A Data-Driven Reflectance Model&lt;/a&gt;. In the process of implementing the BVH we’ll get a taste
of Rust’s generic programming facilities and use them to write a flexible BVH capable of storing any type that can
report its bounds. In the spirit of fogleman’s gorgeous &lt;a href=&quot;https://github.com/fogleman/pt&quot;&gt;Go Gopher in Go&lt;/a&gt; we’ll wrap up
by rendering the Rust logo in Rust using a model made by
&lt;a href=&quot;http://blenderartists.org/forum/showthread.php?362836-Rust-language-3D-logo&quot;&gt;Nylithius on BlenderArtists&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve been following Rust’s development a bit you have probably noticed that the timing of this post is not a
coincidence, since Rust 1.0.0 is being released &lt;a href=&quot;http://blog.rust-lang.org/2015/05/15/Rust-1.0.html&quot;&gt;today&lt;/a&gt;!&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//2015/05/15/porting-a-ray-tracer-to-rust-part-3</link>
			<pubDate>Fri, 15 May 2015 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Porting a Ray Tracer to Rust, part 2</title>
			<description>
				
&lt;p&gt;As mentioned in my &lt;a href=&quot;/2014/12/30/porting-a-ray-tracer-to-rust-part-1&quot;&gt;previous post&lt;/a&gt; I spent the past month-ish
working on improving both the rendering capabilities and performance of &lt;a href=&quot;https://github.com/Twinklebear/tray_rust&quot;&gt;tray_rust&lt;/a&gt;.
While it’s not yet capable of path tracing we can at least have light and shadow and shade our objects with diffuse or specularly
reflective and/or transmissive materials. Along with this I’ve improved performance by parallelizing
the rendering process using Rust’s multithreading capabilities. Although ray tracing is a trivially parallel task there are
two pieces of state that must be shared and modified between threads: the pixel/block counter and the framebuffer.
With Rust’s strong focus on safety I was worried that I would have to resort to unsafe blocks to share these
small pieces of mutable state but I found that the &lt;a href=&quot;http://doc.rust-lang.org/std/sync/index.html&quot;&gt;std::sync module&lt;/a&gt;
provided safe methods for everything I needed and performs quite well. While it’s difficult to compare against
&lt;a href=&quot;https://github.com/Twinklebear/tray&quot;&gt;tray&lt;/a&gt; (my initial C++ version) as the design of tray_rust has diverged quite 
a bit I’ll put some performance numbers in the multithreading section.&lt;/p&gt;

&lt;p&gt;During the past month &lt;a href=&quot;http://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; has also seen some pretty large changes and is currently
in its 1.0 alpha release with the &lt;a href=&quot;http://blog.rust-lang.org/2014/12/12/1.0-Timeline.html&quot;&gt;first beta&lt;/a&gt;
fast approaching.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//2015/01/30/porting-a-ray-tracer-to-rust-part-2</link>
			<pubDate>Fri, 30 Jan 2015 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Porting a Ray Tracer to Rust, part 1</title>
			<description>
				
&lt;p&gt;I’ve decided to port over my physically based ray tracer &lt;a href=&quot;https://github.com/Twinklebear/tray&quot;&gt;tray&lt;/a&gt;
to &lt;a href=&quot;http://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; to finally try out the language with a decent sized project.
In the series we’ll work through the implementation of a physically based ray tracer built
on the techniques discussed in &lt;a href=&quot;http://pbrt.org/&quot;&gt;Physically Based Rendering&lt;/a&gt;. I won’t go into a lot of
detail about rendering theory or the less exciting implementation details but will focus more on Rust
specific concerns and implementation decisions along with comparisons vs. my C++ version.
If you’re looking to learn more about ray tracing I highly recommend picking up Physically
Based Rendering and working through it. Hopefully throughout the series folks more experienced
with Rust can point out mistakes and improvements as well, since I have no experience with Rust
prior to this series.&lt;/p&gt;

&lt;p&gt;With the intro out of the way, let’s get started! Since it’s the beginning of
the series this is my first time really working with Rust and our goal is pretty simple: render a white
sphere and save the image.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//2014/12/30/porting-a-ray-tracer-to-rust-part-1</link>
			<pubDate>Tue, 30 Dec 2014 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Postscript 1: Easy Cleanup</title>
			<description>
				
&lt;p&gt;In this quick postscript we’ll look into a simple way to clean up our various SDL resources with variadic templates
and template specialization. This will let us clean up all our resources with a single simple call:
&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup(texA, texB, renderer, window)&lt;/code&gt; instead of calling all the corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Destroy/Free*&lt;/code&gt; functions,
saving ourselves a lot of typing.&lt;/p&gt;

&lt;p&gt;We’ll do this by creating a variadic function &lt;code class=&quot;highlighter-rouge&quot;&gt;cleanup&lt;/code&gt; that will take the list of SDL resources to be free’d and then
define specializations of it for each resource we’ll be passing, eg. for &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Window&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Renderer&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Texture&lt;/code&gt;
and so on.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2014/08/01/postscript-1-easy-cleanup</link>
			<pubDate>Fri, 01 Aug 2014 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Postscript 0: Properly Finding Resource Paths</title>
			<description>
				
&lt;p&gt;In this short postscript we’ll learn how to make use of &lt;a href=&quot;https://wiki.libsdl.org/SDL_GetBasePath&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_GetBasePath&lt;/code&gt;&lt;/a&gt; to
properly resolve the path to our resource directory where we’ll be storing all the assets needed for each lesson.
This approach lets us avoid issues with relative paths since it doesn’t depend on where the program working
directory is set when it’s run. This functionality was introduced in SDL 2.0.1 so if you haven’t updated to the latest SDL
be sure to grab that before getting started.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2014/06/16/postscript-0-properly-finding-resource-paths</link>
			<pubDate>Mon, 16 Jun 2014 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 0: CMake</title>
			<description>
				
&lt;p&gt;CMake is really useful for building the lessons since it lets us generate make files or project files for just about
any platform and IDE. It also helps with resolving dependencies (such as SDL2), platform specific configurations and
much much more. If you’re unfamiliar with CMake there’s a nice introduction
available on &lt;a href=&quot;http://www.cmake.org/cmake/help/cmake_tutorial.html&quot;&gt;their site&lt;/a&gt; to help you get started.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2014/03/06/lesson-0-cmake</link>
			<pubDate>Thu, 06 Mar 2014 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Lesson 6: True Type Fonts with SDL_ttf</title>
			<description>
				
&lt;p&gt;In this lesson we’ll see how to perform basic True Type font rendering with the SDL_ttf extension library.
Setting up the library is identical to what we did in
&lt;a href=&quot;/sdl2%20tutorials/2013/08/18/lesson-3-sdl-extension-libraries&quot;&gt;Lesson 3&lt;/a&gt; for SDL_image, but just replace
“image” with “ttf” (Windows users should also copy the included freetype dll over). So &lt;a href=&quot;http://www.libsdl.org/projects/SDL_ttf/&quot;&gt;download SDL_ttf&lt;/a&gt;,
take a peek at the &lt;a href=&quot;http://www.libsdl.org/projects/SDL_ttf/docs/index.html&quot;&gt;documentation&lt;/a&gt;, and let’s get started!&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/12/18/lesson-6-true-type-fonts-with-sdl_ttf</link>
			<pubDate>Wed, 18 Dec 2013 00:00:00 -0700</pubDate>
		</item>
		
		<item>
			<title>Lesson 5: Clipping Sprite Sheets</title>
			<description>
				
&lt;p&gt;It’s common in sprite based games to use a larger image file containing many smaller images, such as the 
tiles for a tileset, instead of having a separate image file for each tile. This type of image is known
as a sprite sheet and is very handy to work with since we don’t need to change which texture we’re drawing
each time but rather just which subsection of the texture.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/27/lesson-5-clipping-sprite-sheets</link>
			<pubDate>Tue, 27 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 4: Handling Events</title>
			<description>
				
&lt;p&gt;In this lesson we’ll learn the basics of reading user input with SDL, in this simple example we’ll interpret any input
as the user wanting to quit our application.
To read events SDL provides the &lt;a href=&quot;http://wiki.libsdl.org/SDL_Event&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_Event&lt;/code&gt;&lt;/a&gt; structure
and functions to get events from the queue such as &lt;a href=&quot;http://wiki.libsdl.org/SDL_PollEvent&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SDL_PollEvent&lt;/code&gt;&lt;/a&gt;.
The code for this lesson is built off of the lesson 3 code, if you need that code to start from grab it on &lt;a href=&quot;https://github.com/Twinklebear/TwinklebearDev-Lessons/tree/master/Lesson3&quot;&gt;Github&lt;/a&gt; and let’s get started!&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/20/lesson-4-handling-events</link>
			<pubDate>Tue, 20 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 3: SDL Extension Libraries</title>
			<description>
				
&lt;p&gt;Up until now we’ve only been using BMP images as they’re the only type supported by the base SDL library,
but being restricted to using BMP images isn’t that great. Fortunately there are a set of SDL extension libraries
that add useful features to SDL, such as support for a wide variety of image types through 
&lt;a href=&quot;http://www.libsdl.org/projects/SDL_image/&quot;&gt;SDL_image&lt;/a&gt;. The other available libraries are
&lt;a href=&quot;http://www.libsdl.org/projects/SDL_ttf/&quot;&gt;SDL_ttf&lt;/a&gt; which provides TTF rendering support, 
&lt;a href=&quot;http://www.libsdl.org/projects/SDL_net/&quot;&gt;SDL_net&lt;/a&gt; which provides low level networking
and &lt;a href=&quot;http://www.libsdl.org/projects/SDL_mixer/&quot;&gt;SDL_mixer&lt;/a&gt; which provides multi-channel audio playback.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/18/lesson-3-sdl-extension-libraries</link>
			<pubDate>Sun, 18 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 2: Don&#39;t Put Everything in Main</title>
			<description>
				
&lt;p&gt;In this lesson we’ll begin organizing our texture loading and rendering code from the previous lesson by 
moving them out of main and placing them into some useful functions. We’ll also write a simple generic
SDL error logger and learn how images are positioned and scaled when rendering with SDL.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/17/lesson-2-dont-put-everything-in-main</link>
			<pubDate>Sat, 17 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 1: Hello World</title>
			<description>
				
&lt;p&gt;In this lesson we’ll learn how to open a window, create a rendering context and draw
an image we’ve loaded to the screen. Grab the BMP we’ll be drawing below and save it somewhere in your
project and let’s get started!&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/17/lesson-1-hello-world</link>
			<pubDate>Sat, 17 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 0: Visual Studio</title>
			<description>
				
&lt;p&gt;Now that we’ve got the libraries installed we’ll want to create a new project to include and
link against SDL. At the end we’ll save this as a template project so in the future we can just
load our template and get to work. First we need a new empty C++ project.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/15/lesson-0-visual-studio</link>
			<pubDate>Thu, 15 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 0: Setting Up SDL</title>
			<description>
				
&lt;p&gt;The first step is to get the SDL2 development libraries setup on your system, you can download
them from the &lt;a href=&quot;http://www.libsdl.org/download-2.0.php&quot;&gt;SDL2 downloads page&lt;/a&gt;.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/15/lesson-0-setting-up-sdl</link>
			<pubDate>Thu, 15 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 0: MinGW</title>
			<description>
				
&lt;p&gt;To build the projects with mingw we’ll be using a lightweight makefile that will set the
include and library paths along with linking our dependencies for us. The makefile assumes
that you’ve placed the SDL mingw development libraries under &lt;code class=&quot;highlighter-rouge&quot;&gt;C:/SDL2-2.0.0-mingw/&lt;/code&gt; and that
you’re using the 32bit version of mingw and the 32bit libraries. You should change this to 
match your compiler (32/64bit) and the location of your SDL folder. To use makefiles with mingw call
&lt;code class=&quot;highlighter-rouge&quot;&gt;mingw32-make.exe&lt;/code&gt; in the folder containing the makefile.&lt;/p&gt;

&lt;p&gt;If you’re unfamiliar with Makefiles a basic introduction can be found &lt;a href=&quot;http://mrbook.org/blog/tutorials/make/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/15/lesson-0-mingw</link>
			<pubDate>Thu, 15 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 0: Mac Command Line</title>
			<description>
				
&lt;p&gt;To build the projects on OS X we’ll be using a simple makefile that will include the framework for us.
The makefile assumes you’ve installed SDL following the instructions in the .dmg file on the SDL2
downloads page and now have it available as a framework.&lt;/p&gt;

&lt;p&gt;If you’re unfamiliar with Makefiles a basic introduction can be found &lt;a href=&quot;http://mrbook.org/blog/tutorials/make/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/15/lesson-0-mac-command-line</link>
			<pubDate>Thu, 15 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
		<item>
			<title>Lesson 0: Linux Command Line</title>
			<description>
				
&lt;p&gt;To build the projects on Linux we’ll be using a simple makefile that will setup the include and library
dependencies for us. The makefile assumes that your SDL libraries are installed under &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/lib&lt;/code&gt;
and the headers are under &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/include&lt;/code&gt;. These are the install locations if you built the
project through cmake, some more detail on building from source can be found &lt;a href=&quot;http://twinklebear.github.io/sdl2%20tutorials/2013/08/15/lesson-0-linux-command-line/#comment-1053605032&quot;&gt;here&lt;/a&gt;. 
If you’ve installed it through your package manager or placed the libraries 
and headers elsewhere you may need to change these paths to match your installation. You can also check the output
of &lt;code class=&quot;highlighter-rouge&quot;&gt;sdl2-config&lt;/code&gt; with the &lt;code class=&quot;highlighter-rouge&quot;&gt;--cflags&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;--libs&lt;/code&gt; switches to locate your install, assuming you haven’t moved it.&lt;/p&gt;

&lt;p&gt;If you’re unfamiliar with Makefiles a basic introduction can be found &lt;a href=&quot;http://mrbook.org/blog/tutorials/make/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;


			</description>
			<link>https://www.willusher.io//sdl2%20tutorials/2013/08/15/lesson-0-linux-command-line</link>
			<pubDate>Thu, 15 Aug 2013 00:00:00 -0600</pubDate>
		</item>
		
	</channel>
</rss>
