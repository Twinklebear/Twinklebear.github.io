(()=>{"use strict";var t="undefined"!=typeof Float32Array?Float32Array:Array;function e(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}function n(t,e,n){return t[0]=e,t[1]=n,t}function r(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,n,r){var a=new t(3);return a[0]=e,a[1]=n,a[2]=r,a}function i(t,e,n,r){return t[0]=e,t[1]=n,t[2]=r,t}function o(t,e){var n=e[0],r=e[1],a=e[2],i=n*n+r*r+a*a;return i>0&&(i=1/Math.sqrt(i)),t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t}function l(t,e,n){var r=e[0],a=e[1],i=e[2],o=n[0],l=n[1],s=n[2];return t[0]=a*s-i*l,t[1]=i*o-r*s,t[2]=r*l-a*o,t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)}),e();function s(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function u(t,e,n,r,a){return t[0]=e,t[1]=n,t[2]=r,t[3]=a,t}function c(t,e){var n=e[0],r=e[1],a=e[2],i=e[3],o=n*n+r*r+a*a+i*i;return o>0&&(o=1/Math.sqrt(o)),t[0]=n*o,t[1]=r*o,t[2]=a*o,t[3]=i*o,t}function f(t,e,n){var r=e[0],a=e[1],i=e[2],o=e[3];return t[0]=n[0]*r+n[4]*a+n[8]*i+n[12]*o,t[1]=n[1]*r+n[5]*a+n[9]*i+n[13]*o,t[2]=n[2]*r+n[6]*a+n[10]*i+n[14]*o,t[3]=n[3]*r+n[7]*a+n[11]*i+n[15]*o,t}function v(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}r(),s();var d,_=u,p=function(t,e,n){var r=e[0],a=e[1],i=e[2],o=e[3],l=n[0],s=n[1],u=n[2],c=n[3];return t[0]=r*c+o*l+a*u-i*s,t[1]=a*c+o*s+i*l-r*u,t[2]=i*c+o*u+r*s-a*l,t[3]=o*c-r*l-a*s-i*u,t},m=c;function h(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function g(t,e){var n=e[0],r=e[1],a=e[2],i=e[3],o=e[4],l=e[5],s=e[6],u=e[7],c=e[8],f=e[9],v=e[10],d=e[11],_=e[12],p=e[13],m=e[14],h=e[15],g=n*l-r*o,y=n*s-a*o,x=n*u-i*o,b=r*s-a*l,w=r*u-i*l,M=a*u-i*s,z=c*p-f*_,T=c*m-v*_,A=c*h-d*_,P=f*m-v*p,B=f*h-d*p,C=v*h-d*m,I=g*C-y*B+x*P+b*A-w*T+M*z;return I?(I=1/I,t[0]=(l*C-s*B+u*P)*I,t[1]=(a*B-r*C-i*P)*I,t[2]=(p*M-m*w+h*b)*I,t[3]=(v*w-f*M-d*b)*I,t[4]=(s*A-o*C-u*T)*I,t[5]=(n*C-a*A+i*T)*I,t[6]=(m*x-_*M-h*y)*I,t[7]=(c*M-v*x+d*y)*I,t[8]=(o*B-l*A+u*z)*I,t[9]=(r*A-n*B-i*z)*I,t[10]=(_*w-p*x+h*g)*I,t[11]=(f*x-c*w-d*g)*I,t[12]=(l*T-o*P-s*z)*I,t[13]=(n*P-r*T+a*z)*I,t[14]=(p*y-_*b-m*g)*I,t[15]=(c*b-f*y+v*g)*I,t):null}function y(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}r(),a(1,0,0),a(0,1,0),v(),v(),d=new t(9),t!=Float32Array&&(d[1]=0,d[2]=0,d[3]=0,d[5]=0,d[6]=0,d[7]=0),d[0]=1,d[4]=1,d[8]=1;var x=function(t,e,n){var r=e[0],a=e[1],i=e[2],o=e[3],l=e[4],s=e[5],u=e[6],c=e[7],f=e[8],v=e[9],d=e[10],_=e[11],p=e[12],m=e[13],h=e[14],g=e[15],y=n[0],x=n[1],b=n[2],w=n[3];return t[0]=y*r+x*l+b*f+w*p,t[1]=y*a+x*s+b*v+w*m,t[2]=y*i+x*u+b*d+w*h,t[3]=y*o+x*c+b*_+w*g,y=n[4],x=n[5],b=n[6],w=n[7],t[4]=y*r+x*l+b*f+w*p,t[5]=y*a+x*s+b*v+w*m,t[6]=y*i+x*u+b*d+w*h,t[7]=y*o+x*c+b*_+w*g,y=n[8],x=n[9],b=n[10],w=n[11],t[8]=y*r+x*l+b*f+w*p,t[9]=y*a+x*s+b*v+w*m,t[10]=y*i+x*u+b*d+w*h,t[11]=y*o+x*c+b*_+w*g,y=n[12],x=n[13],b=n[14],w=n[15],t[12]=y*r+x*l+b*f+w*p,t[13]=y*a+x*s+b*v+w*m,t[14]=y*i+x*u+b*d+w*h,t[15]=y*o+x*c+b*_+w*g,t};function b(t){var n,r,a=(r=t,(n=t)[0]*r[0]+n[1]*r[1]);if(a<=1)return _(v(),t[0],t[1],Math.sqrt(1-a),0);var i=function(t,e){var n=e[0],r=e[1],a=n*n+r*r;return a>0&&(a=1/Math.sqrt(a)),t[0]=e[0]*a,t[1]=e[1]*a,t}(e(),t);return _(v(),i[0],i[1],0,0)}function w(t,e,n){return t<e?e:t>n?n:t}class M{constructor(e,n,a,s,u){var c=i(r(),e[0],e[1],e[2]),f=i(r(),n[0],n[1],n[2]),d=i(r(),a[0],a[1],a[2]);o(d,d);var _,p,x,b,w=function(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t}(r(),f,c),M=(p=(_=w)[0],x=_[1],b=_[2],Math.hypot(p,x,b));o(w,w);var z=l(r(),w,d);o(z,z);var T=l(r(),z,w);o(T,T),l(z,w,T),o(z,z),this.zoomSpeed=s,this.invScreen=[1/u[0],1/u[1]],this.centerTranslation=y(h(),n),g(this.centerTranslation,this.centerTranslation);var A=i(r(),0,0,-1*M);this.translation=y(h(),A);var P=function(e,n,r,a,i,o,l,s,u){var c=new t(9);return c[0]=e,c[1]=n,c[2]=r,c[3]=a,c[4]=i,c[5]=o,c[6]=l,c[7]=s,c[8]=u,c}(z[0],z[1],z[2],T[0],T[1],T[2],-w[0],-w[1],-w[2]);!function(t,e){if(t===e){var n=e[1],r=e[2],a=e[5];t[1]=e[3],t[2]=e[6],t[3]=n,t[5]=e[7],t[6]=r,t[7]=a}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8]}(P,P),this.rotation=function(t,e){var n,r=e[0]+e[4]+e[8];if(r>0)n=Math.sqrt(r+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{var a=0;e[4]>e[0]&&(a=1),e[8]>e[3*a+a]&&(a=2);var i=(a+1)%3,o=(a+2)%3;n=Math.sqrt(e[3*a+a]-e[3*i+i]-e[3*o+o]+1),t[a]=.5*n,n=.5/n,t[3]=(e[3*i+o]-e[3*o+i])*n,t[i]=(e[3*i+a]+e[3*a+i])*n,t[o]=(e[3*o+a]+e[3*a+o])*n}return t}(v(),P),m(this.rotation,this.rotation),this.camera=h(),this.invCamera=h(),this.updateCameraMatrix()}rotate(t,r){var a=n(e(),w(2*t[0]*this.invScreen[0]-1,-1,1),w(1-2*t[1]*this.invScreen[1],-1,1)),i=n(e(),w(2*r[0]*this.invScreen[0]-1,-1,1),w(1-2*r[1]*this.invScreen[1],-1,1)),o=b(a),l=b(i);this.rotation=p(this.rotation,o,this.rotation),this.rotation=p(this.rotation,l,this.rotation),this.updateCameraMatrix()}zoom(t){var e=i(r(),0,0,t*this.invScreen[1]*this.zoomSpeed),n=y(h(),e);this.translation=x(this.translation,n,this.translation),this.translation[14]>=-.2&&(this.translation[14]=-.2),this.updateCameraMatrix()}pan(t){var e=u(s(),t[0]*this.invScreen[0]*Math.abs(this.translation[14]),t[1]*this.invScreen[1]*Math.abs(this.translation[14]),0,0),n=f(s(),e,this.invCamera),r=y(h(),n);this.centerTranslation=x(this.centerTranslation,r,this.centerTranslation),this.updateCameraMatrix()}updateCameraMatrix(){var t=function(t,e){var n=e[0],r=e[1],a=e[2],i=e[3],o=n+n,l=r+r,s=a+a,u=n*o,c=r*o,f=r*l,v=a*o,d=a*l,_=a*s,p=i*o,m=i*l,h=i*s;return t[0]=1-f-_,t[1]=c+h,t[2]=v-m,t[3]=0,t[4]=c-h,t[5]=1-u-_,t[6]=d+p,t[7]=0,t[8]=v+m,t[9]=d-p,t[10]=1-u-f,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}(h(),this.rotation);this.camera=x(this.camera,t,this.centerTranslation),this.camera=x(this.camera,this.translation,this.camera),this.invCamera=g(this.invCamera,this.camera)}eyePos(){return[this.invCamera[12],this.invCamera[13],this.invCamera[14]]}eyeDir(){var t=u(s(),0,0,-1,0);return[(t=c(t=f(t,t,this.invCamera),t))[0],t[1],t[2]]}upDir(){var t=u(s(),0,1,0,0);return[(t=c(t=f(t,t,this.invCamera),t))[0],t[1],t[2]]}}function z(t,e){var n=[e[0]-t[0],e[1]-t[1]];return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2))}class T{constructor(){this.mousemove=null,this.press=null,this.wheel=null,this.twoFingerDrag=null,this.pinch=null}registerForCanvas(t){var e=null,n=this;t.addEventListener("mousemove",(function(r){r.preventDefault();var a=t.getBoundingClientRect(),i=[r.clientX-a.left,r.clientY-a.top];e?n.mousemove&&n.mousemove(e,i,r):e=[r.clientX-a.left,r.clientY-a.top],e=i})),t.addEventListener("mousedown",(function(e){e.preventDefault();var r=t.getBoundingClientRect(),a=[e.clientX-r.left,e.clientY-r.top];n.press&&n.press(a,e)})),t.addEventListener("wheel",(function(t){t.preventDefault(),n.wheel&&n.wheel(-t.deltaY)})),t.oncontextmenu=function(t){t.preventDefault()};var r={};t.addEventListener("touchstart",(function(e){var a=t.getBoundingClientRect();e.preventDefault();for(var i=0;i<e.changedTouches.length;++i){var o=e.changedTouches[i];r[o.identifier]=[o.clientX-a.left,o.clientY-a.top],1==e.changedTouches.length&&n.press&&n.press(r[o.identifier],e)}})),t.addEventListener("touchmove",(function(e){e.preventDefault();var a=t.getBoundingClientRect();if(1==Object.keys(r).length){if(n.mousemove){var i=e.changedTouches[0],o=r[i.identifier],l=[i.clientX-a.left,i.clientY-a.top];e.buttons=1,n.mousemove(o,l,e)}}else{for(var s={},u=0;u<e.changedTouches.length;++u)s[(i=e.changedTouches[u]).identifier]=[i.clientX-a.left,i.clientY-a.top];var c=[];for(i in r)i in s||(s[i]=r[i]),c.push(r[i]);var f=[];for(i in s)f.push(s[i]);var v=[vec2.set(vec2.create(),f[0][0]-c[0][0],f[0][1]-c[0][1]),vec2.set(vec2.create(),f[1][0]-c[1][0],f[1][1]-c[1][1])],d=[vec2.create(),vec2.create()];vec2.normalize(d[0],v[0]),vec2.normalize(d[1],v[1]);var _=vec2.set(vec2.create(),c[1][0]-c[0][0],c[1][1]-c[0][1]);vec2.normalize(_,_);var p=vec2.lerp(vec2.create(),v[0],v[1],.5);vec2.normalize(p,p);var m=[vec2.dot(_,d[0]),vec2.dot(_,d[1])],h=[vec2.dot(p,d[0]),vec2.dot(p,d[1])];if(n.pinch&&Math.abs(m[0])>.5&&Math.abs(m[1])>.5&&Math.sign(m[0])!=Math.sign(m[1])){var g=z(c[0],c[1]),y=z(f[0],f[1]);n.pinch(y-g)}else if(n.twoFingerDrag&&Math.abs(h[0])>.5&&Math.abs(h[1])>.5&&Math.sign(h[0])==Math.sign(h[1])){var x=vec2.lerp(vec2.create(),v[0],v[1],.5);x[1]=-x[1],n.twoFingerDrag(x)}}for(u=0;u<e.changedTouches.length;++u)i=e.changedTouches[u],r[i.identifier]=[i.clientX-a.left,i.clientY-a.top]}));var a=function(t){t.preventDefault();for(var e=0;e<t.changedTouches.length;++e){var n=t.changedTouches[e];delete r[n.identifier]}};t.addEventListener("touchcancel",a),t.addEventListener("touchend",a)}}const A={Fuel:"7d87jcsh0qodk78/fuel_64x64x64_uint8.raw",Neghip:"zgocya7h33nltu9/neghip_64x64x64_uint8.raw","Hydrogen Atom":"jwbav8s3wmmxd5x/hydrogen_atom_128x128x128_uint8.raw",Bonsai:"rdnhdxmxtfxe0sa/bonsai_256x256x256_uint8.raw",Foot:"ic0mik3qv4vqacm/foot_256x256x256_uint8.raw",Skull:"5rfjobn0lvb7tmo/skull_256x256x256_uint8.raw",Aneurysm:"3ykigaiym8uiwbp/aneurism_256x256x256_uint8.raw"};function P(t){var e=t.match(/.*\/(\w+)_(\d+)x(\d+)x(\d+)_(\w+)\.*/);return[parseInt(e[2]),parseInt(e[3]),parseInt(e[4])]}function B(t,e){return Math.floor((t+e-1)/e)*e}async function C(t){const e=P(t),n=e[0]*e[1]*e[2];var r=document.getElementById("loadingText"),a=document.getElementById("loadingProgressBar");r.innerHTML="Loading Volume...",a.setAttribute("style","width: 0%");var i="https://www.dl.dropboxusercontent.com/s/"+t+"?dl=1";try{for(var o=(await fetch(i)).body.getReader(),l=0,s=new Uint8Array(n);;){var{done:u,value:c}=await o.read();if(u)break;s.set(c,l);var f=(l+=c.length)/n*100;a.setAttribute("style",`width: ${f.toFixed(2)}%`)}return r.innerHTML="Volume Loaded",e[0]%256!=0?function(t,e){const n=[B(e[0],256),e[1],e[2]];var r=new Uint8Array(n[0]*n[1]*n[2]);const a=e[1]*e[2];for(var i=0;i<a;++i){var o=t.subarray(i*e[0],i*e[0]+e[0]);r.set(o,i*n[0])}return r}(s,e):s}catch(t){console.log(`Error loading volume: ${t}`),r.innerHTML="Error loading volume"}return null}async function I(t,e,n){var r=t.createTexture({size:e,format:"r8unorm",dimension:"3d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),a=t.createBuffer({size:n.length,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(a.getMappedRange()).set(n),a.unmap();var i=t.createCommandEncoder(),o={buffer:a,bytesPerRow:B(e[0],256),rowsPerImage:e[1]},l={texture:r};return i.copyBufferToTexture(o,l,e),t.queue.submit([i.finish()]),await t.queue.onSubmittedWorkDone(),r}(async()=>{if(void 0===navigator.gpu)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var t=await navigator.gpu.requestAdapter();if(!t)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var e=await t.requestDevice(),n=document.getElementById("webgpu-canvas"),a=n.getContext("webgpu"),o=e.createShaderModule({code:"// Reduce clutter/keyboard pain\ntype float2 = vec2<f32>;\ntype float3 = vec3<f32>;\ntype float4 = vec4<f32>;\ntype int2 = vec2<i32>;\ntype int3 = vec3<i32>;\ntype int4 = vec4<i32>;\ntype bool3 = vec3<bool>;\n\nstruct VertexInput {\n    @location(0) position: float3,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: float4,\n    @location(0) transformed_eye: float3,\n    @location(1) ray_dir: float3,\n};\n\nstruct ViewParams {\n    proj_view: mat4x4<f32>,\n    // Not sure on WGSL padding/alignment rules for blocks,\n    // just assume align/pad to vec4\n    eye_pos: float4,\n    //volume_scale: float4;\n    volume_dims: int4,\n    isovalue: f32,\n};\n\nstruct GridIterator {\n    grid_dims: int3,\n    grid_step: int3,\n    t_delta: float3,\n\n    cell: int3,\n    t_max: float3,\n    t: f32,\n};\n\n@group(0) @binding(0)\nvar<uniform> view_params: ViewParams;\n\n@group(0) @binding(1)\nvar volume: texture_3d<f32>;\n\nfn outside_grid(p: int3, grid_dims: int3) -> bool {\n    return any(p < int3(0)) || any(p >= grid_dims);\n}\n\nfn intersect_box(orig: float3, dir: float3, box_min: float3, box_max: float3) -> float2 {\n\tvar inv_dir = 1.0 / dir;\n\tvar tmin_tmp = (box_min - orig) * inv_dir;\n\tvar tmax_tmp = (box_max - orig) * inv_dir;\n\tvar tmin = min(tmin_tmp, tmax_tmp);\n\tvar tmax = max(tmin_tmp, tmax_tmp);\n\tvar t0 = max(tmin.x, max(tmin.y, tmin.z));\n\tvar t1 = min(tmax.x, min(tmax.y, tmax.z));\n\treturn float2(t0, t1);\n}\n\n\n// Initialize the grid traversal state. All positions/directions passed must be in the\n// grid coordinate system where a grid cell is 1^3 in size.\nfn init_grid_iterator(ray_org: float3, ray_dir: float3, t: f32, grid_dims: int3) -> GridIterator {\n    var grid_iter: GridIterator;\n    grid_iter.grid_dims = grid_dims;\n    grid_iter.grid_step = int3(sign(ray_dir));\n\n    let inv_ray_dir = 1.0 / ray_dir;\n    grid_iter.t_delta = abs(inv_ray_dir);\n\n\tvar p = (ray_org + t * ray_dir);\n    p = clamp(p, float3(0), float3(grid_dims - 1));\n    let cell = floor(p);\n    let t_max_neg = (cell - ray_org) * inv_ray_dir;\n    let t_max_pos = (cell + float3(1) - ray_org) * inv_ray_dir;\n\n    // Pick between positive/negative t_max based on the ray sign\n    let is_neg_dir = ray_dir < float3(0);\n    grid_iter.t_max = select(t_max_pos, t_max_neg, is_neg_dir);\n\n    grid_iter.cell = int3(cell);\n\n    grid_iter.t = t;\n\n    return grid_iter;\n}\n\nfn grid_iterator_next_cell(iter: ptr<function, GridIterator>,\n                           cell_t_range: ptr<function, float2>,\n                           cell_id: ptr<function, int3>) -> bool {\n    // Please add arrow operator or something equivalent for it, this is terrible to type\n    // and to read\n    if (outside_grid((*iter).cell, (*iter).grid_dims)) {\n        return false;\n    }\n    // Return the current cell range and ID to the caller\n    (*cell_t_range).x = (*iter).t;\n    (*cell_t_range).y = min((*iter).t_max.x, min((*iter).t_max.y, (*iter).t_max.z));\n    *cell_id = (*iter).cell;\n    if ((*cell_t_range).y < (*cell_t_range).x) {\n       return false;\n    }\n\n    // Move the iterator to the next cell we'll traverse\n    (*iter).t = (*cell_t_range).y;\n    if ((*iter).t == (*iter).t_max.x) {\n        (*iter).cell.x += (*iter).grid_step.x;\n        (*iter).t_max.x += (*iter).t_delta.x;\n    } else if ((*iter).t == (*iter).t_max.y) {\n        (*iter).cell.y += (*iter).grid_step.y;\n        (*iter).t_max.y += (*iter).t_delta.y;\n    } else {\n        (*iter).cell.z += (*iter).grid_step.z;\n        (*iter).t_max.z += (*iter).t_delta.z;\n    }\n    return true;\n}\n\n// Load the vertex values for the dual cell 'cell_id's vertices\n// Vertex values will be returned in the order:\n// [v000, v100, v110, v010, v001, v101, v111, v011]\n// v000 = cell_id\nfn load_dual_cell(cell_id: int3, values: ptr<function, array<f32, 8>>) -> float2 {\n    let index_to_vertex = array<int3, 8>(\n        int3(0, 0, 0), // v000 = 0\n        int3(1, 0, 0), // v100 = 1\n        int3(0, 1, 0), // v010 = 2\n        int3(1, 1, 0), // v110 = 3\n        int3(0, 0, 1), // v001 = 4\n        int3(1, 0, 1), // v101 = 5\n        int3(0, 1, 1), // v011 = 6\n        int3(1, 1, 1)  // v111 = 7\n    );\n\n    var cell_range = float2(1e20f, -1e20f);\n    for (var i = 0; i < 8; i++) { \n        let v = cell_id + index_to_vertex[i];\n        var val = textureLoad(volume, v, 0).r;\n        (*values)[i] = val;\n        cell_range.x = min(cell_range.x, val);\n        cell_range.y = max(cell_range.y, val);\n    }\n    return cell_range;\n}\n\n// Compute the polynomial for the cell with the given vertex values\nfn compute_polynomial(p: float3,\n                      dir: float3,\n                      v000: float3,\n                      values: ptr<function, array<f32, 8>>) -> float4\n{\n    let v111 = v000 + float3(1);\n    // Note: Grid voxels sizes are 1^3\n    let a = array<float3, 2>(v111 - p, p - v000);\n    // Note: The b_0/b_1 equations seem to be flipped in Parker et al. '1998 \n    let b = array<float3, 2>(-dir, dir);\n\n    var poly = float4(0);\n    for (var k = 0; k < 2; k++) {\n        for (var j = 0; j < 2; j++) {\n            for (var i = 0; i < 2; i++) {\n                let val = (*values)[i + 2 * (j + 2 * k)];\n\n                poly.x += b[i].x * b[j].y * b[k].z * val;\n\n                poly.y += (a[i].x * b[j].y * b[k].z +\n                        b[i].x * a[j].y * b[k].z +\n                        b[i].x * b[j].y * a[k].z) * val;\n\n                poly.z += (b[i].x * a[j].y * a[k].z +\n                        a[i].x * b[j].y * a[k].z +\n                        a[i].x * a[j].y * b[k].z) * val;\n\n                poly.w += a[i].x * a[j].y * a[k].z * val;\n            }\n        }\n    }\n    return poly;\n}\n\nfn evaluate_polynomial(poly: float4, t: f32) -> f32 {\n    return poly.x * pow(t, 3.f) + poly.y * pow(t, 2.f) + poly.z * t + poly.w;\n}\n\n// Returns true if the quadratic has real roots\nfn solve_quadratic(poly: float3, roots: ptr<function, array<f32, 2>>) -> bool {\n    // Check for case when poly is just Bt + c = 0\n    if (poly.x == 0) {\n        (*roots)[0] = -poly.z/poly.y;\n        (*roots)[1] = -poly.z/poly.y;\n        return true;\n    }\n    var discriminant = pow(poly.y, 2.f) - 4.f * poly.x * poly.z;\n    if (discriminant < 0.f) {\n        return false;\n    }\n    discriminant = sqrt(discriminant);\n    var r = 0.5f * float2(-poly.y + discriminant, -poly.y - discriminant) / poly.x;\n    (*roots)[0] = min(r.x, r.y);\n    (*roots)[1] = max(r.x, r.y);\n    return true;\n}\n\n// Trilinear interpolation at the given point within the cell with its origin at v000\n// (origin = bottom-left-near point)\nfn trilinear_interpolate_in_cell(p: float3,\n                                 v000: float3,\n                                 values: ptr<function, array<f32, 8>>) -> f32 {\n    let diff = clamp(p, v000, v000 + float3(1.0)) - v000;\n    // Interpolate across x, then y, then z, and return the value normalized between 0 and 1\n    let c00 = (*values)[0] * (1.f - diff.x) + (*values)[1] * diff.x;\n    let c01 = (*values)[4] * (1.f - diff.x) + (*values)[5] * diff.x;\n    let c10 = (*values)[2] * (1.f - diff.x) + (*values)[3] * diff.x;\n    let c11 = (*values)[6] * (1.f - diff.x) + (*values)[7] * diff.x;\n    let c0 = c00 * (1.f - diff.y) + c10 * diff.y;\n    let c1 = c01 * (1.f - diff.y) + c11 * diff.y;\n    return c0 * (1.f - diff.z) + c1 * diff.z;\n}\n\nfn marmitt_intersect(ray_org: float3,\n                     ray_dir: float3,\n                     v000: float3,\n                     values: ptr<function, array<f32, 8>>,\n                     t_prev: f32,\n                     t_next: f32,\n                     t_hit: ptr<function, f32>) -> bool\n{\n    if (t_next <= t_prev) {\n        return false;\n    }\n    // The text seems to not say explicitly, but I think it is required to have\n    // the ray \"origin\" within the cell for the cell-local coordinates for a to\n    // be computed properly. Also because u, v, w have to be in [0, 1], so the points\n    // we're looking at need to be in the cell\n    // So here I set the cell_p to be at the midpoint of the\n    // ray's overlap with the cell, which makes it easy to compute t_in/t_out and\n    // avoid numerical issues with cell_p being right at the edge of the cell.\n    let cell_p = ray_org + ray_dir * (t_prev + (t_next - t_prev) * 0.5f);\n    var t_in = -(t_next - t_prev) * 0.5f * length(ray_dir);\n    var t_out = (t_next - t_prev) * 0.5f * length(ray_dir);\n\n    let cell_ray_dir = normalize(ray_dir);\n\n    var poly = compute_polynomial(cell_p, cell_ray_dir, v000, values);\n    poly.w -= view_params.isovalue;\n\n    var f_in = evaluate_polynomial(poly, t_in);\n    var f_out = evaluate_polynomial(poly, t_out);\n    var roots = array<f32, 2>(0.0, 0.0);\n    if (solve_quadratic(float3(3.f * poly.x, 2.f * poly.y, poly.z), &roots)) {\n        if (roots[0] >= t_in && roots[0] <= t_out) {\n            let f_root0 = evaluate_polynomial(poly, roots[0]);\n            if (sign(f_root0) == sign(f_in)) {\n                t_in = roots[0];\n                f_in = f_root0;\n            } else {\n                t_out = roots[0];\n                f_out = f_root0;\n            }\n        }\n        if (roots[1] >= t_in && roots[1] <= t_out) {\n            let f_root1 = evaluate_polynomial(poly, roots[1]);\n            if (sign(f_root1) == sign(f_in)) {\n                t_in = roots[1];\n                f_in = f_root1;\n            } else {\n                t_out = roots[1];\n                f_out = f_root1;\n            }\n        }\n    }\n    // If the signs aren't equal we know there's an intersection in the cell\n    if (sign(f_in) != sign(f_out)) {\n        // Find the intersection via repeated linear interpolation\n        for (var i = 0; i < 3; i++) {\n            let t = t_in + (t_out - t_in) * (-f_in) / (f_out - f_in);\n            let f_t = evaluate_polynomial(poly, t);\n            if (sign(f_t) == sign(f_in)) {\n                t_in = t;\n                f_in = f_t;\n            } else {\n                t_out = t;\n                f_out = f_t;\n            }\n        }\n        let cell_t_hit = t_in + (t_out - t_in) * (-f_in) / (f_out - f_in);\n        // Return t_hit relative to the ray origin\n        let hit_p = cell_p + cell_ray_dir * cell_t_hit;\n        *t_hit = length(hit_p - ray_org) / length(ray_dir);\n        return true;\n    }\n    return false;\n}\n\nfn compute_gradient(p: float3,\n                    v000: float3,\n                    values: ptr<function, array<f32, 8>>) -> float3 {\n    let v111 = v000 + float3(1);\n    let delta_step = 0.005;\n    let deltas = array<float3, 3>(\n        float3(delta_step, 0.0, 0.0),\n        float3(0.0, delta_step, 0.0),\n        float3(0.0, 0.0, delta_step)\n    );\n    var n = float3(0);\n    // TODO: The clamping is producing at least the artifacts at the cell boundaries,\n    // but it's not too visible. Some of the other kind of \"banding\" might be related\n    // to this as well? Hard to say. Making the delta small also helps reduce the effect,\n    // but also makes the surface appear bumpier since the normal isn't as smooth\n    // Maybe we can use some analytic/derivative based thing here to compute the normal instead?\n    n.x = trilinear_interpolate_in_cell(min(p + deltas[0], v111), v000, values)\n          - trilinear_interpolate_in_cell(max(p - deltas[0], v000), v000, values);\n    n.y = trilinear_interpolate_in_cell(min(p + deltas[1], v111), v000, values)\n          - trilinear_interpolate_in_cell(max(p - deltas[1], v000), v000, values);\n    n.z = trilinear_interpolate_in_cell(min(p + deltas[2], v111), v000, values)\n          - trilinear_interpolate_in_cell(max(p - deltas[2], v000), v000, values);\n    return normalize(n);\n}\n\nfn linear_to_srgb(x: f32) -> f32 {\n\tif (x <= 0.0031308) {\n\t\treturn 12.92 * x;\n\t}\n\treturn 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\n@vertex\nfn vertex_main(vert: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n    var pos = vert.position;\n    out.position = view_params.proj_view * float4(pos, 1.0);\n    out.transformed_eye = view_params.eye_pos.xyz;\n    out.ray_dir = pos - out.transformed_eye;\n    return out;\n};\n\n@fragment\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\n    var ray_dir = normalize(in.ray_dir);\n\n    var t_hit = intersect_box(in.transformed_eye, ray_dir, float3(0.0), float3(1.0));\n    if (t_hit.x > t_hit.y) {\n        discard;\n    }\n    t_hit.x = max(t_hit.x, 0.0);\n\n    // Scale the eye and ray direction from the 1^3 box to the volume grid\n    ray_dir *= float3(view_params.volume_dims.xyz);\n    let ray_org = in.transformed_eye * float3(view_params.volume_dims.xyz) - float3(0.5);\n    let dual_grid_dims = view_params.volume_dims.xyz - int3(1);\n\n    var iter = init_grid_iterator(ray_org, ray_dir, t_hit.x, dual_grid_dims);\n\n    var color = float4(0);\n    var cell_id = int3(0);\n    var cell_t_range = float2(0.0);\n    while (grid_iterator_next_cell(&iter, &cell_t_range, &cell_id)) {\n        var vertex_values: array<f32, 8>;\n        let cell_range = load_dual_cell(cell_id, &vertex_values);\n\n        if (view_params.isovalue >= cell_range.x && view_params.isovalue <= cell_range.y) {\n            var t_hit_iso: f32;\n            let hit = marmitt_intersect(ray_org,\n                                        ray_dir,\n                                        float3(cell_id),\n                                        &vertex_values,\n                                        cell_t_range.x,\n                                        cell_t_range.y,\n                                        &t_hit_iso);\n            if (hit) {\n                let hit_p = ray_org + t_hit_iso * ray_dir;\n\n                var normal = compute_gradient(hit_p, float3(cell_id), &vertex_values);\n                if (dot(ray_dir, normal) > 0.0) {\n                    normal = -normal;\n                }\n\n                // Apply some eye-light shading. h = -ray_dir since the light is coming from the eye\n                let base_color = float3(0.15, 0.15, 0.8);\n                let rd_dot_n = clamp(dot(normalize(-ray_dir), normal), 0.0, 1.0);\n                var color_rgb = 0.2 * base_color;\n                color_rgb += 0.6 * rd_dot_n * base_color;\n                color_rgb += 0.1 * pow(rd_dot_n, 5.0);\n                color = float4(color_rgb, 1.0);\n                break;\n            }\n        }\n    }\n    color.r = linear_to_srgb(color.r);\n    color.g = linear_to_srgb(color.g);\n    color.b = linear_to_srgb(color.b);\n    return color;\n}\n\n"}),l=await o.compilationInfo();if(l.messages.length>0){var s=!1;console.log("Shader compilation log:");for(var u=0;u<l.messages.length;++u){var c=l.messages[u];console.log(`${c.lineNum}:${c.linePos} - ${c.message}`),s=s||"error"==c.type}if(s)return void console.log("Shader failed to compile")}const f=i(r(),.5,.5,2.5),v=i(r(),.5,.5,.5),d=i(r(),0,1,0),_=function(){for(var t=[1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0],e=[],n=0;n<t.length;++n)e.push(n);return{vertices:t,indices:e}}();var p=e.createBuffer({size:4*_.vertices.length,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(p.getMappedRange()).set(_.vertices),p.unmap();var m=e.createBuffer({size:4*_.indices.length,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(m.getMappedRange()).set(_.indices),m.unmap();var g=e.createBuffer({size:112,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),y=document.getElementById("volumeList"),b=document.getElementById("isovalue");b.value=128,function(t,e){for(var n in e){var r=document.createElement("option");r.value=n,r.innerHTML=n,t.appendChild(r)}}(y,A);var w="Bonsai";if(window.location.hash){var z=decodeURI(window.location.hash.substring(1));if(!(z in A))return void alert(`Linked to invalid data set ${z}`);y.value=z,w=z}var B=P(A[w]),k=await C(A[w]).then((t=>I(e,B,t))),E="bgra8unorm";a.configure({device:e,format:E,usage:GPUTextureUsage.OUTPUT_ATTACHMENT,alphaMode:"premultiplied"});var U=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}}]}),S=e.createPipelineLayout({bindGroupLayouts:[U]}),F={module:o,entryPoint:"vertex_main",buffers:[{arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}]},G={module:o,entryPoint:"fragment_main",targets:[{format:E,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},R=e.createRenderPipeline({layout:S,vertex:F,fragment:G,primitive:{topology:"triangle-strip",stripIndexFormat:"uint16",cullMode:"front"}}),q={colorAttachments:[{view:void 0,loadOp:"clear",storeOp:"store",clearValue:[1,1,1,1]}]},D=new M(f,v,d,2,[n.width,n.height]),L=function(t,e,n,r,a){var i,o=1/Math.tan(e/2);return t[0]=o/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=a&&a!==1/0?(i=1/(r-a),t[10]=(a+r)*i,t[14]=2*a*r*i):(t[10]=-1,t[14]=-2*r),t}(h(),50*Math.PI/180,n.width/n.height,.1,100),j=h(),V=new T;V.mousemove=function(t,e,n){1==n.buttons?D.rotate(t,e):2==n.buttons&&D.pan([e[0]-t[0],t[1]-e[1]])},V.wheel=function(t){D.zoom(.1*t)},V.pinch=V.wheel,V.twoFingerDrag=function(t){D.pan(t)},V.registerForCanvas(n);var O=function(){var t=null,e=new Promise((e=>t=e));return window.requestAnimationFrame(t),e};requestAnimationFrame(O);for(var N=[{binding:0,resource:{buffer:g}},{binding:1,resource:k.createView()}],Y=e.createBindGroup({layout:U,entries:N}),X=e.createBuffer({size:112,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1});;)if(await O(),!document.hidden){w!=y.value&&(w=y.value,history.replaceState(history.state,"","#"+w),B=P(A[w]),k=await C(A[w]).then((t=>I(e,B,t))),N[1].resource=k.createView(),Y=e.createBindGroup({layout:U,entries:N})),j=x(j,L,D.camera),await X.mapAsync(GPUMapMode.WRITE);var H=D.eyePos(),$=X.getMappedRange(),W=new Float32Array($),J=new Int32Array($);W.set(j),W.set(H,j.length),J.set(B,j.length+4),W.set([b.value/255],j.length+8),X.unmap();var K=e.createCommandEncoder();K.copyBufferToBuffer(X,0,g,0,112),q.colorAttachments[0].view=a.getCurrentTexture().createView();var Q=K.beginRenderPass(q);Q.setPipeline(R),Q.setBindGroup(0,Y),Q.setVertexBuffer(0,p),Q.setIndexBuffer(m,"uint16"),Q.draw(_.vertices.length/3,1,0,0),Q.end(),e.queue.submit([K.finish()])}})()})();