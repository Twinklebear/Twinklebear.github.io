(()=>{"use strict";var r="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new r(2);return r!=Float32Array&&(t[0]=0,t[1]=0),t}function e(r,t,e){return r[0]=t,r[1]=e,r}function n(){var t=new r(3);return r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function a(t,e,n){var a=new r(3);return a[0]=t,a[1]=e,a[2]=n,a}function i(r,t,e,n){return r[0]=t,r[1]=e,r[2]=n,r}function o(r,t){var e=t[0],n=t[1],a=t[2],i=e*e+n*n+a*a;return i>0&&(i=1/Math.sqrt(i)),r[0]=t[0]*i,r[1]=t[1]*i,r[2]=t[2]*i,r}function l(r,t,e){var n=t[0],a=t[1],i=t[2],o=e[0],l=e[1],s=e[2];return r[0]=a*s-i*l,r[1]=i*o-n*s,r[2]=n*l-a*o,r}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var r=0,t=arguments.length;t--;)r+=arguments[t]*arguments[t];return Math.sqrt(r)}),t();function s(){var t=new r(4);return r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function u(r,t,e,n,a){return r[0]=t,r[1]=e,r[2]=n,r[3]=a,r}function c(r,t){var e=t[0],n=t[1],a=t[2],i=t[3],o=e*e+n*n+a*a+i*i;return o>0&&(o=1/Math.sqrt(o)),r[0]=e*o,r[1]=n*o,r[2]=a*o,r[3]=i*o,r}function f(r,t,e){var n=t[0],a=t[1],i=t[2],o=t[3];return r[0]=e[0]*n+e[4]*a+e[8]*i+e[12]*o,r[1]=e[1]*n+e[5]*a+e[9]*i+e[13]*o,r[2]=e[2]*n+e[6]*a+e[10]*i+e[14]*o,r[3]=e[3]*n+e[7]*a+e[11]*i+e[15]*o,r}function d(){var t=new r(4);return r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}n(),s();var v,_=u,p=function(r,t,e){var n=t[0],a=t[1],i=t[2],o=t[3],l=e[0],s=e[1],u=e[2],c=e[3];return r[0]=n*c+o*l+a*u-i*s,r[1]=a*c+o*s+i*l-n*u,r[2]=i*c+o*u+n*s-a*l,r[3]=o*c-n*l-a*s-i*u,r},m=c;function h(){var t=new r(16);return r!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function g(r,t){var e=t[0],n=t[1],a=t[2],i=t[3],o=t[4],l=t[5],s=t[6],u=t[7],c=t[8],f=t[9],d=t[10],v=t[11],_=t[12],p=t[13],m=t[14],h=t[15],g=e*l-n*o,y=e*s-a*o,x=e*u-i*o,w=n*s-a*l,b=n*u-i*l,M=a*u-i*s,z=c*p-f*_,T=c*m-d*_,A=c*h-v*_,P=f*m-d*p,B=f*h-v*p,C=d*h-v*m,I=g*C-y*B+x*P+w*A-b*T+M*z;return I?(I=1/I,r[0]=(l*C-s*B+u*P)*I,r[1]=(a*B-n*C-i*P)*I,r[2]=(p*M-m*b+h*w)*I,r[3]=(d*b-f*M-v*w)*I,r[4]=(s*A-o*C-u*T)*I,r[5]=(e*C-a*A+i*T)*I,r[6]=(m*x-_*M-h*y)*I,r[7]=(c*M-d*x+v*y)*I,r[8]=(o*B-l*A+u*z)*I,r[9]=(n*A-e*B-i*z)*I,r[10]=(_*b-p*x+h*g)*I,r[11]=(f*x-c*b-v*g)*I,r[12]=(l*T-o*P-s*z)*I,r[13]=(e*P-n*T+a*z)*I,r[14]=(p*y-_*w-m*g)*I,r[15]=(c*w-f*y+d*g)*I,r):null}function y(r,t){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r}n(),a(1,0,0),a(0,1,0),d(),d(),v=new r(9),r!=Float32Array&&(v[1]=0,v[2]=0,v[3]=0,v[5]=0,v[6]=0,v[7]=0),v[0]=1,v[4]=1,v[8]=1;var x=function(r,t,e){var n=t[0],a=t[1],i=t[2],o=t[3],l=t[4],s=t[5],u=t[6],c=t[7],f=t[8],d=t[9],v=t[10],_=t[11],p=t[12],m=t[13],h=t[14],g=t[15],y=e[0],x=e[1],w=e[2],b=e[3];return r[0]=y*n+x*l+w*f+b*p,r[1]=y*a+x*s+w*d+b*m,r[2]=y*i+x*u+w*v+b*h,r[3]=y*o+x*c+w*_+b*g,y=e[4],x=e[5],w=e[6],b=e[7],r[4]=y*n+x*l+w*f+b*p,r[5]=y*a+x*s+w*d+b*m,r[6]=y*i+x*u+w*v+b*h,r[7]=y*o+x*c+w*_+b*g,y=e[8],x=e[9],w=e[10],b=e[11],r[8]=y*n+x*l+w*f+b*p,r[9]=y*a+x*s+w*d+b*m,r[10]=y*i+x*u+w*v+b*h,r[11]=y*o+x*c+w*_+b*g,y=e[12],x=e[13],w=e[14],b=e[15],r[12]=y*n+x*l+w*f+b*p,r[13]=y*a+x*s+w*d+b*m,r[14]=y*i+x*u+w*v+b*h,r[15]=y*o+x*c+w*_+b*g,r};function w(r){var e,n,a=(n=r,(e=r)[0]*n[0]+e[1]*n[1]);if(a<=1)return _(d(),r[0],r[1],Math.sqrt(1-a),0);var i=function(r,t){var e=t[0],n=t[1],a=e*e+n*n;return a>0&&(a=1/Math.sqrt(a)),r[0]=t[0]*a,r[1]=t[1]*a,r}(t(),r);return _(d(),i[0],i[1],0,0)}function b(r,t,e){return r<t?t:r>e?e:r}class M{constructor(t,e,a,s,u){var c=i(n(),t[0],t[1],t[2]),f=i(n(),e[0],e[1],e[2]),v=i(n(),a[0],a[1],a[2]);o(v,v);var _,p,x,w,b=function(r,t,e){return r[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r}(n(),f,c),M=(p=(_=b)[0],x=_[1],w=_[2],Math.hypot(p,x,w));o(b,b);var z=l(n(),b,v);o(z,z);var T=l(n(),z,b);o(T,T),l(z,b,T),o(z,z),this.zoomSpeed=s,this.invScreen=[1/u[0],1/u[1]],this.centerTranslation=y(h(),e),g(this.centerTranslation,this.centerTranslation);var A=i(n(),0,0,-1*M);this.translation=y(h(),A);var P=function(t,e,n,a,i,o,l,s,u){var c=new r(9);return c[0]=t,c[1]=e,c[2]=n,c[3]=a,c[4]=i,c[5]=o,c[6]=l,c[7]=s,c[8]=u,c}(z[0],z[1],z[2],T[0],T[1],T[2],-b[0],-b[1],-b[2]);!function(r,t){if(r===t){var e=t[1],n=t[2],a=t[5];r[1]=t[3],r[2]=t[6],r[3]=e,r[5]=t[7],r[6]=n,r[7]=a}else r[0]=t[0],r[1]=t[3],r[2]=t[6],r[3]=t[1],r[4]=t[4],r[5]=t[7],r[6]=t[2],r[7]=t[5],r[8]=t[8]}(P,P),this.rotation=function(r,t){var e,n=t[0]+t[4]+t[8];if(n>0)e=Math.sqrt(n+1),r[3]=.5*e,e=.5/e,r[0]=(t[5]-t[7])*e,r[1]=(t[6]-t[2])*e,r[2]=(t[1]-t[3])*e;else{var a=0;t[4]>t[0]&&(a=1),t[8]>t[3*a+a]&&(a=2);var i=(a+1)%3,o=(a+2)%3;e=Math.sqrt(t[3*a+a]-t[3*i+i]-t[3*o+o]+1),r[a]=.5*e,e=.5/e,r[3]=(t[3*i+o]-t[3*o+i])*e,r[i]=(t[3*i+a]+t[3*a+i])*e,r[o]=(t[3*o+a]+t[3*a+o])*e}return r}(d(),P),m(this.rotation,this.rotation),this.camera=h(),this.invCamera=h(),this.updateCameraMatrix()}rotate(r,n){var a=e(t(),b(2*r[0]*this.invScreen[0]-1,-1,1),b(1-2*r[1]*this.invScreen[1],-1,1)),i=e(t(),b(2*n[0]*this.invScreen[0]-1,-1,1),b(1-2*n[1]*this.invScreen[1],-1,1)),o=w(a),l=w(i);this.rotation=p(this.rotation,o,this.rotation),this.rotation=p(this.rotation,l,this.rotation),this.updateCameraMatrix()}zoom(r){var t=i(n(),0,0,r*this.invScreen[1]*this.zoomSpeed),e=y(h(),t);this.translation=x(this.translation,e,this.translation),this.translation[14]>=-.2&&(this.translation[14]=-.2),this.updateCameraMatrix()}pan(r){var t=u(s(),r[0]*this.invScreen[0]*Math.abs(this.translation[14]),r[1]*this.invScreen[1]*Math.abs(this.translation[14]),0,0),e=f(s(),t,this.invCamera),n=y(h(),e);this.centerTranslation=x(this.centerTranslation,n,this.centerTranslation),this.updateCameraMatrix()}updateCameraMatrix(){var r=function(r,t){var e=t[0],n=t[1],a=t[2],i=t[3],o=e+e,l=n+n,s=a+a,u=e*o,c=n*o,f=n*l,d=a*o,v=a*l,_=a*s,p=i*o,m=i*l,h=i*s;return r[0]=1-f-_,r[1]=c+h,r[2]=d-m,r[3]=0,r[4]=c-h,r[5]=1-u-_,r[6]=v+p,r[7]=0,r[8]=d+m,r[9]=v-p,r[10]=1-u-f,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}(h(),this.rotation);this.camera=x(this.camera,r,this.centerTranslation),this.camera=x(this.camera,this.translation,this.camera),this.invCamera=g(this.invCamera,this.camera)}eyePos(){return[this.invCamera[12],this.invCamera[13],this.invCamera[14]]}eyeDir(){var r=u(s(),0,0,-1,0);return[(r=c(r=f(r,r,this.invCamera),r))[0],r[1],r[2]]}upDir(){var r=u(s(),0,1,0,0);return[(r=c(r=f(r,r,this.invCamera),r))[0],r[1],r[2]]}}function z(r,t){var e=[t[0]-r[0],t[1]-r[1]];return Math.sqrt(Math.pow(e[0],2)+Math.pow(e[1],2))}class T{constructor(){this.mousemove=null,this.press=null,this.wheel=null,this.twoFingerDrag=null,this.pinch=null}registerForCanvas(r){var t=null,e=this;r.addEventListener("mousemove",(function(n){n.preventDefault();var a=r.getBoundingClientRect(),i=[n.clientX-a.left,n.clientY-a.top];t?e.mousemove&&e.mousemove(t,i,n):t=[n.clientX-a.left,n.clientY-a.top],t=i})),r.addEventListener("mousedown",(function(t){t.preventDefault();var n=r.getBoundingClientRect(),a=[t.clientX-n.left,t.clientY-n.top];e.press&&e.press(a,t)})),r.addEventListener("wheel",(function(r){r.preventDefault(),e.wheel&&e.wheel(-r.deltaY)})),r.oncontextmenu=function(r){r.preventDefault()};var n={};r.addEventListener("touchstart",(function(t){var a=r.getBoundingClientRect();t.preventDefault();for(var i=0;i<t.changedTouches.length;++i){var o=t.changedTouches[i];n[o.identifier]=[o.clientX-a.left,o.clientY-a.top],1==t.changedTouches.length&&e.press&&e.press(n[o.identifier],t)}})),r.addEventListener("touchmove",(function(t){t.preventDefault();var a=r.getBoundingClientRect();if(1==Object.keys(n).length){if(e.mousemove){var i=t.changedTouches[0],o=n[i.identifier],l=[i.clientX-a.left,i.clientY-a.top];t.buttons=1,e.mousemove(o,l,t)}}else{for(var s={},u=0;u<t.changedTouches.length;++u)s[(i=t.changedTouches[u]).identifier]=[i.clientX-a.left,i.clientY-a.top];var c=[];for(i in n)i in s||(s[i]=n[i]),c.push(n[i]);var f=[];for(i in s)f.push(s[i]);var d=[vec2.set(vec2.create(),f[0][0]-c[0][0],f[0][1]-c[0][1]),vec2.set(vec2.create(),f[1][0]-c[1][0],f[1][1]-c[1][1])],v=[vec2.create(),vec2.create()];vec2.normalize(v[0],d[0]),vec2.normalize(v[1],d[1]);var _=vec2.set(vec2.create(),c[1][0]-c[0][0],c[1][1]-c[0][1]);vec2.normalize(_,_);var p=vec2.lerp(vec2.create(),d[0],d[1],.5);vec2.normalize(p,p);var m=[vec2.dot(_,v[0]),vec2.dot(_,v[1])],h=[vec2.dot(p,v[0]),vec2.dot(p,v[1])];if(e.pinch&&Math.abs(m[0])>.5&&Math.abs(m[1])>.5&&Math.sign(m[0])!=Math.sign(m[1])){var g=z(c[0],c[1]),y=z(f[0],f[1]);e.pinch(y-g)}else if(e.twoFingerDrag&&Math.abs(h[0])>.5&&Math.abs(h[1])>.5&&Math.sign(h[0])==Math.sign(h[1])){var x=vec2.lerp(vec2.create(),d[0],d[1],.5);x[1]=-x[1],e.twoFingerDrag(x)}}for(u=0;u<t.changedTouches.length;++u)i=t.changedTouches[u],n[i.identifier]=[i.clientX-a.left,i.clientY-a.top]}));var a=function(r){r.preventDefault();for(var t=0;t<r.changedTouches.length;++t){var e=r.changedTouches[t];delete n[e.identifier]}};r.addEventListener("touchcancel",a),r.addEventListener("touchend",a)}}const A={Fuel:"7d87jcsh0qodk78/fuel_64x64x64_uint8.raw",Neghip:"zgocya7h33nltu9/neghip_64x64x64_uint8.raw","Hydrogen Atom":"jwbav8s3wmmxd5x/hydrogen_atom_128x128x128_uint8.raw",Bonsai:"rdnhdxmxtfxe0sa/bonsai_256x256x256_uint8.raw",Foot:"ic0mik3qv4vqacm/foot_256x256x256_uint8.raw",Skull:"5rfjobn0lvb7tmo/skull_256x256x256_uint8.raw",Aneurysm:"3ykigaiym8uiwbp/aneurism_256x256x256_uint8.raw"};function P(r){var t=r.match(/.*\/(\w+)_(\d+)x(\d+)x(\d+)_(\w+)\.*/);return[parseInt(t[2]),parseInt(t[3]),parseInt(t[4])]}function B(r,t){return Math.floor((r+t-1)/t)*t}async function C(r){const t=P(r),e=t[0]*t[1]*t[2];var n=document.getElementById("loadingText"),a=document.getElementById("loadingProgressBar");n.innerHTML="Loading Volume...",a.setAttribute("style","width: 0%");var i="https://www.dl.dropboxusercontent.com/s/"+r+"?dl=1";try{for(var o=(await fetch(i)).body.getReader(),l=0,s=new Uint8Array(e);;){var{done:u,value:c}=await o.read();if(u)break;s.set(c,l);var f=(l+=c.length)/e*100;a.setAttribute("style",`width: ${f.toFixed(2)}%`)}return n.innerHTML="Volume Loaded",t[0]%256!=0?function(r,t){const e=[B(t[0],256),t[1],t[2]];var n=new Uint8Array(e[0]*e[1]*e[2]);const a=t[1]*t[2];for(var i=0;i<a;++i){var o=r.subarray(i*t[0],i*t[0]+t[0]);n.set(o,i*e[0])}return n}(s,t):s}catch(r){console.log(`Error loading volume: ${r}`),n.innerHTML="Error loading volume"}return null}async function I(r,t,e){var n=r.createTexture({size:t,format:"r8unorm",dimension:"3d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),a=r.createBuffer({size:e.length,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(a.getMappedRange()).set(e),a.unmap();var i=r.createCommandEncoder(),o={buffer:a,bytesPerRow:B(t[0],256),rowsPerImage:t[1]},l={texture:n};return i.copyBufferToTexture(o,l,t),r.queue.submit([i.finish()]),await r.queue.onSubmittedWorkDone(),n}(async()=>{if(void 0===navigator.gpu)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var r=await navigator.gpu.requestAdapter();if(!r)return document.getElementById("webgpu-canvas").setAttribute("style","display:none;"),void document.getElementById("no-webgpu").setAttribute("style","display:block;");var t=await r.requestDevice(),e=document.getElementById("webgpu-canvas"),a=e.getContext("webgpu"),o=t.createShaderModule({code:"// Reduce clutter/keyboard pain\r\ntype float2 = vec2<f32>;\r\ntype float3 = vec3<f32>;\r\ntype float4 = vec4<f32>;\r\ntype int2 = vec2<i32>;\r\ntype int3 = vec3<i32>;\r\ntype int4 = vec4<i32>;\r\ntype bool3 = vec3<bool>;\r\n\r\nstruct VertexInput {\r\n    @location(0) position: float3,\r\n};\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: float4,\r\n    @location(0) transformed_eye: float3,\r\n    @location(1) ray_dir: float3,\r\n};\r\n\r\nstruct ViewParams {\r\n    proj_view: mat4x4<f32>,\r\n    // Not sure on WGSL padding/alignment rules for blocks,\r\n    // just assume align/pad to vec4\r\n    eye_pos: float4,\r\n    //volume_scale: float4;\r\n    volume_dims: int4,\r\n    isovalue: f32,\r\n};\r\n\r\nstruct GridIterator {\r\n    grid_dims: int3,\r\n    grid_step: int3,\r\n    t_delta: float3,\r\n\r\n    cell: int3,\r\n    t_max: float3,\r\n    t: f32,\r\n};\r\n\r\n@group(0) @binding(0)\r\nvar<uniform> view_params: ViewParams;\r\n\r\n@group(0) @binding(1)\r\nvar volume: texture_3d<f32>;\r\n\r\nfn outside_grid(p: int3, grid_dims: int3) -> bool {\r\n    return any(p < int3(0)) || any(p >= grid_dims);\r\n}\r\n\r\nfn intersect_box(orig: float3, dir: float3, box_min: float3, box_max: float3) -> float2 {\r\n\tvar inv_dir = 1.0 / dir;\r\n\tvar tmin_tmp = (box_min - orig) * inv_dir;\r\n\tvar tmax_tmp = (box_max - orig) * inv_dir;\r\n\tvar tmin = min(tmin_tmp, tmax_tmp);\r\n\tvar tmax = max(tmin_tmp, tmax_tmp);\r\n\tvar t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n\tvar t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n\treturn float2(t0, t1);\r\n}\r\n\r\n\r\n// Initialize the grid traversal state. All positions/directions passed must be in the\r\n// grid coordinate system where a grid cell is 1^3 in size.\r\nfn init_grid_iterator(ray_org: float3, ray_dir: float3, t: f32, grid_dims: int3) -> GridIterator {\r\n    var grid_iter: GridIterator;\r\n    grid_iter.grid_dims = grid_dims;\r\n    grid_iter.grid_step = int3(sign(ray_dir));\r\n\r\n    let inv_ray_dir = 1.0 / ray_dir;\r\n    grid_iter.t_delta = abs(inv_ray_dir);\r\n\r\n\tvar p = (ray_org + t * ray_dir);\r\n    p = clamp(p, float3(0), float3(grid_dims - 1));\r\n    let cell = floor(p);\r\n    let t_max_neg = (cell - ray_org) * inv_ray_dir;\r\n    let t_max_pos = (cell + float3(1) - ray_org) * inv_ray_dir;\r\n\r\n    // Pick between positive/negative t_max based on the ray sign\r\n    let is_neg_dir = ray_dir < float3(0);\r\n    grid_iter.t_max = select(t_max_pos, t_max_neg, is_neg_dir);\r\n\r\n    grid_iter.cell = int3(cell);\r\n\r\n    grid_iter.t = t;\r\n\r\n    return grid_iter;\r\n}\r\n\r\nfn grid_iterator_next_cell(iter: ptr<function, GridIterator, read_write>,\r\n                           cell_t_range: ptr<function, float2, read_write>,\r\n                           cell_id: ptr<function, int3, read_write>) -> bool {\r\n    // Please add arrow operator or something equivalent for it, this is terrible to type\r\n    // and to read\r\n    if (outside_grid((*iter).cell, (*iter).grid_dims)) {\r\n        return false;\r\n    }\r\n    // Return the current cell range and ID to the caller\r\n    (*cell_t_range).x = (*iter).t;\r\n    (*cell_t_range).y = min((*iter).t_max.x, min((*iter).t_max.y, (*iter).t_max.z));\r\n    *cell_id = (*iter).cell;\r\n    if ((*cell_t_range).y < (*cell_t_range).x) {\r\n       return false;\r\n    }\r\n\r\n    // Move the iterator to the next cell we'll traverse\r\n    (*iter).t = (*cell_t_range).y;\r\n    if ((*iter).t == (*iter).t_max.x) {\r\n        (*iter).cell.x += (*iter).grid_step.x;\r\n        (*iter).t_max.x += (*iter).t_delta.x;\r\n    } else if ((*iter).t == (*iter).t_max.y) {\r\n        (*iter).cell.y += (*iter).grid_step.y;\r\n        (*iter).t_max.y += (*iter).t_delta.y;\r\n    } else {\r\n        (*iter).cell.z += (*iter).grid_step.z;\r\n        (*iter).t_max.z += (*iter).t_delta.z;\r\n    }\r\n    return true;\r\n}\r\n\r\n// Load the vertex values for the dual cell 'cell_id's vertices\r\n// Vertex values will be returned in the order:\r\n// [v000, v100, v110, v010, v001, v101, v111, v011]\r\n// v000 = cell_id\r\nfn load_dual_cell(cell_id: int3, values: ptr<function, array<f32, 8>, read_write>) -> float2 {\r\n    let index_to_vertex = array<int3, 8>(\r\n        int3(0, 0, 0), // v000 = 0\r\n        int3(1, 0, 0), // v100 = 1\r\n        int3(0, 1, 0), // v010 = 2\r\n        int3(1, 1, 0), // v110 = 3\r\n        int3(0, 0, 1), // v001 = 4\r\n        int3(1, 0, 1), // v101 = 5\r\n        int3(0, 1, 1), // v011 = 6\r\n        int3(1, 1, 1)  // v111 = 7\r\n    );\r\n\r\n    var cell_range = float2(1e20f, -1e20f);\r\n    for (var i = 0; i < 8; i++) { \r\n        let v = cell_id + index_to_vertex[i];\r\n        var val = textureLoad(volume, v, 0).r;\r\n        (*values)[i] = val;\r\n        cell_range.x = min(cell_range.x, val);\r\n        cell_range.y = max(cell_range.y, val);\r\n    }\r\n    return cell_range;\r\n}\r\n\r\n// Compute the polynomial for the cell with the given vertex values\r\nfn compute_polynomial(p: float3,\r\n                      dir: float3,\r\n                      v000: float3,\r\n                      values: ptr<function, array<f32, 8>, read_write>) -> float4\r\n{\r\n    let v111 = v000 + float3(1);\r\n    // Note: Grid voxels sizes are 1^3\r\n    let a = array<float3, 2>(v111 - p, p - v000);\r\n    // Note: The b_0/b_1 equations seem to be flipped in Parker et al. '1998 \r\n    let b = array<float3, 2>(-dir, dir);\r\n\r\n    var poly = float4(0);\r\n    for (var k = 0; k < 2; k++) {\r\n        for (var j = 0; j < 2; j++) {\r\n            for (var i = 0; i < 2; i++) {\r\n                let val = (*values)[i + 2 * (j + 2 * k)];\r\n\r\n                poly.x += b[i].x * b[j].y * b[k].z * val;\r\n\r\n                poly.y += (a[i].x * b[j].y * b[k].z +\r\n                        b[i].x * a[j].y * b[k].z +\r\n                        b[i].x * b[j].y * a[k].z) * val;\r\n\r\n                poly.z += (b[i].x * a[j].y * a[k].z +\r\n                        a[i].x * b[j].y * a[k].z +\r\n                        a[i].x * a[j].y * b[k].z) * val;\r\n\r\n                poly.w += a[i].x * a[j].y * a[k].z * val;\r\n            }\r\n        }\r\n    }\r\n    return poly;\r\n}\r\n\r\nfn evaluate_polynomial(poly: float4, t: f32) -> f32 {\r\n    return poly.x * pow(t, 3.f) + poly.y * pow(t, 2.f) + poly.z * t + poly.w;\r\n}\r\n\r\n// Returns true if the quadratic has real roots\r\nfn solve_quadratic(poly: float3, roots: ptr<function, array<f32, 2>, read_write>) -> bool {\r\n    // Check for case when poly is just Bt + c = 0\r\n    if (poly.x == 0) {\r\n        (*roots)[0] = -poly.z/poly.y;\r\n        (*roots)[1] = -poly.z/poly.y;\r\n        return true;\r\n    }\r\n    var discriminant = pow(poly.y, 2.f) - 4.f * poly.x * poly.z;\r\n    if (discriminant < 0.f) {\r\n        return false;\r\n    }\r\n    discriminant = sqrt(discriminant);\r\n    var r = 0.5f * float2(-poly.y + discriminant, -poly.y - discriminant) / poly.x;\r\n    (*roots)[0] = min(r.x, r.y);\r\n    (*roots)[1] = max(r.x, r.y);\r\n    return true;\r\n}\r\n\r\n// Trilinear interpolation at the given point within the cell with its origin at v000\r\n// (origin = bottom-left-near point)\r\nfn trilinear_interpolate_in_cell(p: float3,\r\n                                 v000: float3,\r\n                                 values: ptr<function, array<f32, 8>, read_write>) -> f32 {\r\n    let diff = clamp(p, v000, v000 + float3(1.0)) - v000;\r\n    // Interpolate across x, then y, then z, and return the value normalized between 0 and 1\r\n    let c00 = (*values)[0] * (1.f - diff.x) + (*values)[1] * diff.x;\r\n    let c01 = (*values)[4] * (1.f - diff.x) + (*values)[5] * diff.x;\r\n    let c10 = (*values)[2] * (1.f - diff.x) + (*values)[3] * diff.x;\r\n    let c11 = (*values)[6] * (1.f - diff.x) + (*values)[7] * diff.x;\r\n    let c0 = c00 * (1.f - diff.y) + c10 * diff.y;\r\n    let c1 = c01 * (1.f - diff.y) + c11 * diff.y;\r\n    return c0 * (1.f - diff.z) + c1 * diff.z;\r\n}\r\n\r\nfn marmitt_intersect(ray_org: float3,\r\n                     ray_dir: float3,\r\n                     v000: float3,\r\n                     values: ptr<function, array<f32, 8>, read_write>,\r\n                     t_prev: f32,\r\n                     t_next: f32,\r\n                     t_hit: ptr<function, f32, read_write>) -> bool\r\n{\r\n    if (t_next <= t_prev) {\r\n        return false;\r\n    }\r\n    // The text seems to not say explicitly, but I think it is required to have\r\n    // the ray \"origin\" within the cell for the cell-local coordinates for a to\r\n    // be computed properly. Also because u, v, w have to be in [0, 1], so the points\r\n    // we're looking at need to be in the cell\r\n    // So here I set the cell_p to be at the midpoint of the\r\n    // ray's overlap with the cell, which makes it easy to compute t_in/t_out and\r\n    // avoid numerical issues with cell_p being right at the edge of the cell.\r\n    let cell_p = ray_org + ray_dir * (t_prev + (t_next - t_prev) * 0.5f);\r\n    var t_in = -(t_next - t_prev) * 0.5f * length(ray_dir);\r\n    var t_out = (t_next - t_prev) * 0.5f * length(ray_dir);\r\n\r\n    let cell_ray_dir = normalize(ray_dir);\r\n\r\n    var poly = compute_polynomial(cell_p, cell_ray_dir, v000, values);\r\n    poly.w -= view_params.isovalue;\r\n\r\n    var f_in = evaluate_polynomial(poly, t_in);\r\n    var f_out = evaluate_polynomial(poly, t_out);\r\n    var roots = array<f32, 2>(0.0, 0.0);\r\n    if (solve_quadratic(float3(3.f * poly.x, 2.f * poly.y, poly.z), &roots)) {\r\n        if (roots[0] >= t_in && roots[0] <= t_out) {\r\n            let f_root0 = evaluate_polynomial(poly, roots[0]);\r\n            if (sign(f_root0) == sign(f_in)) {\r\n                t_in = roots[0];\r\n                f_in = f_root0;\r\n            } else {\r\n                t_out = roots[0];\r\n                f_out = f_root0;\r\n            }\r\n        }\r\n        if (roots[1] >= t_in && roots[1] <= t_out) {\r\n            let f_root1 = evaluate_polynomial(poly, roots[1]);\r\n            if (sign(f_root1) == sign(f_in)) {\r\n                t_in = roots[1];\r\n                f_in = f_root1;\r\n            } else {\r\n                t_out = roots[1];\r\n                f_out = f_root1;\r\n            }\r\n        }\r\n    }\r\n    // If the signs aren't equal we know there's an intersection in the cell\r\n    if (sign(f_in) != sign(f_out)) {\r\n        // Find the intersection via repeated linear interpolation\r\n        for (var i = 0; i < 3; i++) {\r\n            let t = t_in + (t_out - t_in) * (-f_in) / (f_out - f_in);\r\n            let f_t = evaluate_polynomial(poly, t);\r\n            if (sign(f_t) == sign(f_in)) {\r\n                t_in = t;\r\n                f_in = f_t;\r\n            } else {\r\n                t_out = t;\r\n                f_out = f_t;\r\n            }\r\n        }\r\n        let cell_t_hit = t_in + (t_out - t_in) * (-f_in) / (f_out - f_in);\r\n        // Return t_hit relative to the ray origin\r\n        let hit_p = cell_p + cell_ray_dir * cell_t_hit;\r\n        *t_hit = length(hit_p - ray_org) / length(ray_dir);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfn compute_gradient(p: float3,\r\n                    v000: float3,\r\n                    values: ptr<function, array<f32, 8>, read_write>) -> float3 {\r\n    let v111 = v000 + float3(1);\r\n    let delta_step = 0.005;\r\n    let deltas = array<float3, 3>(\r\n        float3(delta_step, 0.0, 0.0),\r\n        float3(0.0, delta_step, 0.0),\r\n        float3(0.0, 0.0, delta_step)\r\n    );\r\n    var n = float3(0);\r\n    // TODO: The clamping is producing at least the artifacts at the cell boundaries,\r\n    // but it's not too visible. Some of the other kind of \"banding\" might be related\r\n    // to this as well? Hard to say. Making the delta small also helps reduce the effect,\r\n    // but also makes the surface appear bumpier since the normal isn't as smooth\r\n    // Maybe we can use some analytic/derivative based thing here to compute the normal instead?\r\n    n.x = trilinear_interpolate_in_cell(min(p + deltas[0], v111), v000, values)\r\n          - trilinear_interpolate_in_cell(max(p - deltas[0], v000), v000, values);\r\n    n.y = trilinear_interpolate_in_cell(min(p + deltas[1], v111), v000, values)\r\n          - trilinear_interpolate_in_cell(max(p - deltas[1], v000), v000, values);\r\n    n.z = trilinear_interpolate_in_cell(min(p + deltas[2], v111), v000, values)\r\n          - trilinear_interpolate_in_cell(max(p - deltas[2], v000), v000, values);\r\n    return normalize(n);\r\n}\r\n\r\nfn linear_to_srgb(x: f32) -> f32 {\r\n\tif (x <= 0.0031308) {\r\n\t\treturn 12.92 * x;\r\n\t}\r\n\treturn 1.055 * pow(x, 1.0 / 2.4) - 0.055;\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vert: VertexInput) -> VertexOutput {\r\n    var out: VertexOutput;\r\n    var pos = vert.position;\r\n    out.position = view_params.proj_view * float4(pos, 1.0);\r\n    out.transformed_eye = view_params.eye_pos.xyz;\r\n    out.ray_dir = pos - out.transformed_eye;\r\n    return out;\r\n};\r\n\r\n@fragment\r\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\r\n    var ray_dir = normalize(in.ray_dir);\r\n\r\n    var t_hit = intersect_box(in.transformed_eye, ray_dir, float3(0.0), float3(1.0));\r\n    if (t_hit.x > t_hit.y) {\r\n        discard;\r\n    }\r\n    t_hit.x = max(t_hit.x, 0.0);\r\n\r\n    // Scale the eye and ray direction from the 1^3 box to the volume grid\r\n    ray_dir *= float3(view_params.volume_dims.xyz);\r\n    let ray_org = in.transformed_eye * float3(view_params.volume_dims.xyz) - float3(0.5);\r\n    let dual_grid_dims = view_params.volume_dims.xyz - int3(1);\r\n\r\n    var iter = init_grid_iterator(ray_org, ray_dir, t_hit.x, dual_grid_dims);\r\n\r\n    var color = float4(0);\r\n    var cell_id = int3(0);\r\n    var cell_t_range = float2(0.0);\r\n    while (grid_iterator_next_cell(&iter, &cell_t_range, &cell_id)) {\r\n        var vertex_values: array<f32, 8>;\r\n        let cell_range = load_dual_cell(cell_id, &vertex_values);\r\n\r\n        if (view_params.isovalue >= cell_range.x && view_params.isovalue <= cell_range.y) {\r\n            var t_hit_iso: f32;\r\n            let hit = marmitt_intersect(ray_org,\r\n                                        ray_dir,\r\n                                        float3(cell_id),\r\n                                        &vertex_values,\r\n                                        cell_t_range.x,\r\n                                        cell_t_range.y,\r\n                                        &t_hit_iso);\r\n            if (hit) {\r\n                let hit_p = ray_org + t_hit_iso * ray_dir;\r\n\r\n                var normal = compute_gradient(hit_p, float3(cell_id), &vertex_values);\r\n                if (dot(ray_dir, normal) > 0.0) {\r\n                    normal = -normal;\r\n                }\r\n\r\n                // Apply some eye-light shading. h = -ray_dir since the light is coming from the eye\r\n                let base_color = float3(0.15, 0.15, 0.8);\r\n                let rd_dot_n = clamp(dot(normalize(-ray_dir), normal), 0.0, 1.0);\r\n                var color_rgb = 0.2 * base_color;\r\n                color_rgb += 0.6 * rd_dot_n * base_color;\r\n                color_rgb += 0.1 * pow(rd_dot_n, 5.0);\r\n                color = float4(color_rgb, 1.0);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    color.r = linear_to_srgb(color.r);\r\n    color.g = linear_to_srgb(color.g);\r\n    color.b = linear_to_srgb(color.b);\r\n    return color;\r\n}\r\n\r\n"}),l=await o.compilationInfo();if(l.messages.length>0){var s=!1;console.log("Shader compilation log:");for(var u=0;u<l.messages.length;++u){var c=l.messages[u];console.log(`${c.lineNum}:${c.linePos} - ${c.message}`),s=s||"error"==c.type}if(s)return void console.log("Shader failed to compile")}const f=i(n(),.5,.5,2.5),d=i(n(),.5,.5,.5),v=i(n(),0,1,0),_=function(){for(var r=[1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0],t=[],e=0;e<r.length;++e)t.push(e);return{vertices:r,indices:t}}();var p=t.createBuffer({size:4*_.vertices.length,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(p.getMappedRange()).set(_.vertices),p.unmap();var m=t.createBuffer({size:4*_.indices.length,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(m.getMappedRange()).set(_.indices),m.unmap();var g=t.createBuffer({size:100,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),y=document.getElementById("volumeList"),w=document.getElementById("isovalue");w.value=128,function(r,t){for(var e in t){var n=document.createElement("option");n.value=e,n.innerHTML=e,r.appendChild(n)}}(y,A);var b="Bonsai";if(window.location.hash){var z=decodeURI(window.location.hash.substring(1));if(!(z in A))return void alert(`Linked to invalid data set ${z}`);y.value=z,b=z}var B=P(A[b]),k=await C(A[b]).then((r=>I(t,B,r))),E="bgra8unorm";a.configure({device:t,format:E,usage:GPUTextureUsage.OUTPUT_ATTACHMENT,alphaMode:"premultiplied"});var U=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"3d"}}]}),S=t.createPipelineLayout({bindGroupLayouts:[U]}),F={module:o,entryPoint:"vertex_main",buffers:[{arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}]},G={module:o,entryPoint:"fragment_main",targets:[{format:E,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]},R=t.createRenderPipeline({layout:S,vertex:F,fragment:G,primitive:{topology:"triangle-strip",stripIndexFormat:"uint16",cullMode:"front"}}),q={colorAttachments:[{view:void 0,loadOp:"clear",storeOp:"store",clearValue:[.3,.3,.3,1]}]},D=new M(f,d,v,2,[e.width,e.height]),L=function(r,t,e,n,a){var i,o=1/Math.tan(t/2);return r[0]=o/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,null!=a&&a!==1/0?(i=1/(n-a),r[10]=(a+n)*i,r[14]=2*a*n*i):(r[10]=-1,r[14]=-2*n),r}(h(),50*Math.PI/180,e.width/e.height,.1,100),j=h(),V=new T;V.mousemove=function(r,t,e){1==e.buttons?D.rotate(r,t):2==e.buttons&&D.pan([t[0]-r[0],r[1]-t[1]])},V.wheel=function(r){D.zoom(.1*r)},V.pinch=V.wheel,V.twoFingerDrag=function(r){D.pan(r)},V.registerForCanvas(e);var O=function(){var r=null,t=new Promise((t=>r=t));return window.requestAnimationFrame(r),t};requestAnimationFrame(O);for(var N=[{binding:0,resource:{buffer:g}},{binding:1,resource:k.createView()}],Y=t.createBindGroup({layout:U,entries:N}),X=t.createBuffer({size:100,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!1});;)if(await O(),!document.hidden){b!=y.value&&(b=y.value,history.replaceState(history.state,"","#"+b),B=P(A[b]),k=await C(A[b]).then((r=>I(t,B,r))),N[1].resource=k.createView(),Y=t.createBindGroup({layout:U,entries:N})),j=x(j,L,D.camera),await X.mapAsync(GPUMapMode.WRITE);var H=D.eyePos(),$=X.getMappedRange(),W=new Float32Array($),J=new Int32Array($);W.set(j),W.set(H,j.length),J.set(B,j.length+4),W.set([w.value/255],j.length+8),X.unmap();var K=t.createCommandEncoder();K.copyBufferToBuffer(X,0,g,0,100),q.colorAttachments[0].view=a.getCurrentTexture().createView();var Q=K.beginRenderPass(q);Q.setPipeline(R),Q.setBindGroup(0,Y),Q.setVertexBuffer(0,p),Q.setIndexBuffer(m,"uint16"),Q.draw(_.vertices.length/3,1,0,0),Q.end(),t.queue.submit([K.finish()])}})()})();