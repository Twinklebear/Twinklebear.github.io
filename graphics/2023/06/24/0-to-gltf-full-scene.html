

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="origin-trial" content="AoMftca5+Dstn4K7mCd1AKVcenGb0/EBkqJgonux6w6fVXhyJ2iHs9LuZKA36+gcaypMdBLAaIpkES6VMXoJtg8AAABQeyJvcmlnaW4iOiJodHRwczovL3d3dy53aWxsdXNoZXIuaW86NDQzIiwiZmVhdHVyZSI6IldlYkdQVSIsImV4cGlyeSI6MTY0MzE1NTE5OX0=">

	<title>From 0 to glTF with WebGPU: Rendering the Full glTF Scene</title>
	
		<meta name="description" content="">
	
    <meta name="author" content="Will Usher">

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

	<!-- Should I be including font-awesome from bootstrap? Or just the 5.0 version? -->
    <!--<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>-->
    <script defer src="https://kit.fontawesome.com/b56adde3a3.js" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>

	<link href="/assets/molokai.css" rel="stylesheet">
	<link href="/assets/custom.css" rel="stylesheet">
	<link rel="shortcut icon" href="/assets/img/identicon.ico">

</head>
<body>
	<nav class="navbar navbar-expand-md navbar-dark bg-dark static-top">
		<div class="container">
			<a class="navbar-brand" href="/">Will Usher</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
				data-target="#navbar_responsive" aria-controls="navbarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbar_responsive">
				<ul class="navbar-nav mr-auto">
				
				
				  
					
					  
					  
						<li class="nav-item"><a href="/projects" class="nav-link">
							Projects</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/blog" class="nav-link">
							Blog</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/pages/sdl2" class="nav-link">
							SDL2 Tutorials</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/news" class="nav-link">
							News</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/archive" class="nav-link">
							Archive</a></li>
						
					  
					
				  
				</ul>
			</div><!-- nav.collaps -->
		</div>
	</nav>

	<div class="container content mb-4">
		

<h1 class="display-4">From 0 to glTF with WebGPU: Rendering the Full glTF Scene</h1>

<div class="row justify-content-center">
	<div class="col-9">
        <p>June 24, 2023</p>
		
<figure>
  <img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/broken-to-fixed-engine.webp" />
  
  <figcaption><b>Figure 1:</b>
  <i>In this post, we'll look at how to fix our terribly broken 2 Cylinder Engine.
  Left: A buggy render of 2CylinderEngine.glb achieved when ignoring the glTF node transformations.
  Right: The correct rendering with meshes positioned based on the hierarchy of transforms
  specified in the glTF node tree.
  </i></figcaption>
</figure>

<p>Loading and drawing our first mesh from a glTF file was quite a bit of work in the <a href="https://www.willusher.io/graphics/2023/05/16/0-to-gltf-first-mesh">previous post</a>, but with this core piece in place we can start adding a lot more functionality to our renderer pretty quickly. If you tried loading up glTF files into the renderer from the previous post, you may have noticed that they didn’t look how you expected. This is because glTF files often contain many meshes that make up different parts of the scene geometry, most of which will be missing since we only loaded the first mesh last time. If we just add a simple loop through the meshes to load and draw them all we’ll frequently end up with a scene like the broken engine on the left in the image above. This is because the meshes are reference and transformed by the glTF node hierarchy, and we need to load and handle these nested transformations to render the correct scene shown on the right. The test model we’ll be using for this post is the <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/2CylinderEngine">2CylinderEngine</a> from the Khronos glTF samples repo, which has nested transformations in its node hierarchy that make it a great test case. So grab <a href="https://github.com/KhronosGroup/glTF-Sample-Models/raw/master/2.0/2CylinderEngine/glTF-Binary/2CylinderEngine.glb">2CylinderEngine.glb</a> and let’s get started!</p>

<!--more-->

<h1 id="gltf-scenes-and-nodes">glTF Scenes and Nodes</h1>

<p>The next step up the glTF concepts hierarchy are nodes and scenes (see <a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">glTF 2.0 cheat sheet</a>). A glTF file can contain multiple scenes, each of which references a tree of nodes specifying the  hierarchy of objects in the scene. Each node may specify a transform, a list of child nodes, and a mesh or camera. A node’s transform is specified relative to its parent node, defining a hierarchy of transformations in the tree, allowing sharing transform data across groups of objects. Each glTF file can contain multiple scenes and can specify a default scene that should be rendered. A file with two scenes and their node trees is illustrated below, with the matching JSON following it.</p>

<figure>
  <img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-2-scenes-hierarchy.webp" />
  
  <figcaption><b>Figure 2:</b>
  <i>A sketch of a simple glTF file with two scenes. Scene 0 containes 4 nodes in total,
  nodes 3 and 4 are children or node 0 and thus should be positioned relative to node 0's transform.
    </i></figcaption>
</figure>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"scene"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"scenes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"nodes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"nodes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"nodes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"children"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w">
      </span><span class="nl">"matrix"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">...</span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"translation"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">...</span><span class="p">],</span><span class="w">
      </span><span class="nl">"rotation"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">...</span><span class="p">],</span><span class="w">
      </span><span class="nl">"scale"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">...</span><span class="p">],</span><span class="w">
      </span><span class="nl">"mesh"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"mesh"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"mesh"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"matrix"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">...</span><span class="p">],</span><span class="w">
      </span><span class="nl">"mesh"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w"> 
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h1 id="flattening-gltf-node-transforms">Flattening glTF Node Transforms</h1>

<p>The nodes in the scene define a tree which has a hierarchy of transformations that must be applied down the tree to correctly position the scene geometry. While Figure 1 left showed the result if we simply loaded all meshes and ignore the node data, another error would be to just load the nodes individually and ignore the hierarchy of transformations. This would give us a buggy scene like shown below for the 2CylinderEngine.</p>

<figure>
  <img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/transforms-not-apply-parent.webp" />
  
  <figcaption><b>Figure 3:</b>
  <i>Another buggy rendering of the 2CylinderEngine. This bug is achieved by applying
  the individual node transforms without taking into account the full transform hierarchy
  defined by the node tree. I.e., by only applying each individual node's transform to its mesh
  and not including the node's parent's transform.
    </i></figcaption>
</figure>

<p>To correctly position each mesh node, we must apply the transformations in order from the root of the tree down to the node referencing a given mesh. However, glTF node trees can be deep, with multiple nested transformations. Storing and traversing the tree each time we render a mesh would require a large amount of storage and complex logic in the shader. A common approach is to instead flatten out the tree, computing the final node to world transform matrix for each mesh node that we can then pass to our vertex shader. This process is illustrated below to compute the transform matrix for node 3’s mesh in our example scene 0. Child node transforms are multiplied on from the right to apply the transformation hierarchy in order from the bottom to top, as each child node’s transform is relative to its parent.</p>

<figure>
  <img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-depth-first-traversal.webp" />
  
  <figcaption><b>Figure 4:</b>
  <i>Depth first traversal of Scene 0's node tree to compute final transformation
  matrices for each node.
    </i></figcaption>
</figure>

<p>This process of traversing the tree and flattening out the transformations amounts to a depth-first traversal of the node tree. We can implement this process as a recursive depth-first tree traversal where we return a simple list of the flattened nodes. Our function will take as input a node tree and produce a flattened list of nodes each with its final node to world transform, as illustrated below. The final matrix for each node is labeled in the output, showing the set of matrices that were combined to compute it during the traversal.</p>

<figure>
  <img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-flatten-tree-output.webp" />
  
  <figcaption><b>Figure 5:</b>
  <i>An illustration of `flattenTree`'s depth first traversal and output. Node 0's
  transform is applied to its children to produce a flattened list of nodes where
  each node stores its final node to world transform that can be passed directly to the shader.
    </i></figcaption>
</figure>

<p>We implement this as the recursive <code class="language-plaintext highlighter-rouge">flattenTree</code> (<a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/4-full-scene/src/glb.js#L412-L432">code</a>) function shown below. This function performs a depth-first traversal of the tree to output a flat list of nodes with the correct world-space transforms. Given the list of all nodes in the file, the current node being processed and its parent’s transform we perform the following:</p>

<ul>
  <li>First, we combine this node’s transform with its parent to compute its flattened transform</li>
  <li>Next, we create a new glTF node from the input node that now uses this flattened transform and that specifies no children. This node is appended to the output flat node list.</li>
  <li>Finally, we recursively call <code class="language-plaintext highlighter-rouge">flattenTree</code> on this nodes children, passing the current node’s flattened transform as the new parent transform. The returned nodes from the children are appended to the flattened node list, which we return at the end.</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Flatten the glTF node tree to flatten the hierarchical transforms</span>
<span class="c1">// The root node is included in the flattened tree</span>
<span class="kd">function</span> <span class="nf">flattenTree</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">parent_transform</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">flattened</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">tfm</span> <span class="o">=</span> <span class="nf">readNodeTransform</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">tfm</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nf">mul</span><span class="p">(</span><span class="nx">tfm</span><span class="p">,</span> <span class="nx">parent_transform</span><span class="p">,</span> <span class="nx">tfm</span><span class="p">);</span>

    <span class="c1">// Add the flattened current node</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">matrix</span><span class="p">:</span> <span class="nx">tfm</span><span class="p">,</span>
        <span class="na">mesh</span><span class="p">:</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">mesh</span><span class="dl">"</span><span class="p">],</span>
        <span class="na">camera</span><span class="p">:</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">camera</span><span class="dl">"</span><span class="p">],</span>
    <span class="p">};</span>
    <span class="nx">flattened</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>

    <span class="c1">// Loop through the node's children and recursively flatten them as well</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">children</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">children</span><span class="dl">"</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">flattened</span><span class="p">.</span><span class="nf">push</span><span class="p">(...</span><span class="nf">flattenTree</span><span class="p">(</span><span class="nx">allNodes</span><span class="p">,</span>
                                          <span class="nx">allNodes</span><span class="p">[</span><span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">children</span><span class="dl">"</span><span class="p">][</span><span class="nx">i</span><span class="p">]],</span>
                                          <span class="nx">tfm</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">flattened</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To read a node’s transform we write another function, <code class="language-plaintext highlighter-rouge">readNodeTransform</code>. A glTF node’s transform can either be specified through a column major matrix or a rotation quaternion, translation, and scale. We’re using using the <a href="https://glmatrix.net/">glMatrix library</a> for matrix math operations here.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">readNodeTransform</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">matrix</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">matrix</span><span class="dl">"</span><span class="p">];</span>
        <span class="c1">// Both glTF and gl matrix are column major</span>
        <span class="k">return</span> <span class="nx">mat4</span><span class="p">.</span><span class="nf">fromValues</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span>
            <span class="nx">m</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kd">var</span> <span class="nx">rotation</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kd">var</span> <span class="nx">translation</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">scale</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">scale</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">scale</span><span class="dl">"</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">rotation</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">rotation</span><span class="dl">"</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">translation</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">translation</span> <span class="o">=</span> <span class="nx">node</span><span class="p">[</span><span class="dl">"</span><span class="s2">translation</span><span class="dl">"</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nf">create</span><span class="p">();</span>
        <span class="k">return</span> <span class="nx">mat4</span><span class="p">.</span><span class="nf">fromRotationTranslationScale</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">rotation</span><span class="p">,</span> <span class="nx">translation</span><span class="p">,</span> <span class="nx">scale</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="loading-the-default-scene">Loading the Default Scene</h1>

<p>We’ll introduce two new classes, <code class="language-plaintext highlighter-rouge">GLTFScene</code> and <code class="language-plaintext highlighter-rouge">GLTFNode</code> to represent glTF scene and node objects respectively. The <code class="language-plaintext highlighter-rouge">GLTFScene</code> simply takes a flattened list of nodes that make up the scene. The nodes are expected to have been flattened by calling <code class="language-plaintext highlighter-rouge">flattenTree</code></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">GLTFScene</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">nodes</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">nodes</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span> <span class="nx">shaderModule</span><span class="p">,</span> <span class="nx">colorFormat</span><span class="p">,</span> <span class="nx">depthFormat</span><span class="p">,</span> <span class="nx">uniformsBGLayout</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Covered in the next section</span>
  <span class="p">}</span>

  <span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Covered in the next section</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">GLTFNode</code> takes the node name, transform, and mesh.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">GLTFNode</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">mesh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">mesh</span> <span class="o">=</span> <span class="nx">mesh</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span> <span class="nx">shaderModule</span><span class="p">,</span> <span class="nx">colorFormat</span><span class="p">,</span> <span class="nx">depthFormat</span><span class="p">,</span> <span class="nx">uniformsBGLayout</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Covered in the next section</span>
  <span class="p">}</span>

  <span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Covered in the next section</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now at the end of <code class="language-plaintext highlighter-rouge">uploadGLB</code> from the previous post, we can get the default scene’s list of nodes and loop through them to flatten out each subtree and build the list of <code class="language-plaintext highlighter-rouge">GLTFNode</code> objects defining the scene. This code is placed after the buffer view upload step (<a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/4-full-scene/src/glb.js#L577-L601">code</a>). Our code now returns a <code class="language-plaintext highlighter-rouge">GLTFScene</code>, however the scene provides the same interface as the <code class="language-plaintext highlighter-rouge">GLBMesh</code> so we don’t need to update our application code.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// After the buffer view upload step in uploadGLB</span>

<span class="c1">// Build the default GLTFScene, we just take all the mesh nodes for now</span>
<span class="kd">var</span> <span class="nx">defaultSceneNodes</span> <span class="o">=</span> <span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">scenes</span><span class="dl">"</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="dl">"</span><span class="s2">nodes</span><span class="dl">"</span><span class="p">];</span>
<span class="c1">// If we have a default scene, load it, otherwise we use the first scene</span>
<span class="k">if </span><span class="p">(</span><span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">scenes</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">defaultSceneNodes</span> <span class="o">=</span> <span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">scenes</span><span class="dl">"</span><span class="p">][</span><span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">scene</span><span class="dl">"</span><span class="p">]][</span><span class="dl">"</span><span class="s2">nodes</span><span class="dl">"</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">defaultNodes</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">defaultSceneNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get each node referenced by the scene and flatten it and its children</span>
  <span class="c1">// out to a single-level scene so that we don't need to keep track of nested</span>
  <span class="c1">// transforms in the renderer</span>
  <span class="c1">// We'll need to put a bit more thought here when we start handling animated nodes</span>
  <span class="c1">// in the hierarchy. For now this is fine.</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">nodes</span><span class="dl">"</span><span class="p">][</span><span class="nx">defaultSceneNodes</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
  <span class="kd">var</span> <span class="nx">nodeTransform</span> <span class="o">=</span> <span class="nf">readNodeTransform</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">flattenedNodes</span> <span class="o">=</span> <span class="nf">flattenTree</span><span class="p">(</span><span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">nodes</span><span class="dl">"</span><span class="p">],</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">nodeTransform</span><span class="p">);</span>

  <span class="c1">// Add all the mesh nodes in the flattened node list to the scene's default nodes</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">flattenedNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="nx">flattenedNodes</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">fn</span><span class="p">[</span><span class="dl">"</span><span class="s2">mesh</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">defaultNodes</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="k">new</span> <span class="nc">GLTFNode</span><span class="p">(</span><span class="nx">n</span><span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">],</span> <span class="nx">fn</span><span class="p">[</span><span class="dl">"</span><span class="s2">matrix</span><span class="dl">"</span><span class="p">],</span> <span class="nx">meshes</span><span class="p">[</span><span class="nx">fn</span><span class="p">[</span><span class="dl">"</span><span class="s2">mesh</span><span class="dl">"</span><span class="p">]]));</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">loading-text</span><span class="dl">"</span><span class="p">).</span><span class="nx">hidden</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="k">return</span> <span class="k">new</span> <span class="nc">GLTFScene</span><span class="p">(</span><span class="nx">defaultNodes</span><span class="p">);</span>
</code></pre></div></div>

<h1 id="drawing-gltf-scenes-and-nodes">Drawing glTF Scenes and Nodes</h1>

<p>Now that we’ve loaded up our full scene, lets fill out the <code class="language-plaintext highlighter-rouge">buildRenderPipeline</code> and <code class="language-plaintext highlighter-rouge">render</code> methods, and update our shaders to get it rendered!</p>

<h2 id="drawing-a-gltfscene">Drawing a GLTFScene</h2>

<p>The <code class="language-plaintext highlighter-rouge">GLTFScene</code> (<a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/4-full-scene/src/glb.js#L391">code</a>) is the entry point to dispatch <code class="language-plaintext highlighter-rouge">buildRenderPipeline</code> and <code class="language-plaintext highlighter-rouge">render</code> to the <code class="language-plaintext highlighter-rouge">GLTFNodes</code>. In <code class="language-plaintext highlighter-rouge">buildRenderPipeline</code> the scene just calls down to each of its nodes, but in <code class="language-plaintext highlighter-rouge">render</code> we can lift binding the view params bind group up, so that each mesh primitive no longer makes this redundant call.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">GLTFScene</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">nodes</span><span class="p">)</span> <span class="p">{...}</span>

  <span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                      <span class="nx">shaderModule</span><span class="p">,</span>
                      <span class="nx">colorFormat</span><span class="p">,</span>
                      <span class="nx">depthFormat</span><span class="p">,</span>
                      <span class="nx">uniformsBGLayout</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                                        <span class="nx">shaderModule</span><span class="p">,</span>
                                        <span class="nx">colorFormat</span><span class="p">,</span>
                                        <span class="nx">depthFormat</span><span class="p">,</span>
                                        <span class="nx">uniformsBGLayout</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Setting bind group 0 containing the view params is shared by all</span>
    <span class="c1">// Nodes, Meshes, Primitives, so we can simply lift the call up here</span>
    <span class="c1">// and remove it from GLTFPrimitive.render</span>
    <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nf">setBindGroup</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">);</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="drawing-a-gltfnode">Drawing a GLTFNode</h2>

<p>The <code class="language-plaintext highlighter-rouge">GLTFNode</code> (<a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/4-full-scene/src/glb.js#L352">code</a>) is responsible for passing the transform to be applied to the mesh being rendered. As mentioned previously, this will be passed through a new uniform buffer. We’ll introduce a new bind group to hold the node parameters, which for now is just the transformation matrix. In <code class="language-plaintext highlighter-rouge">buildRenderPipeline</code> the <code class="language-plaintext highlighter-rouge">GLTFNode</code> creates and uploads the node transform and creates a new bind group referencing it. The bind group layout is passed on to the <code class="language-plaintext highlighter-rouge">GLTFMesh</code> and <code class="language-plaintext highlighter-rouge">GLTFPrimitive</code>, which we modify to take this new parameter and pass it to the pipeline layout creation call.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">GLTFNode</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">mesh</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">mesh</span> <span class="o">=</span> <span class="nx">mesh</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span> <span class="nx">shaderModule</span><span class="p">,</span> <span class="nx">colorFormat</span><span class="p">,</span> <span class="nx">depthFormat</span><span class="p">,</span> <span class="nx">uniformsBGLayout</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Upload the node transform</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">nodeParamsBuf</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nf">createBuffer</span><span class="p">({</span>
      <span class="na">size</span><span class="p">:</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
      <span class="na">usage</span><span class="p">:</span> <span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">UNIFORM</span> <span class="o">|</span> <span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_DST</span><span class="p">,</span>
      <span class="na">mappedAtCreation</span><span class="p">:</span> <span class="kc">true</span>
    <span class="p">});</span>
    <span class="k">new</span> <span class="nc">Float32Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">nodeParamsBuf</span><span class="p">.</span><span class="nf">getMappedRange</span><span class="p">()).</span><span class="nf">set</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">nodeParamsBuf</span><span class="p">.</span><span class="nf">unmap</span><span class="p">();</span>

    <span class="kd">var</span> <span class="nx">bindGroupLayout</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nf">createBindGroupLayout</span><span class="p">({</span>
      <span class="na">entries</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">binding</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="na">visibility</span><span class="p">:</span> <span class="nx">GPUShaderStage</span><span class="p">.</span><span class="nx">VERTEX</span><span class="p">,</span>
        <span class="na">buffer</span><span class="p">:</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uniform</span><span class="dl">"</span><span class="p">}}]</span>
    <span class="p">});</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">nodeParamsBG</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nf">createBindGroup</span><span class="p">({</span>
      <span class="na">layout</span><span class="p">:</span> <span class="nx">bindGroupLayout</span><span class="p">,</span>
      <span class="na">entries</span><span class="p">:</span> <span class="p">[{</span><span class="na">binding</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">resource</span><span class="p">:</span> <span class="p">{</span><span class="na">buffer</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">nodeParamsBuf</span><span class="p">}}]</span>
    <span class="p">});</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">mesh</span><span class="p">.</span><span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                                  <span class="nx">shaderModule</span><span class="p">,</span>
                                  <span class="nx">colorFormat</span><span class="p">,</span>
                                  <span class="nx">depthFormat</span><span class="p">,</span>
                                  <span class="nx">uniformsBGLayout</span><span class="p">,</span>
                                  <span class="nx">bindGroupLayout</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Bind the node parameters bind group containing the node transform</span>
    <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nf">setBindGroup</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">nodeParamsBG</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">mesh</span><span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="updating-gltfmesh-and-gltfprimitive">Updating GLTFMesh and GLTFPrimitive</h2>

<p>Next, we need to update the <code class="language-plaintext highlighter-rouge">GLTFMesh.buildRenderPipeline</code> call to take the new node parameters bind group layout parameter and pass this through to its <code class="language-plaintext highlighter-rouge">GLTFPrimitives</code></p>

<p>This change is straightforward for the <code class="language-plaintext highlighter-rouge">GLTFMesh</code></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">GLTFMesh</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">primitives</span><span class="p">)</span> <span class="p">{...}</span>

  <span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                      <span class="nx">shaderModule</span><span class="p">,</span>
                      <span class="nx">colorFormat</span><span class="p">,</span>
                      <span class="nx">depthFormat</span><span class="p">,</span>
                      <span class="nx">uniformsBGLayout</span><span class="p">,</span>
                      <span class="nx">nodeParamsBGLayout</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Only change: take the nodeParamsBGLayout and pass it down to our</span>
    <span class="c1">// primitives to use in building their pipeline layout</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                                             <span class="nx">shaderModule</span><span class="p">,</span>
                                             <span class="nx">colorFormat</span><span class="p">,</span>
                                             <span class="nx">depthFormat</span><span class="p">,</span>
                                             <span class="nx">uniformsBGLayout</span><span class="p">,</span>
                                             <span class="nx">nodeParamsBGLayout</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// No longer need to take and pass the view params bind group</span>
  <span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, at the <code class="language-plaintext highlighter-rouge">GLTFPrimitive</code> we take the nodeParamsBGLayout and include it in our pipeline layout</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nc">GLTFPrimitive</span> <span class="p">{</span>
  <span class="nf">constructor</span><span class="p">(</span><span class="nx">positions</span><span class="p">,</span> <span class="nx">indices</span><span class="p">,</span> <span class="nx">topology</span><span class="p">)</span> <span class="p">{...}</span>

  <span class="nf">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                      <span class="nx">shaderModule</span><span class="p">,</span>
                      <span class="nx">colorFormat</span><span class="p">,</span>
                      <span class="nx">depthFormat</span><span class="p">,</span>
                      <span class="nx">uniformsBGLayout</span><span class="p">,</span>
                      <span class="nx">nodeParamsBGLayout</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Vertex attribute state and shader stage</span>
    <span class="kd">var</span> <span class="nx">vertexState</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// Same as before</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">fragmentState</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// Same as before</span>
    <span class="p">};</span>

    <span class="c1">// Same as before, topology setup</span>
    <span class="kd">var</span> <span class="nx">primitive</span> <span class="o">=</span> <span class="p">{</span><span class="na">topology</span><span class="p">:</span> <span class="dl">"</span><span class="s2">triangle-list</span><span class="dl">"</span><span class="p">};</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">topology</span> <span class="o">==</span> <span class="nx">GLTFRenderMode</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">primitive</span><span class="p">.</span><span class="nx">topology</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">triangle-strip</span><span class="dl">"</span><span class="p">;</span>
      <span class="nx">primitive</span><span class="p">.</span><span class="nx">stripIndexFormat</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">vertexType</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">layout</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nf">createPipelineLayout</span><span class="p">({</span>
      <span class="c1">// New: Pass the nodeParamsBGLayout as another bind group layout</span>
      <span class="c1">// in our pipeline</span>
      <span class="na">bindGroupLayouts</span><span class="p">:</span> <span class="p">[</span><span class="nx">uniformsBGLayout</span><span class="p">,</span> <span class="nx">nodeParamsBGLayout</span><span class="p">]</span>
    <span class="p">});</span>

    <span class="c1">// renderPipeline creation is the same as before</span>
  <span class="p">}</span>

  <span class="nf">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Removed: no longer need to bind the view params bind group</span>
    <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nf">setPipeline</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">renderPipeline</span><span class="p">);</span>

    <span class="c1">// Rest of rendering code is the same as before</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="updating-our-shader-code">Updating our Shader Code</h2>

<p>Our node transform matrix is now on the GPU and being passed through a bind group as a uniform parameter that we can access in our shader. The last step is to update our shader code from before to apply the node transform to the vertices in the vertex shader. The shader code is the same as before, with the addition of the <code class="language-plaintext highlighter-rouge">node_params</code> bind group and its use in <code class="language-plaintext highlighter-rouge">vertex_main</code></p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alias</span> <span class="n">float4</span> <span class="o">=</span> <span class="kt">vec4</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">alias</span> <span class="n">float3</span> <span class="o">=</span> <span class="kt">vec3</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">VertexInput</span> <span class="p">{</span>
    <span class="err">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">position</span><span class="o">:</span> <span class="n">float3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">VertexOutput</span> <span class="p">{</span>
    <span class="err">@</span><span class="n">builtin</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="n">position</span><span class="o">:</span> <span class="n">float4</span><span class="p">,</span>
    <span class="err">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">world_pos</span><span class="o">:</span> <span class="n">float3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ViewParams</span> <span class="p">{</span>
    <span class="nl">view_proj:</span> <span class="kt">mat4x4</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// New struct for our node params</span>
<span class="k">struct</span> <span class="n">NodeParams</span> <span class="p">{</span>
    <span class="nl">transform:</span> <span class="kt">mat4x4</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">};</span>

<span class="err">@</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="err">@</span><span class="n">binding</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">var</span><span class="o">&lt;</span><span class="k">uniform</span><span class="o">&gt;</span> <span class="n">view_params</span><span class="o">:</span> <span class="n">ViewParams</span><span class="p">;</span>

<span class="c1">// New uniform parameter passing our node params</span>
<span class="err">@</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">@</span><span class="n">binding</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">var</span><span class="o">&lt;</span><span class="k">uniform</span><span class="o">&gt;</span> <span class="n">node_params</span><span class="o">:</span> <span class="n">NodeParams</span><span class="p">;</span>

<span class="err">@</span><span class="n">vertex</span>
<span class="n">fn</span> <span class="n">vertex_main</span><span class="p">(</span><span class="n">vert</span><span class="o">:</span> <span class="n">VertexInput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VertexOutput</span> <span class="p">{</span>
    <span class="n">var</span> <span class="k">out</span><span class="o">:</span> <span class="n">VertexOutput</span><span class="p">;</span>
    <span class="c1">// New: use node_params.transform to transform the vertices into world space</span>
    <span class="k">out</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">view_params</span><span class="p">.</span><span class="n">view_proj</span> <span class="o">*</span> <span class="n">node_params</span><span class="p">.</span><span class="n">transform</span> <span class="o">*</span> <span class="n">float4</span><span class="p">(</span><span class="n">vert</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">out</span><span class="p">.</span><span class="n">world_pos</span> <span class="o">=</span> <span class="n">vert</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">out</span><span class="p">;</span>
<span class="p">};</span>

<span class="err">@</span><span class="n">fragment</span>
<span class="n">fn</span> <span class="nf">fragment_main</span><span class="p">(</span><span class="k">in</span><span class="o">:</span> <span class="n">VertexOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">float4</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">dpdx</span><span class="p">(</span><span class="k">in</span><span class="p">.</span><span class="n">world_pos</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">dpdy</span><span class="p">(</span><span class="k">in</span><span class="p">.</span><span class="n">world_pos</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>

<h1 id="result">Result</h1>

<p>That’s it! Now we can correctly render the 2CylinderEngine glTF scene, properly accounting for the hierarchical node transforms specified in the file to position the geometry in the scene. You can view the full code on <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/tree/main/4-full-scene">Github</a> to run the app locally, <a href="https://www.willusher.io/webgpu-0-to-gltf-demos/4-full-scene/">view it online</a>, or simply run try it out in the embed below.</p>

<p>Feel free to ask any questions or post comments on the <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/discussions/3">Github discussion board for this post</a>.</p>

<p>Now that we’re rendering entire glTF scenes we find that we’re creating a lot of redundant render pipelines and repeatedly binding them.
In the next post, we’ll look at how we can optimize rendering by re-using pipelines and batching rendering commands into render bundles to reduce repeated call overhead.
I also highly recommend checking out <a href="https://toji.github.io/webgpu-gltf-case-study/">Brandon Jones’s write up on efficient rendering of glTF in WebGPU</a>!
See you next time!</p>

<div class="embed-responsive embed-responsive-4by3">
<iframe class="embed-responsive-item" src="https://www.willusher.io/webgpu-0-to-gltf-demos/4-full-scene/index.html"></iframe>
</div>


		<hr>
		<div class="col-12 row">
			
			<div class="col-md-6 justify-content-left">
				<a href="/graphics/2023/05/16/0-to-gltf-first-mesh" title="From 0 to glTF with WebGPU: Rendering the First glTF Mesh">
					<span class="fa fa-chevron-left" aria-hidden="true"></span>&nbsp Previous</a>
			</div>
			
			
		</div>
	</div>
</div>



	</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    

    <script defer data-domain="willusher.io" src="https://pan.wushernet.com/js/script.js"></script>

</body>
</html>



