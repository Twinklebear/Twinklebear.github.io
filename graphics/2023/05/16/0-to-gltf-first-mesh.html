

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="origin-trial" content="AoMftca5+Dstn4K7mCd1AKVcenGb0/EBkqJgonux6w6fVXhyJ2iHs9LuZKA36+gcaypMdBLAaIpkES6VMXoJtg8AAABQeyJvcmlnaW4iOiJodHRwczovL3d3dy53aWxsdXNoZXIuaW86NDQzIiwiZmVhdHVyZSI6IldlYkdQVSIsImV4cGlyeSI6MTY0MzE1NTE5OX0=">

	<title>From 0 to glTF with WebGPU: Rendering the First glTF Mesh</title>
	
		<meta name="description" content="">
	
    <meta name="author" content="Will Usher">

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

	<!-- Should I be including font-awesome from bootstrap? Or just the 5.0 version? -->
    <!--<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>-->
    <script defer src="https://kit.fontawesome.com/b56adde3a3.js" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>

	<link href="/assets/molokai.css" rel="stylesheet">
	<link href="/assets/custom.css" rel="stylesheet">
	<link rel="shortcut icon" href="/assets/img/identicon.ico">

</head>
<body>
	<nav class="navbar navbar-expand-md navbar-dark bg-dark static-top">
		<div class="container">
			<a class="navbar-brand" href="/">Will Usher</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
				data-target="#navbar_responsive" aria-controls="navbarResponsive" aria-expanded="false"
				aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbar_responsive">
				<ul class="navbar-nav mr-auto">
				
				
				  
					
					  
					  
						<li class="nav-item"><a href="/projects" class="nav-link">
							Projects</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/blog" class="nav-link">
							Blog</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/pages/sdl2" class="nav-link">
							SDL2 Tutorials</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/news" class="nav-link">
							News</a></li>
						
					  
					
				  
					
					  
					  
						<li class="nav-item"><a href="/archive" class="nav-link">
							Archive</a></li>
						
					  
					
				  
				</ul>
			</div><!-- nav.collaps -->
		</div>
	</nav>

	<div class="container content mb-4">
		

<h1 class="display-4">From 0 to glTF with WebGPU: Rendering the First glTF Mesh</h1>

<div class="row justify-content-center">
	<div class="col-9">
        <p>May 16, 2023</p>
		
<p>Now that we’ve seen how to draw a triangle in the <a href="https://www.willusher.io/graphics/2023/04/10/0-to-gltf-triangle">first post</a> and hook up camera controls so we can look around in the <a href="https://www.willusher.io/graphics/2023/04/11/0-to-gltf-bind-groups">second post</a>, we’re at the point where the avocado really hits the screen and we can start drawing our first glTF primitives! I say the avocado hits the screen because that’s the glTF test model we’ll be using. You can grab it from the <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/Avocado">Khronos glTF samples repo</a>. glTF files come in two flavors (minus other extension specific versions), a standard “.gltf” version that stores the JSON header in one file and binary data and textures in separate files, and a “.glb” version, that combines the JSON header and all binary or texture data into a single file. We’ll be loading .glb files in this series to simplify how many files we have to deal with to get a model into the renderer, so grab the glTF-Binary <a href="https://github.com/KhronosGroup/glTF-Sample-Models/raw/master/2.0/Avocado/glTF-Binary/Avocado.glb">Avocado.glb</a> and let’s get started!</p>

<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/first-mesh-avocado.png" />
	
	<figcaption><b>Figure 1:</b>
	<i>It takes quite a bit to get Avocado.glb on the screen, but this
    beautiful image of our expected final (and delicious) result should
    be enough motivation to keep us going!
    </i></figcaption>
</figure>

<!--more-->

<h1 id="gltf-concepts">glTF Concepts</h1>

<p>The glTF format was designed for efficient transfer of 3D content, and consists of a JSON part that describes the objects, and a binary part(s) containing the data for them. The binary data can be stored in separate binary files, embedded in the JSON as Base64, or in the case of glB (and the focus of this series), appended as binary in the same file following the JSON data. We’ll look at glB specifically in more detail later, but first we need to understand what’s in the JSON part of the glTF file that describes the scene.</p>

<p>I recommend taking a look through the <a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">glTF 2.0 cheat sheet</a>, which is a great resource to get a quick overview of what’s in a glTF file. For even more details, check out the <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">glTF 2.0 spec</a>. The cheat sheet is excellent, but it might be a bit overwhelming since it covers everything that glTF supports, which is a lot! We’re going to be starting small for this post and just getting our first GLTFMesh on the screen, so we can ignore a lot of the file right now.</p>

<p>The sketch below is adapted from the glTF cheat sheet concepts sketch to just show the parts of the file that we’ll be looking at for this post: Meshes, Primitives, Accessors, BufferViews, and Buffers.</p>

<!--![Screenshot 2023-05-15 at 11.32.04 AM.png](Parsing%20and%20Rendering%20the%20First%20Mesh%20from%20a%20glTF%20F%20811e35c0bfa44348b2bd78993a3e3fb2/Screenshot_2023-05-15_at_11.32.04_AM.png)-->
<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-concepts.svg" />
	
	<figcaption><b>Figure 2:</b>
	<i>The GLTF concepts we'll be looking at in this post and their relationships. A mesh is made of multiple primitives. Primitives can reference multiple accessors that provide data for their attributes. Accessors provide type information for data referenced in buffer views. Buffer views reference regions of a binary buffer provided with the file.
    </i></figcaption>
</figure>

<p>The Meshes, Accessors, BufferViews and Buffers are all top-level objects in the JSON, as shown below for the Avocado.glb scene. The Scenes, Nodes, Cameras, Materials, Textures, Images, Samplers, Skins and Animations are also top-level JSON objects, but we won’t be looking into those yet. The Avocado includes a few of these objects, which you can see below.</p>

<p>To view the header of a glb file you can open it in a text editor, which will display the JSON part as readable text followed by a bunch of junk for the binary data. Alternatively, I wrote a small python script to print out the JSON part of a glb file to the console, you can download it <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/3-first-mesh/print_glb_header.py">here</a>. <a href="https://gltf.report/">gltf.report</a> is another useful site where you can explore the content of gltf/glb files.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"accessors"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"bufferViews"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"buffers"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"images"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"meshes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"primitives"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="err">...</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="err">...</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"materials"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"nodes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"scene"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"scenes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"textures"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Let’s take a look at the objects we’ll be loading for this post in a bit more detail. We’ll be using the Avocado.glb as the example here and work our way from the bottom to the top. We want to be able to load other files than just the Avocado, so we’ll also talk about possible properties of these objects that may not be used by the Avocado scene.</p>

<h2 id="buffers">Buffers</h2>

<p>The buffers entry for a glb file is pretty straightforward. A glb file that doesn’t use any extensions will have a single binary buffer following the JSON data. The length of this buffer is specified in bytes, in the <code class="language-plaintext highlighter-rouge">byteLength</code> member of the Buffer object. glTF files using separate binary files or Base64 encoding can have multiple entries here, referring to different binary files or containing different Base64 encoded binary data. The buffer entry for the Avocado.glb is shown below.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"buffers"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">8326600</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<h2 id="bufferviews">BufferViews</h2>

<p>The binary data for our glTF file is packed into a single binary buffer which can contain vertex data, textures, etc. The buffer views are used to create virtual sub-buffers, or views, of this single large binary buffer to access specific vertex data, texture data, etc.</p>

<p>A bufferview must specify the buffer it references, <code class="language-plaintext highlighter-rouge">buffer</code>, and the size of the view in bytes, <code class="language-plaintext highlighter-rouge">byteLength</code>. The buffer view can optionally specify an offset from the start of the buffer that the view begins at, <code class="language-plaintext highlighter-rouge">byteOffset</code>, and the stride between elements in the buffer, <code class="language-plaintext highlighter-rouge">byteStride</code>. The <code class="language-plaintext highlighter-rouge">byteOffset</code> and <code class="language-plaintext highlighter-rouge">byteLength</code> together allow defining views of subregions of the buffer. The <code class="language-plaintext highlighter-rouge">byteStride</code> can be used to define a view containing interleaved data, for example a buffer that interleaves positions and normals for each vertex as position0, normal0, position1, normal1, etc. If the <code class="language-plaintext highlighter-rouge">byteStride</code> is not provided, the buffer is assumed to be tightly packed with elements of size defined by the accessor. Note that <code class="language-plaintext highlighter-rouge">byteStride</code> is required if multiple accessors reference a single buffer view.</p>

<p>There are some less common optional properties that can also be specified, see the <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#buffers-and-buffer-views">spec</a> for details.</p>

<p>The bufferview objects for the Avocado.glb are shown below. We don’t have interleaved buffers for the Avocado, but Khronos provides an <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/BoxInterleaved">example</a> if you’re curious.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"bufferViews"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">3158729</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">3158729</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">1655059</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">4813788</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">3489232</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">8303020</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">3248</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">8306268</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">4872</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">8311140</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">6496</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">8317636</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">4872</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"buffer"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteOffset"</span><span class="p">:</span><span class="w"> </span><span class="mi">8322508</span><span class="p">,</span><span class="w">
    </span><span class="nl">"byteLength"</span><span class="p">:</span><span class="w"> </span><span class="mi">4092</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<h2 id="accessors">Accessors</h2>

<p>An accessor takes the data defined by a buffer view and specifies how it should be interpreted by the application. The accessor specifies the component type of the data, <code class="language-plaintext highlighter-rouge">componentType</code>, (e.g., int, float), the type of the elements, <code class="language-plaintext highlighter-rouge">type</code>, (scalar, vec2, vec3, etc.), and the number of elements, <code class="language-plaintext highlighter-rouge">count</code>. Accessors can optionally specify an additional offset, <code class="language-plaintext highlighter-rouge">byteOffset</code> , from the start of the referenced buffer view. More details about these parameters and optional ones can be found in the <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#accessors">spec</a>.</p>

<p>The accessor offset can be used to apply an offset to access different elements in an interleaved buffer, or to apply an additional absolute offset to access a set of elements at some offset within the same buffer view. In WebGPU we have two options for how we pass the byte offset for a vertex attribute, and where we pass it will depend on whether the accessor is referring to interleaved data or is applying an additional absolute offset. For simplicity, later in this post we will pass it in the most generic location.</p>

<p>The illustration below shows an interleaved attribute buffer case. We have a single 32 byte buffer, within which is some interleaved vertex data containing a vec2 and scalar for each vertex. The file provides a buffer view specifying the offset to this data and the stride between elements (12 bytes). It then includes two accessors referencing this buffer view, one for the green vec2 attribute and one for the orange scalar attribute.</p>

<!--![Screenshot 2023-05-15 at 3.24.04 PM.png](Parsing%20and%20Rendering%20the%20First%20Mesh%20from%20a%20glTF%20F%20811e35c0bfa44348b2bd78993a3e3fb2/Screenshot_2023-05-15_at_3.24.04_PM.png)-->
<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-accessors-interleaved.svg" />
	
	<figcaption><b>Figure 3:</b>
	<i>Buffer, BufferView and Accessor configuration for a buffer storing interleaved vertex attributes.
    </i></figcaption>
</figure>

<p>The illustration below shows a case of using an accessor to apply an additional absolute offset. In this case, we again have a 32 byte buffer, but within the buffer is data containing position and normal data for a vertex. This data is specified as two vec3’s, which are not interleaved. Our buffer view can be made with the same parameters as above; however, our normal accessor now applies a larger byte offset to reach the desired region of the buffer view.</p>

<!--![Screenshot 2023-05-15 at 3.27.31 PM.png](Parsing%20and%20Rendering%20the%20First%20Mesh%20from%20a%20glTF%20F%20811e35c0bfa44348b2bd78993a3e3fb2/Screenshot_2023-05-15_at_3.27.31_PM.png)-->
<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-accessors-absolute-offset.svg" />
	
	<figcaption><b>Figure 4:</b>
	<i>Buffer, BufferView and Accessor configuration for a buffer storing packed vertex attributes. The accessor offset is used to access the normal vector attribute within the same buffer view.
    </i></figcaption>
</figure>

<p>It’s important to note that the two strategies can also be combined. We could have an interleaved buffer like the interleaved example, but use an accessor to apply both a large offset containing both the absolute and element offset to access some subregion of the buffer view. This is illustrated below, where we have accessors made specifically for the second elements in the interleaved case. These possibilities will impact our choice of how we specify the accessor offsets in WebGPU.</p>

<!--![Screenshot 2023-05-15 at 3.35.38 PM.png](Parsing%20and%20Rendering%20the%20First%20Mesh%20from%20a%20glTF%20F%20811e35c0bfa44348b2bd78993a3e3fb2/Screenshot_2023-05-15_at_3.35.38_PM.png)-->
<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/gltf-accessors-interleaved-and-absolute-offset.svg" />
	
	<figcaption><b>Figure 5:</b>
	<i>Buffer, BufferView and Accessor configuration for accessing interleaved vertex attribute data at an additional absolute offset within a buffer view.
    </i></figcaption>
</figure>

<p>Fortunately, the accessors for the Avocado are pretty simple. Each accessor references a different buffer view containing the packed elements for its data, as shown below.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"accessors"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bufferView"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
    </span><span class="nl">"componentType"</span><span class="p">:</span><span class="w"> </span><span class="mi">5126</span><span class="p">,</span><span class="w">
    </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">406</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"VEC2"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bufferView"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">
    </span><span class="nl">"componentType"</span><span class="p">:</span><span class="w"> </span><span class="mi">5126</span><span class="p">,</span><span class="w">
    </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">406</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"VEC3"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bufferView"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
    </span><span class="nl">"componentType"</span><span class="p">:</span><span class="w"> </span><span class="mi">5126</span><span class="p">,</span><span class="w">
    </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">406</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"VEC4"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bufferView"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
    </span><span class="nl">"componentType"</span><span class="p">:</span><span class="w"> </span><span class="mi">5126</span><span class="p">,</span><span class="w">
    </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">406</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"VEC3"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"max"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="mf">0.02128091</span><span class="p">,</span><span class="w">
      </span><span class="mf">0.06284806</span><span class="p">,</span><span class="w">
      </span><span class="mf">0.0138090011</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"min"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="mf">-0.02128091</span><span class="p">,</span><span class="w">
      </span><span class="mf">-4.773855e-05</span><span class="p">,</span><span class="w">
      </span><span class="mf">-0.013809</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bufferView"</span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w">
    </span><span class="nl">"componentType"</span><span class="p">:</span><span class="w"> </span><span class="mi">5123</span><span class="p">,</span><span class="w">
    </span><span class="nl">"count"</span><span class="p">:</span><span class="w"> </span><span class="mi">2046</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"SCALAR"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<h2 id="meshes-and-primitives">Meshes and Primitives</h2>

<p>Finally, we can take a look at how meshes are specified in glTF. A mesh object itself is just a list of primitives, an optional name, and a few other optional parameters that we won’t need here (see the <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-mesh">spec</a>). The real work of specifying the geometry for a mesh is done by its primitives.</p>

<p>The primitives array of the mesh specifies the different geometric primitives that make up the mesh. The attributes for each primitive maps each attribute’s name to an accessor that provides the data. The <code class="language-plaintext highlighter-rouge">POSITION</code> attribute is required, other optional attributes are defined by the <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes">spec</a> and applications can also add custom attributes as well. A list of vertex indices for indexed rendering can be provided by specifying the accessor referencing the index data. Each primitive can also specify a material and topology mode (e.g., points, lines, triangles), along with other <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-mesh-primitive">optional parameters</a>.</p>

<p>The meshes for the Avocado are listed below. The Avocado contains a single primitive, who’s <code class="language-plaintext highlighter-rouge">POSITION</code> attribute references accessor 3. This accessor (above) provides vec3 float data (this format is required by the spec) for the vertex positions.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"meshes"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"primitives"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="w">
        </span><span class="nl">"attributes"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"TEXCOORD_0"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
          </span><span class="nl">"NORMAL"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
          </span><span class="nl">"TANGENT"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
          </span><span class="nl">"POSITION"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="nl">"indices"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w">
        </span><span class="nl">"material"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Avocado"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<h1 id="anatomy-of-a-binary-gltf-file-glb">Anatomy of a Binary glTF File (glb)</h1>

<p>Typical glTF files separate the JSON and binary data into different files, requiring multiple network requests or disk accesses to load the data. The glB format was designed to address this issue, by combining the JSON header and all binary data into a single file. This combination has the added benefit of making the data easier to manage as well, as we only need to keep track of one file. However, it also means we need to do a bit more byte-level access when reading the data so that we can properly access the JSON and binary data for the file.</p>

<p>A glb is required to contain a JSON chunk followed by a binary chunk, in that order (<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#glb-file-format-specification">spec</a>). Additional chunks for extensions can follow the binary chunk, if needed.</p>

<p>Visually, a binary glTF file as shown below</p>

<!--![Screenshot 2023-05-15 at 4.31.04 PM.png](Parsing%20and%20Rendering%20the%20First%20Mesh%20from%20a%20glTF%20F%20811e35c0bfa44348b2bd78993a3e3fb2/Screenshot_2023-05-15_at_4.31.04_PM.png)-->
<figure>
	<img class="img-fluid" src="https://cdn.willusher.io/webgpu-0-to-gltf/glb-layout.svg" />
	
	<figcaption><b>Figure 6:</b>
	<i>The glb file layout.
    </i></figcaption>
</figure>

<p>The first 12 bytes are the glb header, used to identify the file as glb file and specify its total length in bytes (including all headers, JSON, binary). The JSON chunk starts at 12 bytes, and includes a chunk header specifying its length and type, followed by a JSON string. The JSON string will occupy bytes 20 to 20 + jsonChunkLength. The binary chunk follows at byte 20 + jsonChunkLength, and contains its own header specifying the binary chunk length and type, followed by the binary data for the file.</p>

<h1 id="parsing-a-gltf-mesh-from-a-glb-file">Parsing a glTF Mesh from a glB File</h1>

<p>Now that we’re familiar with the parts of the glTF file we need and know how to read a binary glTF file, we’re ready to load up a glb file and import the data to render our Avocado! We’re going to start with simply loading the primitives for the first mesh we find in the file. This will work for our Avocado and a number of other simple single-mesh glTF files available in the Khronos test model repo and online.</p>

<p>We’ll load the file from bottom to top, in the same order that we discussed the components in detail above. The final <code class="language-plaintext highlighter-rouge">uploadGLB</code> function and supporting classes can be found in the repo on <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/3-first-mesh/src/glb.js">GitHub</a>.</p>

<h2 id="reading-the-header">Reading the Header</h2>

<p>First, we need to read the glb header, load the JSON chunk, and create a buffer corresponding to the binary chunk. Our function <code class="language-plaintext highlighter-rouge">uploadGLB</code> takes an ArrayBuffer, <code class="language-plaintext highlighter-rouge">buffer</code>, containing the glb file data, and the WebGPU Device, <code class="language-plaintext highlighter-rouge">device</code>, to upload the data to.</p>

<p>First, we create a <code class="language-plaintext highlighter-rouge">Uint32Array</code> over the glb file data that contains both the glb header and JSON chunk header.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">uploadGLB</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">device</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// glB has a JSON chunk and a binary chunk, potentially followed by</span>
    <span class="c1">// other chunks specifying extension specific data, which we ignore</span>
    <span class="c1">// since we don't support any extensions.</span>
    <span class="c1">// Read the glB header and the JSON chunk header together </span>
    <span class="c1">// glB header:</span>
    <span class="c1">// - magic: u32 (expect: 0x46546C67)</span>
    <span class="c1">// - version: u32 (expect: 2)</span>
    <span class="c1">// - length: u32 (size of the entire file, in bytes)</span>
    <span class="c1">// JSON chunk header</span>
    <span class="c1">// - chunkLength: u32 (size of the chunk, in bytes)</span>
    <span class="c1">// - chunkType: u32 (expect: 0x4E4F534A for the JSON chunk)</span>
    <span class="kd">var</span> <span class="nx">header</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">// Validate glb file contains correct magic value</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x46546C67</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Provided file is not a glB file</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Provided file is glTF 2.0 file</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Validate that first chunk is JSON</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">header</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x4E4F534A</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Invalid glB: The first chunk of the glB file is not a JSON chunk!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Decode the JSON chunk of the glB file to a JSON object</span>
    <span class="kd">var</span> <span class="nx">jsonChunk</span> <span class="o">=</span>
        <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="k">new</span> <span class="nx">TextDecoder</span><span class="p">(</span><span class="dl">"</span><span class="s2">utf-8</span><span class="dl">"</span><span class="p">).</span><span class="nx">decode</span><span class="p">(</span><span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="nx">header</span><span class="p">[</span><span class="mi">3</span><span class="p">])));</span>

    <span class="c1">// Read the binary chunk header</span>
    <span class="c1">// - chunkLength: u32 (size of the chunk, in bytes)</span>
    <span class="c1">// - chunkType: u32 (expect: 0x46546C67 for the binary chunk)</span>
    <span class="kd">var</span> <span class="nx">binaryHeader</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">20</span> <span class="o">+</span> <span class="nx">header</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">binaryHeader</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x004E4942</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Invalid glB: The second chunk of the glB file is not a binary chunk!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="reading-the-buffer-and-bufferviews">Reading the Buffer and BufferViews</h2>

<p>We’ll introduce two classes, <code class="language-plaintext highlighter-rouge">GLTFBuffer</code> and <code class="language-plaintext highlighter-rouge">GLTFBufferView</code> to represent the gltf buffer and buffer view objects in our app.</p>

<p>First we can create the <code class="language-plaintext highlighter-rouge">GLTFBuffer</code>. Although the glb spec allows the JSON to reference other external buffers in addition to the single embedded buffer, we’re targeting just the simple and common use case that there’s a single buffer which is the binary chunk.</p>

<p>The <code class="language-plaintext highlighter-rouge">GLTFBuffer</code> class is a straightforward mapping of the GLTF buffer object. We create a new <code class="language-plaintext highlighter-rouge">Uint8Array</code> view over the glb buffer passed to the constructor at the binary chunk’s starting offset with the binary chunk’s size.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js, outside uploadGLB</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">GLTFBuffer</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">size</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can then create a <code class="language-plaintext highlighter-rouge">GLTFBuffer</code> referencing the data in the binary chunk</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// within uploadGLB</span>
<span class="c1">// Make a GLTFBuffer that is a view of the entire binary chunk's data,</span>
<span class="c1">// we'll use this to create buffer views within the chunk for memory referenced</span>
<span class="c1">// by objects in the glTF scene</span>
<span class="kd">var</span> <span class="nx">binaryChunk</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GLTFBuffer</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">28</span> <span class="o">+</span> <span class="nx">header</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">binaryHeader</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></div></div>

<p>The next object we need to read are the buffer views, which we represent with the <code class="language-plaintext highlighter-rouge">GLTFBufferView</code> class. The constructor for <code class="language-plaintext highlighter-rouge">GLTFBufferView</code> makes a new <code class="language-plaintext highlighter-rouge">Uint8Array</code> view over just the region of the binary chunk that the view covers. Note that the <code class="language-plaintext highlighter-rouge">subarray</code> API creates a view over the underlying <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, it does not make a copy. Another design choice here is that we don’t need to track the offset for buffer views after creating the view, because this offset is baked into the view object we create in the constructor.</p>

<p>The <code class="language-plaintext highlighter-rouge">GLTFBufferView</code> provides two additional methods, <code class="language-plaintext highlighter-rouge">addUsage</code> and <code class="language-plaintext highlighter-rouge">upload</code>. The latter is self-descriptive, it creates a GPU buffer and upload the buffer view to it. The <code class="language-plaintext highlighter-rouge">addUsage</code> method is used when parsing the rest of the scene data to ensure that the GPU buffer we create will have the correct usage flags set for it, e.g., to allow binding it as a vertex or index buffer.</p>

<p>We also track a flag <code class="language-plaintext highlighter-rouge">needsUpload</code> to determine which buffer views actually need to be uploaded to the GPU. Image data is also access through buffer views in glb files, however we don’t need to upload the PNG or JPG binary data to the GPU since we will instead decode it to a texture. When parsing the rest of the scene we’ll flag buffers that need to be uploaded to the GPU so that we can upload just what we need.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js, outside uploadGLB</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">GLTFBufferView</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">view</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">view</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteLength</span><span class="dl">"</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">byteStride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">view</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteStride</span><span class="dl">"</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">byteStride</span> <span class="o">=</span> <span class="nx">view</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteStride</span><span class="dl">"</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// Create the buffer view. Note that subarray creates a new typed</span>
        <span class="c1">// view over the same array buffer, we do not make a copy here.</span>
        <span class="kd">var</span> <span class="nx">viewOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">view</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteOffset</span><span class="dl">"</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">viewOffset</span> <span class="o">=</span> <span class="nx">view</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteOffset</span><span class="dl">"</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">view</span> <span class="o">=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">subarray</span><span class="p">(</span><span class="nx">viewOffset</span><span class="p">,</span> <span class="nx">viewOffset</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">needsUpload</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">gpuBuffer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">usage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// When this buffer is referenced as vertex data or index data we</span>
    <span class="c1">// add the corresponding usage flag here so that the GPU buffer can</span>
    <span class="c1">// be created properly.</span>
    <span class="nx">addUsage</span><span class="p">(</span><span class="nx">usage</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">usage</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">usage</span> <span class="o">|</span> <span class="nx">usage</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Upload the buffer view to a GPU buffer</span>
    <span class="nx">upload</span><span class="p">(</span><span class="nx">device</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Note: must align to 4 byte size when mapped at creation is true</span>
        <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">({</span>
            <span class="na">size</span><span class="p">:</span> <span class="nx">alignTo</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="na">usage</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">usage</span><span class="p">,</span>
            <span class="na">mappedAtCreation</span><span class="p">:</span> <span class="kc">true</span>
        <span class="p">});</span>
        <span class="k">new</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="kd">constructor</span><span class="p">)(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">getMappedRange</span><span class="p">()).</span><span class="kd">set</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">);</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">unmap</span><span class="p">();</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">gpuBuffer</span> <span class="o">=</span> <span class="nx">buf</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">needsUpload</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next we can loop through the bufferViews specified in the JSON chunk and create corresponding <code class="language-plaintext highlighter-rouge">GLTFBufferView</code> objects for them. The buffer view constructor takes the buffer to make a view over and the JSON object describing the buffer view being created.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// within uploadGLB</span>
<span class="c1">// Create GLTFBufferView objects for all the buffer views in the glTF file</span>
<span class="kd">var</span> <span class="nx">bufferViews</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">jsonChunk</span><span class="p">.</span><span class="nx">bufferViews</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">bufferViews</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">GLTFBufferView</span><span class="p">(</span><span class="nx">binaryChunk</span><span class="p">,</span> <span class="nx">jsonChunk</span><span class="p">.</span><span class="nx">bufferViews</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>At the end of <code class="language-plaintext highlighter-rouge">uploadGLB</code>, after we’ve loaded all the meshes and scene objects, we loop through the buffer views and upload those that need to be uploaded to the GPU based on which ones were marked as <code class="language-plaintext highlighter-rouge">needsUpload</code> during the scene loading step.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// at the end of uploadGLB before returning the mesh</span>
<span class="c1">// Upload the buffer views used by mesh</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bufferViews</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">bufferViews</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">needsUpload</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">bufferViews</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">upload</span><span class="p">(</span><span class="nx">device</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="reading-the-accessors">Reading the Accessors</h2>

<p>The next object up the chain are accessors, which we represent with the <code class="language-plaintext highlighter-rouge">GLTFAccessor</code> class shown below. The constructor takes the <code class="language-plaintext highlighter-rouge">GLTFBufferView</code> and the JSON object describing the accessor and constructs the object. The object is a direct mapping of the JSON accessor data, with the addition of storing a reference to the buffer view instead of just an index to it.</p>

<p>The accessor also provides a utility getter, <code class="language-plaintext highlighter-rouge">byteStride</code> , to compute the stride in bytes between elements referenced by the accessor. If the buffer view specifies a byte stride we use this stride, otherwise the elements are assumed to be packed and we use the size of the accessor type as the stride. If not byte stride is specified for the buffer view it will default to 0, thus we pick between the two with a max.</p>

<p>The utility functions <code class="language-plaintext highlighter-rouge">gltfTypeSize</code> and <code class="language-plaintext highlighter-rouge">gltfVertexType</code> are omitted from the post to keep it focused, these can be found on <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/3-first-mesh/src/glb.js">Github</a>.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js, outside uploadGLB</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">GLTFAccessor</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">view</span><span class="p">,</span> <span class="nx">accessor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">[</span><span class="dl">"</span><span class="s2">count</span><span class="dl">"</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">componentType</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">[</span><span class="dl">"</span><span class="s2">componentType</span><span class="dl">"</span><span class="p">];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">gltfType</span> <span class="o">=</span> <span class="nx">parseGltfType</span><span class="p">(</span><span class="nx">accessor</span><span class="p">[</span><span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">]);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">view</span> <span class="o">=</span> <span class="nx">view</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">accessor</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteOffset</span><span class="dl">"</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">byteOffset</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">[</span><span class="dl">"</span><span class="s2">byteOffset</span><span class="dl">"</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">get</span> <span class="nx">byteStride</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">elementSize</span> <span class="o">=</span> <span class="nx">gltfTypeSize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentType</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">gltfType</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">elementSize</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">byteStride</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Get the vertex attribute type for accessors that are</span>
    <span class="c1">// used as vertex attributes</span>
    <span class="kd">get</span> <span class="nx">vertexType</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">gltfVertexType</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">componentType</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">gltfType</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Back within <code class="language-plaintext highlighter-rouge">uploadGLB</code>, we can create the accessors after the loop creating the buffer views. The process is the same, we loop through the JSON data describing the accessors and create the objects, passing the referenced buffer view and the accessor JSON object to the constructor.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// within uploadGLB</span>
<span class="c1">// Create GLTFAccessor objects for the accessors in the glTF file</span>
<span class="c1">// We need to handle possible errors being thrown here if a model is using</span>
<span class="c1">// accessors for types we don't support yet. For example, a model with animation</span>
<span class="c1">// may have a MAT4 accessor, which we currently don't support.</span>
<span class="kd">var</span> <span class="nx">accessors</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">jsonChunk</span><span class="p">.</span><span class="nx">accessors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">accessorInfo</span> <span class="o">=</span> <span class="nx">jsonChunk</span><span class="p">.</span><span class="nx">accessors</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">viewID</span> <span class="o">=</span> <span class="nx">accessorInfo</span><span class="p">[</span><span class="dl">"</span><span class="s2">bufferView</span><span class="dl">"</span><span class="p">];</span>
    <span class="nx">accessors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">GLTFAccessor</span><span class="p">(</span><span class="nx">bufferViews</span><span class="p">[</span><span class="nx">viewID</span><span class="p">],</span> <span class="nx">accessorInfo</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="reading-the-meshs-primitives">Reading the Mesh’s Primitives</h2>

<p>With the accessors, buffer views, and buffers in place we can now load our mesh’s primitives. We’ll represent each primitive with the <code class="language-plaintext highlighter-rouge">GLTFPrimitive</code> class shown below. We’re just going to render the mesh geometry to start, and ignore any additional attributes. The <code class="language-plaintext highlighter-rouge">GLTFPrimitive</code> constructor takes the accessors for the vertex indices and positions, and the rendering topology (triangles, triangle strip, etc.). We’ll also start by only supporting triangles or triangle strips.</p>

<p>In the constructor we also mark the required buffer usages for the views and mark them as needing upload to the GPU so that our primitive can use the data during rendering. If indices are provided for the primitive we must add the index buffer usage flag to the underlying buffer view. Similarly, we must add the vertex buffer usage flag to the accessor’s buffer view. The index and vertex buffers will need to be uploaded to the GPU, and</p>

<p>The <code class="language-plaintext highlighter-rouge">GLTFPrimitive</code> has two methods that we’ll use later for rendering, <code class="language-plaintext highlighter-rouge">buildRenderPipeline</code> and <code class="language-plaintext highlighter-rouge">render</code>. We’ll look at those in detail later when we get to rendering our mesh.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js, outside uploadGLB</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">GLTFPrimitive</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">positions</span><span class="p">,</span> <span class="nx">indices</span><span class="p">,</span> <span class="nx">topology</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">positions</span> <span class="o">=</span> <span class="nx">positions</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">indices</span> <span class="o">=</span> <span class="nx">indices</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">topology</span> <span class="o">=</span> <span class="nx">topology</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">renderPipeline</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="c1">// Set usage for the positions data and flag it as needing upload</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">needsUpload</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">addUsage</span><span class="p">(</span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">VERTEX</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Set usage for the indices data and flag it as needing upload</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">needsUpload</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">addUsage</span><span class="p">(</span><span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">INDEX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                        <span class="nx">shaderModule</span><span class="p">,</span>
                        <span class="nx">colorFormat</span><span class="p">,</span>
                        <span class="nx">depthFormat</span><span class="p">,</span>
                        <span class="nx">uniformsBGLayout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// More on this later!</span>
    <span class="p">}</span>

    <span class="nx">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// More on this later!</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">GLTFMesh</code> class is pretty simple. It just takes the name of the mesh and the list of primitives that make up the mesh.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js, outside uploadGLB</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">GLTFMesh</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">primitives</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span> <span class="o">=</span> <span class="nx">primitives</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                        <span class="nx">shaderModule</span><span class="p">,</span>
                        <span class="nx">colorFormat</span><span class="p">,</span>
                        <span class="nx">depthFormat</span><span class="p">,</span>
                        <span class="nx">uniformsBGLayout</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// More on this later!</span>
    <span class="p">}</span>

    <span class="nx">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// More on this later!</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With everything in place we can now load the GLTF primitives and the mesh from the file. In this post we’re just going to load the first mesh defined in the file, so we take <code class="language-plaintext highlighter-rouge">jsonChunk.meshes[0]</code> and then loop through its primitives to create the <code class="language-plaintext highlighter-rouge">GLTFPrimitive</code> objects. Another restriction we’ll have is that we only support triangles and triangle trip topologies for now. Our primitive importing loop will throw an error if we encounter an unsupported primitive type for now.</p>

<p>To create each primitive we then need to find the accessors for its indices (if provided) and vertex positions (required). The indices are provided as a distinct member of the primitive’s JSON object, while the positions are listed in the primitive attributes map as the <code class="language-plaintext highlighter-rouge">POSITION</code> attribute. The <code class="language-plaintext highlighter-rouge">POSITION</code> attribute is required by the glTF spec to be provided.</p>

<p>Once we’ve imported all the primitives we can create the mesh. The <code class="language-plaintext highlighter-rouge">GLTFRenderMode</code> constants are omitted for brevity, and can be found on <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/3-first-mesh/src/glb.js">Github</a>.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// within uploadGLB</span>
<span class="c1">// Load the first mesh</span>
<span class="kd">var</span> <span class="nx">mesh</span> <span class="o">=</span> <span class="nx">jsonChunk</span><span class="p">.</span><span class="nx">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">meshPrimitives</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// Loop through the mesh's primitives and load them</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">mesh</span><span class="p">.</span><span class="nx">primitives</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">prim</span> <span class="o">=</span> <span class="nx">mesh</span><span class="p">.</span><span class="nx">primitives</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">topology</span> <span class="o">=</span> <span class="nx">prim</span><span class="p">[</span><span class="dl">"</span><span class="s2">mode</span><span class="dl">"</span><span class="p">];</span>
    <span class="c1">// Default is triangles if mode specified</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">topology</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">topology</span> <span class="o">=</span> <span class="nx">GLTFRenderMode</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">topology</span> <span class="o">!=</span> <span class="nx">GLTFRenderMode</span><span class="p">.</span><span class="nx">TRIANGLES</span> <span class="o">&amp;&amp;</span>
        <span class="nx">topology</span> <span class="o">!=</span> <span class="nx">GLTFRenderMode</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Unsupported primitive mode </span><span class="p">${</span><span class="nx">prim</span><span class="p">[</span><span class="dl">"</span><span class="s2">mode</span><span class="dl">"</span><span class="p">]}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Find the vertex indices accessor if provided</span>
    <span class="kd">var</span> <span class="nx">indices</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">jsonChunk</span><span class="p">[</span><span class="dl">"</span><span class="s2">accessors</span><span class="dl">"</span><span class="p">][</span><span class="nx">prim</span><span class="p">[</span><span class="dl">"</span><span class="s2">indices</span><span class="dl">"</span><span class="p">]]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">indices</span> <span class="o">=</span> <span class="nx">accessors</span><span class="p">[</span><span class="nx">prim</span><span class="p">[</span><span class="dl">"</span><span class="s2">indices</span><span class="dl">"</span><span class="p">]];</span>
    <span class="p">}</span>

    <span class="c1">// Loop through all the attributes to find the POSITION attribute.</span>
    <span class="c1">// While we only want the position attribute right now, we'll load</span>
    <span class="c1">// the others later as well.</span>
    <span class="kd">var</span> <span class="nx">positions</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">attr</span> <span class="k">in</span> <span class="nx">prim</span><span class="p">[</span><span class="dl">"</span><span class="s2">attributes</span><span class="dl">"</span><span class="p">])</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">accessor</span> <span class="o">=</span> <span class="nx">accessors</span><span class="p">[</span><span class="nx">prim</span><span class="p">[</span><span class="dl">"</span><span class="s2">attributes</span><span class="dl">"</span><span class="p">][</span><span class="nx">attr</span><span class="p">]];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">attr</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">POSITION</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">positions</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Add the primitive to the mesh's list of primitives</span>
    <span class="nx">meshPrimitives</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">GLTFPrimitive</span><span class="p">(</span><span class="nx">positions</span><span class="p">,</span> <span class="nx">indices</span><span class="p">,</span> <span class="nx">topology</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">// Create the GLTFMesh</span>
<span class="kd">var</span> <span class="nx">mesh</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GLTFMesh</span><span class="p">(</span><span class="nx">mesh</span><span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">],</span> <span class="nx">meshPrimitives</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, before we return the mesh we loaded we have to loop through the buffer views and upload any that were marked as “needs upload” to the GPU so that the data will be available during rendering.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// at the end of uploadGLB</span>
<span class="c1">// Upload the buffers as mentioned above before returning the mesh</span>
<span class="c1">// Upload the buffer views used by mesh</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bufferViews</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">bufferViews</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">needsUpload</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">bufferViews</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">upload</span><span class="p">(</span><span class="nx">device</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="nx">mesh</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="rendering-the-mesh">Rendering the Mesh</h1>

<p>We’ve put in a lot of work getting our mesh data loaded from the glb file, but we’re almost there! To render the mesh we need to render each of its primitives. To render each primitive we’re going to implement the two methods we saw earlier: <code class="language-plaintext highlighter-rouge">GLTFPrimitive.buildRenderPipeline</code> , responsible for creating the rendering pipeline for the primitive, and <code class="language-plaintext highlighter-rouge">GLTFPrimitive.render</code> , which will encode the rendering commands for the primitive.</p>

<p>You might be wondering, “won’t this be really inefficient for large scenes where my GLTF file has 100’s-1000’s (or more) primitives?”, and you’re right! Creating a rendering pipeline for each individual primitive is not a scalable approach. We’ll come back to how we can optimize this simple approach in a later post, but it’s enough to get us started for now.</p>

<h2 id="building-a-render-pipeline-for-each-primitive">Building a Render Pipeline for Each Primitive</h2>

<p>First we need to build a render pipeline for each primitive. This is done in the <code class="language-plaintext highlighter-rouge">GLTFPrimitive.buildRenderPipeline</code> method, shown below. To allow some re-use across primitives we will use the same shader for all of them, as right now we don’t need to handle differences in attributes or material usage between primitives. This is passed as the <code class="language-plaintext highlighter-rouge">shaderModule</code> parameter. We’ll also be sharing the same uniform buffer containing the camera parameters across all primitives, this bind group layout is passed as the <code class="language-plaintext highlighter-rouge">uniformsBGLayout</code> . We also need the output color format and depth formats to build the render pipeline. The app rendering our primitive passes these through to us as <code class="language-plaintext highlighter-rouge">colorFormat</code> and <code class="language-plaintext highlighter-rouge">depthFormat</code> respectively.</p>

<p>The setup here is actually not that different from the previous posts. The main changes are that we now use the positions accessor’s <code class="language-plaintext highlighter-rouge">byteStride</code> as the vertex attribute array stride, and compute the vertex type for it from the accessor’s type. It’s worth noting that for GLTF, the <code class="language-plaintext highlighter-rouge">POSITION</code> attribute must always be <code class="language-plaintext highlighter-rouge">float32x3</code>.</p>

<p>A key point here is that we do not pass the position accessor’s <code class="language-plaintext highlighter-rouge">byteOffset</code> as the attribute offset in the vertex state. In WebGPU, there are two ways to pass a byte offset for a vertex attribute. It can either be set in the vertex state, where it is treated as an offset within <code class="language-plaintext highlighter-rouge">arrayStride</code> for accessing interleaved attributes, or as a global offset applied to the buffer when calling <code class="language-plaintext highlighter-rouge">setVertexBuffer</code>. The attribute offset set in the vertex state is specifically for interleaved attributes, and thus WebGPU requires that <code class="language-plaintext highlighter-rouge">offset + sizeof(format)</code> is less than the <code class="language-plaintext highlighter-rouge">arrayStride</code> of the buffer. However, the offset applied in <code class="language-plaintext highlighter-rouge">setVertexBuffer</code> has no such restriction, as it applies an absolute offset in bytes from the start of the buffer. Passing the offset in <code class="language-plaintext highlighter-rouge">setVertexBuffer</code> doesn’t prevent us from supporting interleaved attributes, but it does mean we need to bind the same buffer twice. Since we’re only supporting one attribute right now anyways, the position, we’ll simply apply the offset in <code class="language-plaintext highlighter-rouge">setVertexBuffer</code>to simplify handling the different offset size possibilities in GLTF.</p>

<p>The last change difference is that, if we’re rendering a triangle strip, WebGPU requires us to include the index format as part of the pipeline.  This is handled when creating the <code class="language-plaintext highlighter-rouge">primitive</code> object for the pipeline descriptor.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js GLTFPrimitive.buildRenderPipeline implementation</span>
<span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                    <span class="nx">shaderModule</span><span class="p">,</span>
                    <span class="nx">colorFormat</span><span class="p">,</span>
                    <span class="nx">depthFormat</span><span class="p">,</span>
                    <span class="nx">uniformsBGLayout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Vertex attribute state and shader stage</span>
    <span class="kd">var</span> <span class="nx">vertexState</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1">// Shader stage info</span>
        <span class="na">module</span><span class="p">:</span> <span class="nx">shaderModule</span><span class="p">,</span>
        <span class="na">entryPoint</span><span class="p">:</span> <span class="dl">"</span><span class="s2">vertex_main</span><span class="dl">"</span><span class="p">,</span>
        <span class="c1">// Vertex buffer info</span>
        <span class="na">buffers</span><span class="p">:</span> <span class="p">[{</span>
            <span class="na">arrayStride</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">byteStride</span><span class="p">,</span>
            <span class="na">attributes</span><span class="p">:</span> <span class="p">[</span>
                <span class="c1">// Note: We do not pass the positions.byteOffset here, as its</span>
                <span class="c1">// meaning can vary in different glB files, i.e., if it's</span>
                <span class="c1">// being used for interleaved element offset or an absolute</span>
                <span class="c1">// offset.</span>
                <span class="p">{</span>
                    <span class="na">format</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">vertexType</span><span class="p">,</span> 
                    <span class="na">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="na">shaderLocation</span><span class="p">:</span> <span class="mi">0</span>
                <span class="p">}</span>
            <span class="p">]</span>
        <span class="p">}]</span>
    <span class="p">};</span>
  
    <span class="kd">var</span> <span class="nx">fragmentState</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1">// Shader info</span>
        <span class="na">module</span><span class="p">:</span> <span class="nx">shaderModule</span><span class="p">,</span>
        <span class="na">entryPoint</span><span class="p">:</span> <span class="dl">"</span><span class="s2">fragment_main</span><span class="dl">"</span><span class="p">,</span>
        <span class="c1">// Output render target info</span>
        <span class="na">targets</span><span class="p">:</span> <span class="p">[{</span><span class="na">format</span><span class="p">:</span> <span class="nx">colorFormat</span><span class="p">}]</span>
    <span class="p">};</span>
  
    <span class="c1">// Our loader only supports triangle lists and strips, so by default we set</span>
    <span class="c1">// the primitive topology to triangle list, and check if it's</span>
    <span class="c1">// instead a triangle strip</span>
    <span class="kd">var</span> <span class="nx">primitive</span> <span class="o">=</span> <span class="p">{</span><span class="na">topology</span><span class="p">:</span> <span class="dl">"</span><span class="s2">triangle-list</span><span class="dl">"</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">topology</span> <span class="o">==</span> <span class="nx">GLTFRenderMode</span><span class="p">.</span><span class="nx">TRIANGLE_STRIP</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">primitive</span><span class="p">.</span><span class="nx">topology</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">triangle-strip</span><span class="dl">"</span><span class="p">;</span>
        <span class="nx">primitive</span><span class="p">.</span><span class="nx">stripIndexFormat</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">vertexType</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="kd">var</span> <span class="nx">layout</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nx">createPipelineLayout</span><span class="p">({</span>
        <span class="na">bindGroupLayouts</span><span class="p">:</span> <span class="p">[</span><span class="nx">uniformsBGLayout</span><span class="p">]</span>
    <span class="p">});</span>
  
    <span class="k">this</span><span class="p">.</span><span class="nx">renderPipeline</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nx">createRenderPipeline</span><span class="p">({</span>
        <span class="na">layout</span><span class="p">:</span> <span class="nx">layout</span><span class="p">,</span>
        <span class="na">vertex</span><span class="p">:</span> <span class="nx">vertexState</span><span class="p">,</span>
        <span class="na">fragment</span><span class="p">:</span> <span class="nx">fragmentState</span><span class="p">,</span>
        <span class="na">primitive</span><span class="p">:</span> <span class="nx">primitive</span><span class="p">,</span>
        <span class="na">depthStencil</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">format</span><span class="p">:</span> <span class="nx">depthFormat</span><span class="p">,</span>
            <span class="na">depthWriteEnabled</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="na">depthCompare</span><span class="p">:</span> <span class="dl">"</span><span class="s2">less</span><span class="dl">"</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="rendering-each-primitive">Rendering Each Primitive</h2>

<p>Now we can use our rendering pipeline in <code class="language-plaintext highlighter-rouge">GLTFPrimitive.render</code> to render our primitive! The render method takes as input a render pass encoder to encode our rendering commands into and the global uniforms bindgroup to bind.</p>

<p>The rendering process is similar to what we’ve seen in previous posts, with the main changes being that we need to set the accessor’s byte offset and length when binding the vertex buffer, and potentially use an index buffer for indexed rendering. When binding the index buffer we must also apply its accessor’s byte offset and length.</p>

<p>Then we can draw our primitive!</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js GLTFPrimitive.render implementation</span>
<span class="nx">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nx">setPipeline</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">renderPipeline</span><span class="p">);</span>
    <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nx">setBindGroup</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">);</span>

    <span class="c1">// Apply the accessor's byteOffset here to handle both global and interleaved</span>
    <span class="c1">// offsets for the buffer. Setting the offset here allows handling both cases,</span>
    <span class="c1">// with the downside that we must repeatedly bind the same buffer at different</span>
    <span class="c1">// offsets if we're dealing with interleaved attributes.</span>
    <span class="c1">// Since we only handle positions at the moment, this isn't a problem.</span>
    <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nx">setVertexBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">gpuBuffer</span><span class="p">,</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">byteOffset</span><span class="p">,</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nx">setIndexBuffer</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">gpuBuffer</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">vertexType</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">byteOffset</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nx">drawIndexed</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">indices</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">renderPassEncoder</span><span class="p">.</span><span class="nx">draw</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">positions</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="putting-it-together-to-render-the-entire-mesh">Putting it Together to Render the Entire Mesh</h2>

<p>The <code class="language-plaintext highlighter-rouge">GLTFMesh</code> versions of <code class="language-plaintext highlighter-rouge">buildRenderPipeline</code> and <code class="language-plaintext highlighter-rouge">render</code> are straightforward. We’ve delegated all the work to the primitives, where the actual geometry data lives, so the mesh just loops through its primitives and calls the respective functions.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in glb.js GLTFMesh.buildRenderPipeline and GLTFMesh.render implementations</span>
<span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                    <span class="nx">shaderModule</span><span class="p">,</span>
                    <span class="nx">colorFormat</span><span class="p">,</span>
                    <span class="nx">depthFormat</span><span class="p">,</span>
                    <span class="nx">uniformsBGLayout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We take a pretty simple approach to start. Just loop through</span>
    <span class="c1">// all the primitives and build their respective render pipelines</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
            <span class="nx">shaderModule</span><span class="p">,</span>
            <span class="nx">colorFormat</span><span class="p">,</span>
            <span class="nx">depthFormat</span><span class="p">,</span>
            <span class="nx">uniformsBGLayout</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// We take a pretty simple approach to start. Just loop through</span>
    <span class="c1">// all the primitives and call their individual draw methods</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">primitives</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">render</span><span class="p">(</span><span class="nx">renderPassEncoder</span><span class="p">,</span> <span class="nx">uniformsBG</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="rendering-a-gltf-mesh-in-our-app">Rendering a glTF Mesh in our App!</h1>

<p>With all that done, we’re ready to get the Avocado on the screen! To render the glb file we’re going to need to fetch it from the network or have the user upload it through a form, then set up its render pipeline(s) and render it. Most of our application code is the same as the previous post, with the changes that we can remove the triangle buffers and render pipeline. For the full app code, see <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/blob/main/3-first-mesh/src/app.js">app.js on Github</a>.</p>

<h2 id="loading-a-glb-file-from-the-network-or-the-user">Loading a glb File from the Network or the User</h2>

<p>To render a glb file we need to get one into our app, either by fetching it over the network or letting users of the app upload their own files to try out. I’ve packed the Avocado.glb file in the <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/tree/main/3-first-mesh/src">lesson repo</a> and have used <a href="https://webpack.js.org/">webpack</a> to bundle everything into an app. At the top of app.js we import it with webpack:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// top of app.js in the imports section</span>
<span class="k">import</span> <span class="nx">avocadoGlb</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Avocado.glb</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>Then after we’ve setup our shader module, bind group layout, swapchain, etc. as before we can fetch the file, load it and build the render pipeline.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in the async lambda in app.js</span>
<span class="c1">// Load the packaged GLB file, Avocado.glb</span>
<span class="kd">var</span> <span class="nx">glbMesh</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">avocadoGlb</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">arrayBuffer</span><span class="p">()).</span><span class="nx">then</span><span class="p">(</span><span class="nx">buf</span> <span class="o">=&gt;</span> <span class="nx">uploadGLB</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">device</span><span class="p">));</span>

<span class="nx">glbMesh</span><span class="p">.</span><span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
    <span class="nx">shaderModule</span><span class="p">,</span>
    <span class="nx">swapChainFormat</span><span class="p">,</span>
    <span class="nx">depthFormat</span><span class="p">,</span>
    <span class="nx">bindGroupLayout</span><span class="p">);</span>
</code></pre></div></div>

<p>I’ve also included a file upload form in the example app so users can upload their own glb files to try out. To support that we find the file upload form by its id and attach an <code class="language-plaintext highlighter-rouge">onchange</code> listener</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in the async lambda in app.js</span>
<span class="c1">// Setup onchange listener for file uploads</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">uploadGLB</span><span class="dl">"</span><span class="p">).</span><span class="nx">onchange</span> <span class="o">=</span>
    <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error reading GLB file</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">glbMesh</span> <span class="o">=</span> <span class="nx">uploadGLB</span><span class="p">(</span><span class="nx">reader</span><span class="p">.</span><span class="nx">result</span><span class="p">,</span> <span class="nx">device</span><span class="p">)</span>
            <span class="nx">glbMesh</span><span class="p">.</span><span class="nx">buildRenderPipeline</span><span class="p">(</span><span class="nx">device</span><span class="p">,</span>
                <span class="nx">shaderModule</span><span class="p">,</span>
                <span class="nx">swapChainFormat</span><span class="p">,</span>
                <span class="nx">depthFormat</span><span class="p">,</span>
                <span class="nx">bindGroupLayout</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsArrayBuffer</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">};</span>
</code></pre></div></div>

<h2 id="coloring-the-mesh-by-geometry-normal">Coloring the Mesh by Geometry Normal</h2>

<p>In the previous posts we passed position and color data through as vertex attributes to make our triangle look a bit more interesting. However, we now only have position data for our mesh file and need to update our shader vertex inputs. We could just color it by a solid color, but it will be hard to see the surface details of the meshes to tell if we’ve loaded them properly.</p>

<p>Instead, we can compute the geometry normal on the fly in the fragment shader by computing fragment derivatives on the world space position of the object. We can take the derivative of the position along the x and y axes and compute the cross product to find the normal. After normalizing it, the normal will be in the <code class="language-plaintext highlighter-rouge">[-1, 1]</code> range, which we can rescale into <code class="language-plaintext highlighter-rouge">[0, 1]</code> for use as a color.</p>

<p>Our updated shader code is shown below. We’ve removed the <code class="language-plaintext highlighter-rouge">color</code> attribute from the <code class="language-plaintext highlighter-rouge">VertexInput</code> struct to match the render pipeline, which now only provides position data. The position data also comes in as a <code class="language-plaintext highlighter-rouge">float3</code> from gltf, so we’ve changed the type of <code class="language-plaintext highlighter-rouge">position</code> as well. To compute the geometry normal in the fragment shader we now output the world space position from the vertex shader in the <code class="language-plaintext highlighter-rouge">VertexOutput</code> member. The fragment shader then computes fragment derivatives of <code class="language-plaintext highlighter-rouge">world_pos</code> to compute the normal.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alias</span> <span class="n">float4</span> <span class="o">=</span> <span class="kt">vec4</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">alias</span> <span class="n">float3</span> <span class="o">=</span> <span class="kt">vec3</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">VertexInput</span> <span class="p">{</span>
    <span class="err">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">position</span><span class="o">:</span> <span class="n">float3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">VertexOutput</span> <span class="p">{</span>
    <span class="err">@</span><span class="n">builtin</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="n">position</span><span class="o">:</span> <span class="n">float4</span><span class="p">,</span>
    <span class="err">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">world_pos</span><span class="o">:</span> <span class="n">float3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ViewParams</span> <span class="p">{</span>
    <span class="nl">view_proj:</span> <span class="kt">mat4x4</span><span class="o">&lt;</span><span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">};</span>

<span class="err">@</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="err">@</span><span class="n">binding</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">var</span><span class="o">&lt;</span><span class="k">uniform</span><span class="o">&gt;</span> <span class="n">view_params</span><span class="o">:</span> <span class="n">ViewParams</span><span class="p">;</span>

<span class="err">@</span><span class="n">vertex</span>
<span class="n">fn</span> <span class="n">vertex_main</span><span class="p">(</span><span class="n">vert</span><span class="o">:</span> <span class="n">VertexInput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VertexOutput</span> <span class="p">{</span>
    <span class="n">var</span> <span class="k">out</span><span class="o">:</span> <span class="n">VertexOutput</span><span class="p">;</span>
    <span class="k">out</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">view_params</span><span class="p">.</span><span class="n">view_proj</span> <span class="o">*</span> <span class="n">float4</span><span class="p">(</span><span class="n">vert</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">out</span><span class="p">.</span><span class="n">world_pos</span> <span class="o">=</span> <span class="n">vert</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">out</span><span class="p">;</span>
<span class="p">};</span>

<span class="err">@</span><span class="n">fragment</span>
<span class="n">fn</span> <span class="nf">fragment_main</span><span class="p">(</span><span class="k">in</span><span class="o">:</span> <span class="n">VertexOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="err">@</span><span class="n">location</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">float4</span> <span class="p">{</span>
    <span class="c1">// Compute the normal by taking the cross product of the</span>
    <span class="c1">// dx &amp; dy vectors computed through fragment derivatives</span>
    <span class="n">let</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">dpdx</span><span class="p">(</span><span class="k">in</span><span class="p">.</span><span class="n">world_pos</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">dpdy</span><span class="p">(</span><span class="k">in</span><span class="p">.</span><span class="n">world_pos</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">float4</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>

<h2 id="rendering-the-mesh-1">Rendering the Mesh</h2>

<p>The rest of our render pass and camera setup is the same as before. The Avocado mesh location is a bit different than the triangle we were rendering earlier, so I tweaked the camera parameters a bit to start it in a better position.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in the async lambda in app.js</span>
<span class="c1">// Adjust camera position and near/far plans to have a better view</span>
<span class="c1">// of the Avocado when it's loaded</span>
<span class="kd">var</span> <span class="nx">camera</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nx">ArcballCamera</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="mf">0.5</span><span class="p">,</span> <span class="p">[</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">]);</span>
<span class="kd">var</span> <span class="nx">proj</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span>
    <span class="nx">mat4</span><span class="p">.</span><span class="nx">create</span><span class="p">(),</span> <span class="mi">50</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span>
    <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>Our render loop is the same as before, we wait for the <code class="language-plaintext highlighter-rouge">animationFrame</code> promise, update the view parameters, and start encoding a render pass. Then we simply call <code class="language-plaintext highlighter-rouge">glbMesh.render</code> to render our mesh.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in the async lambda in app.js</span>
<span class="c1">// Render!</span>
<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">animationFrame</span><span class="p">();</span>

    <span class="c1">// Update camera buffer</span>
    <span class="nx">projView</span> <span class="o">=</span> <span class="nx">mat4</span><span class="p">.</span><span class="nx">mul</span><span class="p">(</span><span class="nx">projView</span><span class="p">,</span> <span class="nx">proj</span><span class="p">,</span> <span class="nx">camera</span><span class="p">.</span><span class="nx">camera</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">upload</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">(</span>
        <span class="p">{</span><span class="na">size</span><span class="p">:</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="na">usage</span><span class="p">:</span> <span class="nx">GPUBufferUsage</span><span class="p">.</span><span class="nx">COPY_SRC</span><span class="p">,</span> <span class="na">mappedAtCreation</span><span class="p">:</span> <span class="kc">true</span><span class="p">});</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float32Array</span><span class="p">(</span><span class="nx">upload</span><span class="p">.</span><span class="nx">getMappedRange</span><span class="p">());</span>
        <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">projView</span><span class="p">);</span>
        <span class="nx">upload</span><span class="p">.</span><span class="nx">unmap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">renderPassDesc</span><span class="p">.</span><span class="nx">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">view</span> <span class="o">=</span>
        <span class="nx">context</span><span class="p">.</span><span class="nx">getCurrentTexture</span><span class="p">().</span><span class="nx">createView</span><span class="p">();</span>

    <span class="kd">var</span> <span class="nx">commandEncoder</span> <span class="o">=</span> <span class="nx">device</span><span class="p">.</span><span class="nx">createCommandEncoder</span><span class="p">();</span>
    <span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">copyBufferToBuffer</span><span class="p">(</span><span class="nx">upload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">viewParamsBuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">renderPass</span> <span class="o">=</span> <span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">beginRenderPass</span><span class="p">(</span><span class="nx">renderPassDesc</span><span class="p">);</span>

    <span class="c1">// Render our mesh!</span>
    <span class="nx">glbMesh</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">renderPass</span><span class="p">,</span> <span class="nx">viewParamBG</span><span class="p">);</span>

    <span class="nx">renderPass</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
    <span class="nx">device</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">submit</span><span class="p">([</span><span class="nx">commandEncoder</span><span class="p">.</span><span class="nx">finish</span><span class="p">()]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="result">Result</h1>

<p>Finally after all that work, we’ve got our Avocado on the screen! I’ve embedded the app below as an iframe so you can try it out. You can also grab the code on <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/tree/main/3-first-mesh">Github</a> to run it locally or view it <a href="https://www.willusher.io/webgpu-0-to-gltf-demos/3-first-mesh/">online directly</a>.</p>

<p>Feel free to ask any questions or post comments about the post on the <a href="https://github.com/Twinklebear/webgpu-0-to-gltf/discussions/2">GitHub discussion board</a>.</p>

<div class="embed-responsive embed-responsive-4by3">
<iframe class="embed-responsive-item" src="https://www.willusher.io/webgpu-0-to-gltf-demos/3-first-mesh/index.html"></iframe>
</div>


		<hr>
		<div class="col-12 row">
			
			<div class="col-md-6 justify-content-left">
				<a href="/graphics/2023/04/11/0-to-gltf-bind-groups" title="From 0 to glTF with WebGPU: Bind Groups - Updated for Chrome 113 Release">
					<span class="fa fa-chevron-left" aria-hidden="true"></span>&nbsp Previous</a>
			</div>
			
			
			<div class="col-6 text-right">
				<a href="/graphics/2023/06/24/0-to-gltf-full-scene" title="From 0 to glTF with WebGPU: Rendering the Full glTF Scene">
					Next &nbsp<span class="fa fa-chevron-right" aria-hidden="true"></span></a>
			</div>
			
		</div>
	</div>
</div>



	</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    

    <script defer data-domain="willusher.io" src="https://pan.wushernet.com/js/script.js"></script>

</body>
</html>



